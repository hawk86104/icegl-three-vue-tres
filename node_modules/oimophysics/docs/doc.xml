<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="C:\HaxeToolkit\haxe\std/Any.hx">
		<from><icast field="__cast"><c path="__cast.T"/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="C:\HaxeToolkit\haxe\std/Any.hx" private="1" module="Any" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="C:\HaxeToolkit\haxe\std/Array.hx" extern="1">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" set="method">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" set="method">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<iterator public="1" get="inline" set="null" line="280">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="287">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<map public="1" params="S" get="inline" set="null" line="298">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="316">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<resize public="1" set="method">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
	</class>
	<abstract path="Class" params="T" file="C:\HaxeToolkit\haxe\std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="EReg" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/EReg.hx" extern="1">
		<escape public="1" set="method" static="1">
			<f a="s">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Escape the string `s` for use as a part of regular expression.

		If `s` is null, the result is unspecified.</haxe_doc>
		</escape>
		<match public="1" set="method">
			<f a="s">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `this` regular expression matches String `s`.

		This method modifies the internal state.

		If `s` is `null`, the result is unspecified.</haxe_doc>
		</match>
		<matched public="1" set="method">
			<f a="n">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the matched sub-group `n` of `this` EReg.

		This method should only be called after `this.match` or
		`this.matchSub`, and then operates on the String of that operation.

		The index `n` corresponds to the n-th set of parentheses in the pattern
		of `this` EReg. If no such sub-group exists, the result is unspecified.

		If `n` equals 0, the whole matched substring is returned.</haxe_doc>
		</matched>
		<matchedLeft public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the left of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the left of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedLeft>
		<matchedRight public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the part to the right of the last matched substring.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, only the
		substring to the right of the leftmost match is returned.

		The result does not include the matched part.</haxe_doc>
		</matchedRight>
		<matchedPos public="1" set="method">
			<f a=""><a>
	<pos><x path="Int"/></pos>
	<len><x path="Int"/></len>
</a></f>
			<haxe_doc>Returns the position and length of the last matched substring, within
		the String which was last used as argument to `this.match` or
		`this.matchSub`.

		If the most recent call to `this.match` or `this.matchSub` did not
		match anything, the result is unspecified.

		If the global g modifier was in place for the matching, the position and
		length of the leftmost substring is returned.</haxe_doc>
		</matchedPos>
		<matchSub public="1" set="method">
			<f a="s:pos:?len" v="::-1">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ len : -1 }</e></m></meta>
			<haxe_doc>Tells if `this` regular expression matches a substring of String `s`.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.match(s.substr(pos,len))` can be used instead.

		This method modifies the internal state.

		If `s` is null, the result is unspecified.</haxe_doc>
		</matchSub>
		<split public="1" set="method">
			<f a="s">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits String `s` at all substrings `this` EReg matches.

		If a match is found at the start of `s`, the result contains a leading
		empty String "" entry.

		If a match is found at the end of `s`, the result contains a trailing
		empty String "" entry.

		If two matching substrings appear next to each other, the result
		contains the empty String `""` between them.

		By default, this method splits `s` into two parts at the first matched
		substring. If the global g modifier is in place, `s` is split at each
		matched substring.

		If `s` is null, the result is unspecified.</haxe_doc>
		</split>
		<replace public="1" set="method">
			<f a="s:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replaces the first substring of `s` which `this` EReg matches with `by`.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `by` contains `$1` to `$9`, the digit corresponds to number of a
		matched sub-group and its value is used instead. If no such sub-group
		exists, the replacement is unspecified. The string `$$` becomes `$`.

		If `s` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<map public="1" set="method">
			<f a="s:f">
				<c path="String"/>
				<f a="">
					<c path="EReg"/>
					<c path="String"/>
				</f>
				<c path="String"/>
			</f>
			<haxe_doc>Calls the function `f` for the substring of `s` which `this` EReg matches
		and replaces that substring with the result of `f` call.

		The `f` function takes `this` EReg object as its first argument and should
		return a replacement string for the substring matched.

		If `this` EReg does not match any substring, the result is `s`.

		By default, this method replaces only the first matched substring. If
		the global g modifier is in place, all matched substrings are replaced.

		If `s` or `f` are null, the result is unspecified.</haxe_doc>
		</map>
		<new public="1" set="method">
			<f a="r:opt">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new regular expression with pattern `r` and modifiers `opt`.

		This is equivalent to the shorthand syntax `~/r/opt`

		If `r` or `opt` are null, the result is unspecified.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[The EReg class represents regular expressions.

	While basic usage and patterns consistently work across platforms, some more
	complex operations may yield different results. This is a necessary trade-
	off to retain a certain level of performance.

	EReg instances can be created by calling the constructor, or with the
	special syntax `~/pattern/modifier`

	EReg instances maintain an internal state, which is affected by several of
	its methods.

	A detailed explanation of the supported operations is available at
	<https://haxe.org/manual/std-regex.html>]]></haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="Enum" params="T" file="C:\HaxeToolkit\haxe\std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="C:\HaxeToolkit\haxe\std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="Map" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="C:\HaxeToolkit\haxe\std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="C:\HaxeToolkit\haxe\std/Math.hx" extern="1">
		<PI public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>Represents the ratio of the circumference of a circle to its diameter,
		specified by the constant, Ï€. `PI` is approximately `3.141592653589793`.</haxe_doc>
		</PI>
		<NEGATIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes negative infinity.

		For example, this is the result of `-1.0 / 0.0`.

		Operations with `NEGATIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</NEGATIVE_INFINITY>
		<POSITIVE_INFINITY public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes positive infinity.

		For example, this is the result of `1.0 / 0.0`.

		Operations with `POSITIVE_INFINITY` as an operand may result in
		`NEGATIVE_INFINITY`, `POSITIVE_INFINITY` or `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.</haxe_doc>
		</POSITIVE_INFINITY>
		<NaN public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>A special `Float` constant which denotes an invalid number.

		`NaN` stands for "Not a Number". It occurs when a mathematically incorrect
		operation is executed, such as taking the square root of a negative
		number: `Math.sqrt(-1)`.

		All further operations with `NaN` as an operand will result in `NaN`.

		If this constant is converted to an `Int`, e.g. through `Std.int()`, the
		result is unspecified.

		In order to test if a value is `NaN`, you should use `Math.isNaN()` function.</haxe_doc>
		</NaN>
		<abs public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of `v`.

		- If `v` is positive or `0`, the result is unchanged. Otherwise the result is `-v`.
		- If `v` is `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</abs>
		<min public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smaller of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.
		- If `a` and `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.</haxe_doc>
		</min>
		<max public="1" set="method" static="1">
			<f a="a:b">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the greater of values `a` and `b`.

		- If `a` or `b` are `NaN`, the result is `NaN`.
		- If `a` or `b` are `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `a` and `b` are `NEGATIVE_INFINITY`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</max>
		<sin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric sine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</sin>
		<cos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric cosine of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</cos>
		<tan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric tangent of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</tan>
		<asin public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc of the specified angle `v`, in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</asin>
		<acos public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc cosine of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</acos>
		<atan public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent of the specified angle `v`,
		in radians.

		If `v` is `NaN` or infinite, the result is `NaN`.</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the trigonometric arc tangent whose tangent is the quotient of
		two specified numbers, in radians.

		If parameter `x` or `y`  is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is `NaN`.</haxe_doc>
		</atan2>
		<exp public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns Euler's number, raised to the power of `v`.

		`exp(1.0)` is approximately `2.718281828459`.

		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `NEGATIVE_INFINITY`, the result is `0.0`.
		- If `v` is `NaN`, the result is `NaN`.</haxe_doc>
		</exp>
		<log public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of `v`.

		This is the mathematical inverse operation of exp,
		i.e. `log(exp(v)) == v` always holds.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `NEGATIVE_INFINITY`.</haxe_doc>
		</log>
		<pow public="1" set="method" static="1">
			<f a="v:exp">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns a specified base `v` raised to the specified power `exp`.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of `v`.

		- If `v` is negative (including `NEGATIVE_INFINITY`) or `NaN`, the result is `NaN`.
		- If `v` is `POSITIVE_INFINITY`, the result is `POSITIVE_INFINITY`.
		- If `v` is `0.0`, the result is `0.0`.</haxe_doc>
		</sqrt>
		<round public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</round>
		<floor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</floor>
		<ceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`.

		If `v` is outside of the signed `Int32` range, or is `NaN`, `NEGATIVE_INFINITY`
		or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</ceil>
		<random public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns a pseudo-random number which is greater than or equal to `0.0`,
		and less than `1.0`.</haxe_doc>
		</random>
		<ffloor public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the largest integer value that is not greater than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</ffloor>
		<fceil public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the smallest integer value that is not less than `v`, as a `Float`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fceil>
		<fround public="1" set="method" static="1">
			<f a="v">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Rounds `v` to the nearest integer value, as a Float.

		Ties are rounded up, so that `0.5` becomes `1` and `-0.5` becomes `0`.

		If `v` is is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`,
		the result is unspecified.</haxe_doc>
		</fround>
		<isFinite public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is a finite number.

		If `f` is `POSITIVE_INFINITY`, `NEGATIVE_INFINITY` or `NaN`, the result
		is `false`, otherwise the result is `true`.</haxe_doc>
		</isFinite>
		<isNaN public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `f` is not a valid number.

		If `f` is `NaN`, the result is `true`, otherwise the result is `false`.
		In particular, both `POSITIVE_INFINITY` and `NEGATIVE_INFINITY` are
		not considered `NaN`.</haxe_doc>
		</isNaN>
		<haxe_doc>This class defines mathematical functions and constants.

	@see https://haxe.org/manual/std-math.html</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="Reflect" params="" file="C:\HaxeToolkit\haxe\std/Reflect.hx" extern="1">
		<hasField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if structure `o` has a field named `field`.

		This is only guaranteed to work for anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</hasField>
		<field public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`.

		If `o` is not an object or has no field named `field`, the result is
		null.

		If the field is defined as a property, its accessors are ignored. Refer
		to `Reflect.getProperty` for a function supporting property accessors.

		If `field` is null, the result is unspecified.</haxe_doc>
		</field>
		<setField public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`.

		If `o` has no field named `field`, this function is only guaranteed to
		work for anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</setField>
		<getProperty public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>Returns the value of the field named `field` on object `o`, taking
		property getter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.field`, but might be slower.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</getProperty>
		<setProperty public="1" set="method" static="1">
			<f a="o:field:value">
				<d/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the field named `field` of object `o` to value `value`, taking
		property setter functions into account.

		If the field is not a property, this function behaves like
		`Reflect.setField`, but might be slower.

		If `field` is null, the result is unspecified.</haxe_doc>
		</setProperty>
		<callMethod public="1" set="method" static="1">
			<f a="o:func:args">
				<d/>
				<x path="haxe.Function"/>
				<c path="Array"><d/></c>
				<d/>
			</f>
			<haxe_doc>Call a method `func` with the given arguments `args`.

		The object `o` is ignored in most cases. It serves as the `this`-context in the following
		situations:

		* (neko) Allows switching the context to `o` in all cases.
		* (macro) Same as neko for Haxe 3. No context switching in Haxe 4.
		* (js, lua) Require the `o` argument if `func` does not, but should have a context.
			This can occur by accessing a function field natively, e.g. through `Reflect.field`
			or by using `(object : Dynamic).field`. However, if `func` has a context, `o` is
			ignored like on other targets.</haxe_doc>
		</callMethod>
		<fields public="1" set="method" static="1">
			<f a="o">
				<d/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns the fields of structure `o`.

		This method is only guaranteed to work on anonymous structures. Refer to
		`Type.getInstanceFields` for a function supporting class instances.

		If `o` is null, the result is unspecified.</haxe_doc>
		</fields>
		<isFunction public="1" set="method" static="1">
			<f a="f">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns true if `f` is a function, false otherwise.

		If `f` is null, the result is false.</haxe_doc>
		</isFunction>
		<compare public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="compare.T"/>
				<c path="compare.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Compares `a` and `b`.

		If `a` is less than `b`, the result is negative. If `b` is less than
		`a`, the result is positive. If `a` and `b` are equal, the result is 0.

		This function is only defined if `a` and `b` are of the same type.

		If that type is a function, the result is unspecified and
		`Reflect.compareMethods` should be used instead.

		For all other types, the result is 0 if `a` and `b` are equal. If they
		are not equal, the result depends on the type and is negative if:

		- Numeric types: a is less than b
		- String: a is lexicographically less than b
		- Other: unspecified

		If `a` and `b` are null, the result is 0. If only one of them is null,
		the result is unspecified.</haxe_doc>
		</compare>
		<compareMethods public="1" set="method" static="1">
			<f a="f1:f2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Compares the functions `f1` and `f2`.

		If `f1` or `f2` are null, the result is false.
		If `f1` or `f2` are not functions, the result is unspecified.

		Otherwise the result is true if `f1` and the `f2` are physically equal,
		false otherwise.

		If `f1` or `f2` are member method closures, the result is true if they
		are closures of the same method on the same object value, false otherwise.</haxe_doc>
		</compareMethods>
		<isObject public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc><![CDATA[Tells if `v` is an object.

		The result is true if `v` is one of the following:

		- class instance
		- structure
		- `Class<T>`
		- `Enum<T>`

		Otherwise, including if `v` is null, the result is false.]]></haxe_doc>
		</isObject>
		<isEnumValue public="1" set="method" static="1">
			<f a="v">
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if `v` is an enum value.

		The result is true if `v` is of type EnumValue, i.e. an enum
		constructor.

		Otherwise, including if `v` is null, the result is false.</haxe_doc>
		</isEnumValue>
		<deleteField public="1" set="method" static="1">
			<f a="o:field">
				<d/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the field named `field` from structure `o`.

		This method is only guaranteed to work on anonymous structures.

		If `o` or `field` are null, the result is unspecified.</haxe_doc>
		</deleteField>
		<copy public="1" params="T" set="method" static="1">
			<f a="o">
				<x path="Null"><c path="copy.T"/></x>
				<x path="Null"><c path="copy.T"/></x>
			</f>
			<haxe_doc>Copies the fields of structure `o`.

		This is only guaranteed to work on anonymous structures.

		If `o` is null, the result is `null`.</haxe_doc>
		</copy>
		<makeVarArgs public="1" set="method" static="1">
			<f a="f">
				<f a="">
					<c path="Array"><d/></c>
					<d/>
				</f>
				<d/>
			</f>
			<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
			<overloads><makeVarArgs public="1" set="method">
	<f a="f">
		<f a="">
			<c path="Array"><d/></c>
			<x path="Void"/>
		</f>
		<d/>
	</f>
	<haxe_doc>Transform a function taking an array of arguments into a function that can
		be called with any number of arguments.</haxe_doc>
</makeVarArgs></overloads>
		</makeVarArgs>
		<haxe_doc>The Reflect API is a way to manipulate values dynamically through an
	abstract interface in an untyped manner. Use with care.

	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
	</class>
	<class path="Std" params="" file="C:\HaxeToolkit\haxe\std/Std.hx" extern="1">
		<is public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.is is deprecated. Use Std.isOfType instead."</e></m></meta>
			<haxe_doc>DEPRECATED. Use `Std.isOfType(v, t)` instead.

		Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</is>
		<isOfType public="1" set="method" static="1">
			<f a="v:t">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Tells if a value `v` is of the type `t`. Returns `false` if `v` or `t` are null.

		If `t` is a class or interface with `@:generic` meta, the result is `false`.</haxe_doc>
		</isOfType>
		<downcast public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="downcast.T"/>
				<x path="Class"><c path="downcast.S"/></x>
				<c path="downcast.S"/>
			</f>
			<haxe_doc>Checks if object `value` is an instance of class or interface `c`.

		Compiles only if the type specified by `c` can be assigned to the type
		of `value`.

		This method checks if a downcast is possible. That is, if the runtime
		type of `value` is assignable to the type specified by `c`, `value` is
		returned. Otherwise null is returned.

		This method is not guaranteed to work with core types such as `String`,
		`Array` and `Date`.

		If `value` is null, the result is null. If `c` is null, the result is
		unspecified.</haxe_doc>
		</downcast>
		<instance public="1" params="T:S" set="method" static="1">
			<f a="value:c">
				<c path="instance.T"/>
				<x path="Class"><c path="instance.S"/></x>
				<c path="instance.S"/>
			</f>
			<meta><m n=":deprecated"><e>"Std.instance() is deprecated. Use Std.downcast() instead."</e></m></meta>
		</instance>
		<string public="1" set="method" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		If `x` starts with 0x or 0X, hexadecimal notation is recognized where the following digits may
		contain 0-9 and A-F.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. `x` may also start with
		a - to denote a negative value.

		In decimal mode, parsing continues until an invalid character is detected, in which case the
		result up to that point is returned. For hexadecimal notation, the effect of invalid characters
		is unspecified.

		Leading 0s that are not part of the 0x/0X hexadecimal notation are ignored, which means octal
		notation is not supported.

		If `x` is null, the result is unspecified.
		If `x` cannot be parsed as integer, the result is `null`.</haxe_doc>
		</parseInt>
		<parseFloat public="1" set="method" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Converts a `String` to a `Float`.

		The parsing rules for `parseInt` apply here as well, with the exception of invalid input
		resulting in a `NaN` value instead of null.

		Additionally, decimal notation may contain a single `.` to denote the start of the fractions.</haxe_doc>
		</parseFloat>
		<random public="1" set="method" static="1">
			<f a="x">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc><![CDATA[Return a random integer between 0 included and `x` excluded.

		If `x <= 1`, the result is always 0.]]></haxe_doc>
		</random>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="Void" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="C:\HaxeToolkit\haxe\std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<class path="String" params="" file="C:\HaxeToolkit\haxe\std/String.hx" extern="1">
		<fromCharCode public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<charAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" set="method">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<indexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<substr public="1" set="method">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<substring public="1" set="method">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
	</class>
	<class path="StringBuf" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/StringBuf.hx" extern="1">
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` StringBuf in characters.</haxe_doc>
		</length>
		<get_length set="method"><f a=""><x path="Int"/></f></get_length>
		<add public="1" params="T" set="method">
			<f a="x">
				<c path="add.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the representation of `x` to `this` StringBuf.

		The exact representation of `x` may vary per platform. To get more
		consistent behavior, this function should be called with
		Std.string(x).

		If `x` is null, the String "null" is appended.</haxe_doc>
		</add>
		<addChar public="1" set="method">
			<f a="c">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends the character identified by `c` to `this` StringBuf.

		If `c` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</addChar>
		<addSub public="1" set="method">
			<f a="s:pos:?len">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Appends a substring of `s` to `this` StringBuf.

		This function expects `pos` and `len` to describe a valid substring of
		`s`, or else the result is unspecified. To get more robust behavior,
		`this.add(s.substr(pos,len))` can be used instead.

		If `s` or `pos` are null, the result is unspecified.

		If `len` is omitted or null, the substring ranges from `pos` to the end
		of `s`.</haxe_doc>
		</addSub>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the content of `this` StringBuf as String.

		The buffer is not emptied by this operation.</haxe_doc>
		</toString>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringBuf instance.

		This may involve initialization of the internal buffer.</haxe_doc>
		</new>
		<haxe_doc>A String buffer is an efficient way to build a big string by appending small
	elements together.

	Unlike String, an instance of StringBuf is not immutable in the sense that
	it can be passed as argument to functions which modify it by appending more
	values.</haxe_doc>
		<meta><m n=":coreApi"/></meta>
	</class>
	<class path="Sys" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/Sys.hx">
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":require"><e>sys</e></m>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="C:\HaxeToolkit\haxe\std/Type.hx" extern="1">
		<getClass public="1" params="T" set="method" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<getEnum public="1" set="method" static="1">
			<f a="o">
				<x path="EnumValue"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc><![CDATA[Returns the enum of enum instance `o`.

		An enum instance is the result of using an enum constructor. Given an
		`enum Color { Red; }`, `getEnum(Red)` returns `Enum<Color>`.

		If `o` is null, null is returned.

		In general, type parameter information cannot be obtained at runtime.]]></haxe_doc>
		</getEnum>
		<getSuperClass public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Returns the super-class of class `c`.

		If `c` has no super class, null is returned.

		If `c` is null, the result is unspecified.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getSuperClass>
		<getClassName public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of class `c`, including its path.

		If `c` is inside a package, the package structure is returned dot-
		separated, with another dot separating the class name:
		`pack1.pack2.(...).packN.ClassName`
		If `c` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `c` has no package, the class name is returned.

		If `c` is null, the result is unspecified.

		The class name does not include any type parameters.</haxe_doc>
		</getClassName>
		<getEnumName public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		`pack1.pack2.(...).packN.EnumName`
		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is null, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getEnumName>
		<resolveClass public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Class"><d/></x>
			</f>
			<haxe_doc>Resolves a class by name.

		If `name` is the path of an existing class, that class is returned.

		Otherwise null is returned.

		If `name` is null or the path to a different type, the result is
		unspecified.

		The class name must not include any type parameters.</haxe_doc>
		</resolveClass>
		<resolveEnum public="1" set="method" static="1">
			<f a="name">
				<c path="String"/>
				<x path="Enum"><d/></x>
			</f>
			<haxe_doc>Resolves an enum by name.

		If `name` is the path of an existing enum, that enum is returned.

		Otherwise null is returned.

		If `name` is null the result is unspecified.

		If `name` is the path to a different type, null is returned.

		The enum name must not include any type parameters.</haxe_doc>
		</resolveEnum>
		<createInstance public="1" params="T" set="method" static="1">
			<f a="cl:args">
				<x path="Class"><c path="createInstance.T"/></x>
				<c path="Array"><d/></c>
				<c path="createInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`, using `args` as arguments to the
		class constructor.

		This function guarantees that the class constructor is called.

		Default values of constructors arguments are not guaranteed to be
		taken into account.

		If `cl` or `args` are null, or if the number of elements in `args` does
		not match the expected number of constructor arguments, or if any
		argument has an invalid type,  or if `cl` has no own constructor, the
		result is unspecified.

		In particular, default values of constructor arguments are not
		guaranteed to be taken into account.</haxe_doc>
		</createInstance>
		<createEmptyInstance public="1" params="T" set="method" static="1">
			<f a="cl">
				<x path="Class"><c path="createEmptyInstance.T"/></x>
				<c path="createEmptyInstance.T"/>
			</f>
			<haxe_doc>Creates an instance of class `cl`.

		This function guarantees that the class constructor is not called.

		If `cl` is null, the result is unspecified.</haxe_doc>
		</createEmptyInstance>
		<createEnum public="1" params="T" set="method" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createEnum.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createEnum.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnum>
		<createEnumIndex public="1" params="T" set="method" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createEnumIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createEnumIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `constr` is null, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createEnumIndex>
		<getInstanceFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the instance fields of class `c`, including
		inherited fields.

		This only includes fields which are known at compile-time. In
		particular, using `getInstanceFields(getClass(obj))` will not include
		any fields which were added to `obj` at runtime.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getInstanceFields>
		<getClassFields public="1" set="method" static="1">
			<f a="c">
				<x path="Class"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of static fields of class `c`.

		This does not include static fields of parent classes.

		The order of the fields in the returned Array is unspecified.

		If `c` is null, the result is unspecified.</haxe_doc>
		</getClassFields>
		<getEnumConstructs public="1" set="method" static="1">
			<f a="e">
				<x path="Enum"><d/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `e` is null, the result is unspecified.</haxe_doc>
		</getEnumConstructs>
		<typeof public="1" set="method" static="1">
			<f a="v">
				<d/>
				<e path="ValueType"/>
			</f>
			<haxe_doc>Returns the runtime type of value `v`.

		The result corresponds to the type `v` has at runtime, which may vary
		per platform. Assumptions regarding this should be minimized to avoid
		surprises.</haxe_doc>
		</typeof>
		<enumEq public="1" params="T" set="method" static="1">
			<f a="a:b">
				<c path="enumEq.T"/>
				<c path="enumEq.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors, if exists.

		If `a` or `b` are null, the result is unspecified.</haxe_doc>
		</enumEq>
		<enumConstructor public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumConstructor>
		<enumParameters public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is [].

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumParameters>
		<enumIndex public="1" set="method" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is null, the result is unspecified.</haxe_doc>
		</enumIndex>
		<allEnums public="1" params="T" set="method" static="1">
			<f a="e">
				<x path="Enum"><c path="allEnums.T"/></x>
				<c path="Array"><c path="allEnums.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is null, the result is unspecified.</haxe_doc>
		</allEnums>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
	</class>
	<class path="eval.Vector" params="T" file="C:\HaxeToolkit\haxe\std/eval/Vector.hx" extern="1">
		<fromArrayCopy public="1" params="T" set="method" static="1"><f a="array">
	<c path="Array"><c path="fromArrayCopy.T"/></c>
	<c path="eval.Vector"><c path="fromArrayCopy.T"/></c>
</f></fromArrayCopy>
		<length public="1" set="null"><x path="Int"/></length>
		<blit public="1" params="T" set="method"><f a="srcPos:dest:destPos:len">
	<x path="Int"/>
	<c path="eval.Vector"><c path="blit.T"/></c>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<toArray public="1" set="method"><f a=""><c path="Array"><c path="eval.Vector.T"/></c></f></toArray>
		<copy public="1" params="T" set="method"><f a=""><c path="eval.Vector"><c path="copy.T"/></c></f></copy>
		<join public="1" params="T" set="method"><f a="sep">
	<c path="String"/>
	<c path="String"/>
</f></join>
		<map public="1" params="S" set="method"><f a="f">
	<f a="">
		<c path="eval.Vector.T"/>
		<c path="map.S"/>
	</f>
	<c path="eval.Vector"><c path="map.S"/></c>
</f></map>
		<new public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<abstract path="eval.integers.Int64" params="" file="C:\HaxeToolkit\haxe\std/eval/integers/Int64.hx">
		<from><icast field="ofHxInt64"><x path="haxe.Int64"/></icast></from>
		<this><x path="eval.integers.Int64"/></this>
		<to><icast field="toHxInt64"><x path="haxe.Int64"/></icast></to>
		<haxe_doc>Signed 64-bit integer type and operations.</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="eval.integers._Int64.Int64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/integers/Int64.hx" private="1" module="eval.integers.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="eval.integers.UInt64" params="" file="C:\HaxeToolkit\haxe\std/eval/integers/UInt64.hx">
		<this><x path="eval.integers.UInt64"/></this>
		<haxe_doc>Unsigned 64-bit integer type and operations.</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="eval.integers._UInt64.UInt64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/integers/UInt64.hx" private="1" module="eval.integers.UInt64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="eval.luv.Async" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Async.hx">
		<this><x path="eval.luv.Async"/></this>
		<to><icast><x path="eval.luv.Handle"/></icast></to>
		<haxe_doc>Inter-loop communication.

	@see https://aantron.github.io/luv/luv/Luv/Async</haxe_doc>
		<meta>
			<m n=":using"><e>eval.luv.Handle</e></m>
			<m n=":coreType"/>
		</meta>
		<impl><class path="eval.luv._Async.Async_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Async.hx" private="1" module="eval.luv.Async" final="1">
	<init public="1" set="method" static="1">
		<f a="loop:callback">
			<x path="eval.luv.Loop"/>
			<f a="async">
				<x path="eval.luv.Async"/>
				<x path="Void"/>
			</f>
			<e path="eval.luv.Result"><x path="eval.luv.Async"/></e>
		</f>
		<meta><m n=":noExpr"/></meta>
		<haxe_doc>Allocates and initializes an async handle.

		The handle should be cleaned up with `eval.luv.Handle.close` when no longer needed.</haxe_doc>
	</init>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":using"><e>eval.luv.Handle</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="eval.luv._Async.Async_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Async.hx" private="1" module="eval.luv.Async" final="1">
		<init public="1" set="method" static="1">
			<f a="loop:callback">
				<x path="eval.luv.Loop"/>
				<f a="async">
					<x path="eval.luv.Async"/>
					<x path="Void"/>
				</f>
				<e path="eval.luv.Result"><x path="eval.luv.Async"/></e>
			</f>
			<meta><m n=":noExpr"/></meta>
			<haxe_doc>Allocates and initializes an async handle.

		The handle should be cleaned up with `eval.luv.Handle.close` when no longer needed.</haxe_doc>
		</init>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":using"><e>eval.luv.Handle</e></m>
		</meta>
	</class>
	<abstract path="eval.luv.SocketHandle" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Handle.hx" module="eval.luv.Handle">
		<this><x path="eval.luv.SocketHandle"/></this>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="eval.luv.Handle" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Handle.hx">
		<this><x path="eval.luv.Handle"/></this>
		<haxe_doc>Handles.

	@see https://aantron.github.io/luv/luv/Luv/Handle</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="eval.luv._Handle.Handle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Handle.hx" private="1" module="eval.luv.Handle" final="1">
	<unref public="1" set="method" static="1">
		<f a="handle">
			<x path="eval.luv.Handle"/>
			<x path="Void"/>
		</f>
		<meta><m n=":noExpr"/></meta>
		<haxe_doc>Un-reference the given handle.

		@see https://aantron.github.io/luv/luv/Luv/Handle/#val-unref</haxe_doc>
	</unref>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="eval.luv._Handle.Handle_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Handle.hx" private="1" module="eval.luv.Handle" final="1">
		<unref public="1" set="method" static="1">
			<f a="handle">
				<x path="eval.luv.Handle"/>
				<x path="Void"/>
			</f>
			<meta><m n=":noExpr"/></meta>
			<haxe_doc>Un-reference the given handle.

		@see https://aantron.github.io/luv/luv/Luv/Handle/#val-unref</haxe_doc>
		</unref>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="eval.luv.RunMode" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" module="eval.luv.Loop">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="eval.luv._Loop.RunMode_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" private="1" module="eval.luv.Loop" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="eval.luv.LoopOption" params="T" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" module="eval.luv.Loop">
		<this><x path="Int"/></this>
		<haxe_doc>Configuration options.
	@see http://docs.libuv.org/en/v1.x/loop.html#c.uv_loop_configure</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="eval.luv._Loop.LoopOption_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" private="1" module="eval.luv.Loop" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="eval.luv.Loop" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx">
		<from><icast field="fromHaxeEventLoop"><c path="sys.thread.EventLoop"/></icast></from>
		<this><x path="eval.luv.Loop"/></this>
		<haxe_doc>Event loops.

	@see https://aantron.github.io/luv/luv/Luv/Loop

	Haxe event loops define an implicit cast to libuv loops. That is, you can use
	`sys.thread.Thread.current().events` in any place where `eval.luv.Loop` is
	expected.</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="eval.luv._Loop.Loop_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" private="1" module="eval.luv.Loop" final="1">
	<init public="1" set="method" static="1">
		<f a=""><e path="eval.luv.Result"><x path="eval.luv.Loop"/></e></f>
		<meta><m n=":noExpr"/></meta>
		<haxe_doc>Allocates and initializes a new event loop.</haxe_doc>
	</init>
	<run public="1" set="method" static="1">
		<f a="this:mode">
			<x path="eval.luv.Loop"/>
			<x path="eval.luv.RunMode"/>
			<x path="Bool"/>
		</f>
		<meta><m n=":noExpr"/></meta>
		<haxe_doc>Runs an event loop.</haxe_doc>
	</run>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
	</meta>
</class></impl>
	</abstract>
	<class path="eval.luv._Loop.Loop_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Loop.hx" private="1" module="eval.luv.Loop" final="1">
		<init public="1" set="method" static="1">
			<f a=""><e path="eval.luv.Result"><x path="eval.luv.Loop"/></e></f>
			<meta><m n=":noExpr"/></meta>
			<haxe_doc>Allocates and initializes a new event loop.</haxe_doc>
		</init>
		<run public="1" set="method" static="1">
			<f a="this:mode">
				<x path="eval.luv.Loop"/>
				<x path="eval.luv.RunMode"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":noExpr"/></meta>
			<haxe_doc>Runs an event loop.</haxe_doc>
		</run>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.Exception" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/Exception.hx">
		<thrown set="method" line="25" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__nativeStack>
			<x path="haxe.CallStack"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<toString public="1" set="method" line="52">
			<f a=""><c path="String"/></f>
			<meta><m n=":ifFeature"><e>"haxe.Exception.thrown"</e></m></meta>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<get_message set="method" line="66"><f a=""><c path="String"/></f></get_message>
		<get_native final="1" set="method" line="74"><f a=""><x path="Any"/></f></get_native>
		<new public="1" set="method" line="35">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="eval.luv.LuvException" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/LuvException.hx">
		<extends path="haxe.Exception"/>
		<error final="1" public="1">
			<x path="eval.luv.UVError"/>
			<haxe_doc>The error.</haxe_doc>
		</error>
		<new public="1" set="method" line="15">
			<f a="error:?message:?previous">
				<x path="eval.luv.UVError"/>
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Instantiates an error with given message and position.</haxe_doc>
		</new>
		<haxe_doc>Exceptions thrown by functions in `eval.luv` package.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<enum path="eval.luv.Result" params="T" file="C:\HaxeToolkit\haxe\std/eval/luv/Result.hx">
		<Ok a="value">
			<c path="eval.luv.Result.T"/>
			<haxe_doc>Operation completed successfully.</haxe_doc>
		</Ok>
		<Error a="e">
			<x path="eval.luv.UVError"/>
			<haxe_doc>Operation failed.</haxe_doc>
		</Error>
		<haxe_doc>Outcome of an operation.</haxe_doc>
		<meta><m n=":using"><e>eval.luv.Result.ResultTools</e></m></meta>
	</enum>
	<abstract path="eval.luv.NoData" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Result.hx" module="eval.luv.Result">
		<this><d/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="eval.luv._Result.NoData_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Result.hx" private="1" module="eval.luv.Result" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="eval.luv.Timer" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Timer.hx">
		<this><x path="eval.luv.Timer"/></this>
		<to><icast><x path="eval.luv.Handle"/></icast></to>
		<haxe_doc>Timers.

	@see https://aantron.github.io/luv/luv/Luv/Timer</haxe_doc>
		<meta>
			<m n=":using"><e>eval.luv.Handle</e></m>
			<m n=":coreType"/>
		</meta>
		<impl><class path="eval.luv._Timer.Timer_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/Timer.hx" private="1" module="eval.luv.Timer" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>eval.luv.Handle</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="eval.luv.UVError" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/UVError.hx">
		<this><x path="Int"/></this>
		<haxe_doc>Error handling.

	@see https://aantron.github.io/luv/luv/Luv/Error</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="eval.luv._UVError.UVError_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/UVError.hx" private="1" module="eval.luv.UVError" extern="1" final="1"><meta>
	<m n=":keep"/>
	<m n=":directlyUsed"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="eval.luv._UVError.UVError_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/luv/UVError.hx" private="1" module="eval.luv.UVError" extern="1" final="1"><meta>
	<m n=":keep"/>
	<m n=":directlyUsed"/>
	<m n=":enum"/>
</meta></class>
	<class path="eval.vm.Context" params="" file="C:\HaxeToolkit\haxe\std/eval/vm/Context.hx" extern="1">
		<addBreakpoint public="1" set="method" static="1"><f a="file:line">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBreakpoint>
		<breakHere public="1" set="method" static="1"><f a=""><x path="Void"/></f></breakHere>
		<callMacroApi public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<d/>
</f></callMacroApi>
		<loadPlugin public="1" params="T" set="method" static="1">
			<f a="filePath">
				<c path="String"/>
				<c path="loadPlugin.T"/>
			</f>
			<haxe_doc><![CDATA[Loads and returns a plugin from file `filePath`.

		If Haxe is built natively, the extension automatically defaults to `.cmxs`,
		even if a different extension is provided in `filePath`. In bytecode mode,
		the default extension is `.cmo`.

		Sample plugin:

		```ocaml
		open EvalValue
		open EvalContext
		open EvalEncode

		let add_int = vfun2 (fun v1 v2 -> match v1,v2 with
			| VInt32 i1,VInt32 i2 -> vint32 (Int32.add i1 i2)
			| _ -> exc_string "Expected int + int"
		)
		;;
		EvalStdLib.StdContext.register ["add_int",add_int]
		```

		Usage from Haxe:

		```haxe
		var module:TestPlugin = eval.vm.Context.loadPlugin("testPlugin.cmo");
		trace(module.add_int(4, 3));
		```

		Plugins have to be compiled with the same OCaml version as the Haxe compiler
		and using the same Haxe version. If a plugin cannot be loaded, an exception
		of type `String` is thrown.]]></haxe_doc>
		</loadPlugin>
	</class>
	<class path="eval.vm.NativeThread" params="" file="C:\HaxeToolkit\haxe\std/eval/vm/NativeThread.hx" extern="1">
		<delay public="1" set="method" static="1">
			<f a="f">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends the execution of the calling thread for `f` seconds. The other program
		threads continue to run during this time.</haxe_doc>
		</delay>
		<exit public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Terminate prematurely the currently executing thread.</haxe_doc>
		</exit>
		<join public="1" set="method" static="1">
			<f a="thread">
				<c path="eval.vm.NativeThread"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends the execution of the calling thread until the thread `thread` has
		terminated.</haxe_doc>
		</join>
		<self public="1" set="method" static="1">
			<f a=""><c path="eval.vm.NativeThread"/></f>
			<haxe_doc>Return the thread currently executing.</haxe_doc>
		</self>
		<yield public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Re-schedule the calling thread without suspending it. This function can be used
		to give scheduling hints, telling the scheduler that now is a good time to switch
		to other threads.</haxe_doc>
		</yield>
		<readMessage public="1" params="T" set="method" static="1"><f a="block">
	<x path="Bool"/>
	<c path="readMessage.T"/>
</f></readMessage>
		<id public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Return the identifier of the given thread. A thread identifier is an integer
		that identifies uniquely the thread. It can be used to build data structures
		indexed by threads.</haxe_doc>
		</id>
		<kill public="1" set="method">
			<f a=""><x path="Int"/></f>
			<haxe_doc>Terminate prematurely the thread whose handle is given. This functionality is
		available only with bytecode-level threads.</haxe_doc>
		</kill>
		<sendMessage public="1" params="T" set="method"><f a="msg">
	<c path="sendMessage.T"/>
	<x path="Void"/>
</f></sendMessage>
		<events get="null" set="null">
			<x path="Null"><c path="sys.thread.EventLoop"/></x>
			<meta><m n=":allow"><e>sys.thread.Thread</e></m></meta>
		</events>
		<new public="1" set="method">
			<f a="f">
				<f a=""><x path="Void"/></f>
				<x path="Void"/>
			</f>
			<haxe_doc>Creates a new thread that executes function `f`.

		Exceptions caused while executing `f` are printed to stderr and are not
		propagated to the parent thread.</haxe_doc>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="export.Export" params="" file="exports/src/export/Export.hx">
		<main set="method" line="126" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</main>
		<haxe_doc>* this class just imports all the classes in the library</haxe_doc>
	</class>
	<enum path="haxe.StackItem" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
	</enum>
	<abstract path="haxe.CallStack" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1"><meta>
	<m n=":keep"/>
	<m n=":using"><e>haxe.CallStack</e></m>
	<m n=":allow"><e>haxe.Exception</e></m>
</meta></class></impl>
	</abstract>
	<abstract path="haxe.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.EnumTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:
		
			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="C:\HaxeToolkit\haxe\std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="133" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="144" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="158" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="170" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<abstract path="haxe.Int32" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="C:\HaxeToolkit\haxe\std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.Log" params="" file="C:\HaxeToolkit\haxe\std/haxe/Log.hx">
		<formatOutput public="1" set="method" line="33" static="1">
			<f a="v:infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<c path="String"/>
			</f>
			<haxe_doc>Format the output of `trace` before printing it.</haxe_doc>
		</formatOutput>
		<trace public="1" set="dynamic" line="62" static="1">
			<f a="v:?infos">
				<d/>
				<t path="haxe.PosInfos"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Outputs `v` in a platform-dependent way.

		The second parameter `infos` is injected by the compiler and contains
		information about the position where the `trace()` call was made.

		This method can be rebound to a custom function:

			var oldTrace = haxe.Log.trace; // store old function
			haxe.Log.trace = function(v, ?infos) {
			  // handle trace
			}
			...
			haxe.Log.trace = oldTrace;

		If it is bound to null, subsequent calls to `trace()` will cause an
		exception.</haxe_doc>
		</trace>
		<haxe_doc>Log primarily provides the `trace()` method, which is invoked upon a call to
	`trace()` in Haxe code.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.NativeStackTrace" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="15" static="1"><f a=""><c path="Array"><e path="haxe.StackItem"/></c></f></callStack>
		<_callStack set="method" line="20" static="1"><f a=""><c path="Array"><e path="haxe.StackItem"/></c></f></_callStack>
		<exceptionStack public="1" set="method" line="25" static="1"><f a=""><c path="Array"><e path="haxe.StackItem"/></c></f></exceptionStack>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="C:\HaxeToolkit\haxe\std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<class path="haxe.ValueException" params="" file="C:\HaxeToolkit\haxe\std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.HashMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx">
		<this><c path="haxe.ds._HashMap.HashMapData">
	<c path="haxe.ds.HashMap.K"/>
	<c path="haxe.ds.HashMap.V"/>
</c></this>
		<haxe_doc>HashMap allows mapping of hashable objects to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
		<impl><class path="haxe.ds._HashMap.HashMap_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/HashMap.hx" private="1" module="haxe.ds.HashMap" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.IntMap" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/IntMap.hx" extern="1">
		<implements path="haxe.IMap">
			<x path="Int"/>
			<c path="haxe.ds.IntMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<x path="Int"/>
				<c path="haxe.ds.IntMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Null"><c path="haxe.ds.IntMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><x path="Int"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.IntMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="78">
			<f a=""><t path="KeyValueIterator">
	<x path="Int"/>
	<c path="haxe.ds.IntMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.IntMap"><c path="haxe.ds.IntMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new IntMap.</haxe_doc>
		</new>
		<haxe_doc>IntMap allows mapping of Int keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="K:V" file="C:\HaxeToolkit\haxe\std/haxe/ds/ObjectMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.K"/>
			<c path="haxe.ds.ObjectMap.V"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="haxe.ds.ObjectMap.K"/>
				<c path="haxe.ds.ObjectMap.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.V"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="haxe.ds.ObjectMap.K"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.K"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.V"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="81">
			<f a=""><t path="KeyValueIterator">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.ObjectMap">
	<c path="haxe.ds.ObjectMap.K"/>
	<c path="haxe.ds.ObjectMap.V"/>
</c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new ObjectMap.</haxe_doc>
		</new>
		<haxe_doc>ObjectMap allows mapping of object keys to arbitrary values.

	On static targets, the keys are considered to be strong references. Refer
	to `haxe.ds.WeakMap` for a weak reference version.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/StringMap.hx" extern="1">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<set public="1" set="method">
			<f a="key:value">
				<c path="String"/>
				<c path="haxe.ds.StringMap.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>See `Map.set`</haxe_doc>
		</set>
		<get public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<haxe_doc>See `Map.get`</haxe_doc>
		</get>
		<exists public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.exists`</haxe_doc>
		</exists>
		<remove public="1" set="method">
			<f a="key">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>See `Map.remove`</haxe_doc>
		</remove>
		<keys public="1" set="method">
			<f a=""><t path="Iterator"><c path="String"/></t></f>
			<haxe_doc>See `Map.keys`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</keys>
		<iterator public="1" set="method">
			<f a=""><t path="Iterator"><c path="haxe.ds.StringMap.T"/></t></f>
			<haxe_doc>See `Map.iterator`

		(cs, java) Implementation detail: Do not `set()` any new value while
		iterating, as it may cause a resize, which will break iteration.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="78">
			<f a=""><t path="KeyValueIterator">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</t></f>
			<meta><m n=":runtime"/></meta>
			<haxe_doc>See `Map.keyValueIterator`</haxe_doc>
		</keyValueIterator>
		<copy public="1" set="method">
			<f a=""><c path="haxe.ds.StringMap"><c path="haxe.ds.StringMap.T"/></c></f>
			<haxe_doc>See `Map.copy`</haxe_doc>
		</copy>
		<toString public="1" set="method">
			<f a=""><c path="String"/></f>
			<haxe_doc>See `Map.toString`</haxe_doc>
		</toString>
		<clear public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>See `Map.clear`</haxe_doc>
		</clear>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a new StringMap.</haxe_doc>
		</new>
		<haxe_doc>StringMap allows mapping of String keys to arbitrary values.

	See `Map` for documentation details.

	@see https://haxe.org/manual/std-Map.html</haxe_doc>
	</class>
	<typedef path="haxe.ds._Vector.VectorData" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector"><c path="eval.Vector"><c path="haxe.ds._Vector.VectorData.T"/></c></typedef>
	<abstract path="haxe.ds.Vector" params="T" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx">
		<this><t path="haxe.ds._Vector.VectorData"><c path="haxe.ds.Vector.T"/></t></this>
		<haxe_doc>A Vector is a storage of fixed size. It can be faster than Array on some
	targets, and is never slower.

	@see https://haxe.org/manual/std-vector.html</haxe_doc>
		<impl><class path="haxe.ds._Vector.Vector_Impl_" params="" file="C:\HaxeToolkit\haxe\std/haxe/ds/Vector.hx" private="1" module="haxe.ds.Vector" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<enum path="haxe.io.Error" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Error.hx">
		<Blocked><haxe_doc>The IO is set into nonblocking mode and some data cannot be read or written</haxe_doc></Blocked>
		<Overflow><haxe_doc>An integer value is outside its allowed range</haxe_doc></Overflow>
		<OutsideBounds><haxe_doc>An operation on Bytes is outside of its valid range</haxe_doc></OutsideBounds>
		<Custom a="e">
			<d/>
			<haxe_doc>Other errors</haxe_doc>
		</Custom>
		<haxe_doc>The possible IO errors that can occur</haxe_doc>
		<meta><m n=":keep"/></meta>
	</enum>
	<class path="haxe.io.Bytes" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/io/Bytes.hx" extern="1">
		<alloc public="1" set="method" static="1"><f a="length">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></alloc>
		<ofString public="1" set="method" static="1"><f a="s:?encoding">
	<c path="String"/>
	<e path="haxe.io.Encoding"/>
	<c path="haxe.io.Bytes"/>
</f></ofString>
		<ofData public="1" set="method" static="1"><f a="b">
	<t path="haxe.io.BytesData"/>
	<c path="haxe.io.Bytes"/>
</f></ofData>
		<ofHex public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<c path="haxe.io.Bytes"/>
</f></ofHex>
		<fastGet public="1" set="method" static="1"><f a="b:pos">
	<t path="haxe.io.BytesData"/>
	<x path="Int"/>
	<x path="Int"/>
</f></fastGet>
		<length public="1" set="null"><x path="Int"/></length>
		<get public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></get>
		<set public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></set>
		<blit public="1" set="method"><f a="pos:src:srcpos:len">
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></blit>
		<fill public="1" set="method"><f a="pos:len:value">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></fill>
		<sub public="1" set="method"><f a="pos:len">
	<x path="Int"/>
	<x path="Int"/>
	<c path="haxe.io.Bytes"/>
</f></sub>
		<compare public="1" set="method"><f a="other">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
</f></compare>
		<getDouble public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="Float"/>
</f></getDouble>
		<getFloat public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="Float"/>
</f></getFloat>
		<setDouble public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setDouble>
		<setFloat public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setFloat>
		<getUInt16 public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></getUInt16>
		<setUInt16 public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setUInt16>
		<getInt32 public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="Int"/>
</f></getInt32>
		<getInt64 public="1" set="method"><f a="pos">
	<x path="Int"/>
	<x path="haxe.Int64"/>
</f></getInt64>
		<setInt32 public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setInt32>
		<setInt64 public="1" set="method"><f a="pos:v">
	<x path="Int"/>
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></setInt64>
		<getString public="1" set="method"><f a="pos:len:?encoding">
	<x path="Int"/>
	<x path="Int"/>
	<e path="haxe.io.Encoding"/>
	<c path="String"/>
</f></getString>
		<toString public="1" set="method"><f a=""><c path="String"/></f></toString>
		<toHex public="1" set="method"><f a=""><c path="String"/></f></toHex>
		<getData public="1" set="method"><f a=""><t path="haxe.io.BytesData"/></f></getData>
		<new public="1" set="method"><f a="length:b">
	<x path="Int"/>
	<t path="haxe.io.BytesData"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="haxe.io.BytesBuffer" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/io/BytesBuffer.hx" extern="1">
		<length public="1" get="accessor" set="null">
			<x path="Int"/>
			<haxe_doc>The length of the buffer in bytes.</haxe_doc>
		</length>
		<get_length set="method"><f a=""><x path="Int"/></f></get_length>
		<addByte public="1" set="method"><f a="byte">
	<x path="Int"/>
	<x path="Void"/>
</f></addByte>
		<add public="1" set="method"><f a="src">
	<c path="haxe.io.Bytes"/>
	<x path="Void"/>
</f></add>
		<addString public="1" set="method"><f a="v:?encoding">
	<c path="String"/>
	<e path="haxe.io.Encoding"/>
	<x path="Void"/>
</f></addString>
		<addInt32 public="1" set="method"><f a="v">
	<x path="Int"/>
	<x path="Void"/>
</f></addInt32>
		<addInt64 public="1" set="method"><f a="v">
	<x path="haxe.Int64"/>
	<x path="Void"/>
</f></addInt64>
		<addFloat public="1" set="method"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addFloat>
		<addDouble public="1" set="method"><f a="v">
	<x path="Float"/>
	<x path="Void"/>
</f></addDouble>
		<addBytes public="1" set="method"><f a="src:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addBytes>
		<getBytes public="1" set="method">
			<f a=""><c path="haxe.io.Bytes"/></f>
			<haxe_doc>Returns either a copy or a reference of the current bytes.
		Once called, the buffer should no longer be used.</haxe_doc>
		</getBytes>
		<new public="1" set="method"><f a=""><x path="Void"/></f></new>
		<meta><m n=":coreApi"/></meta>
	</class>
	<abstract path="haxe.io._BytesData.NativeBytesDataAbstract" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/io/BytesData.hx" private="1" module="haxe.io.BytesData">
		<from><icast><c path="haxe.io.Bytes"/></icast></from>
		<this><c path="haxe.io.Bytes"/></this>
		<to><icast><c path="haxe.io.Bytes"/></icast></to>
		<meta><m n=":forward"/></meta>
		<impl><class path="haxe.io._BytesData.NativeBytesDataAbstract_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/io/BytesData.hx" private="1" module="haxe.io.BytesData" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.io.BytesData" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/haxe/io/BytesData.hx"><x path="haxe.io._BytesData.NativeBytesDataAbstract"/></typedef>
	<class path="haxe.io.Input" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Input.hx">
		<haxe_doc>An Input is an abstract reader. See other classes in the `haxe.io` package
	for several possible implementations.

	All functions which read data throw `Eof` when the end of the stream
	is reached.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.io.Output" params="" file="C:\HaxeToolkit\haxe\std/haxe/io/Output.hx">
		<haxe_doc>An Output is an abstract write. A specific output implementation will only
	have to override the `writeByte` and maybe the `write`, `flush` and `close`
	methods. See `File.write` and `String.write` for two ways of creating an
	Output.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.iterators.ArrayIterator" params="T" file="C:\HaxeToolkit\haxe\std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<typedef path="haxe.macro.Position" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<min>
				<x path="Int"/>
				<haxe_doc>Position of the first character.</haxe_doc>
			</min>
			<max>
				<x path="Int"/>
				<haxe_doc>Position of the last character.</haxe_doc>
			</max>
			<file>
				<c path="String"/>
				<haxe_doc>Reference to the filename.</haxe_doc>
			</file>
		</a>
		<haxe_doc>Represents a position in a file.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Expr" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.ExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a node in the AST.
	@see https://haxe.org/manual/macro-reification-expression.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ExprOf" params="T" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<t path="haxe.macro.Expr"/>
		<haxe_doc>Represents a AST node identical to `Expr`, but it allows constraining the
	type of accepted expressions.
	@see https://haxe.org/manual/macro-ExprOf.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Case" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<values>
				<c path="Array"><t path="haxe.macro.Expr"/></c>
				<haxe_doc>The value expressions of the case.</haxe_doc>
			</values>
			<guard>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional guard expressions of the case, if available.</haxe_doc>
			</guard>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the case, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a switch case.
	@see https://haxe.org/manual/expression-switch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Var" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the variable, if available.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Metadata associatied with the variable, if available.</haxe_doc>
			</meta>
			<isFinal>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the variable can be assigned to.</haxe_doc>
			</isFinal>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the variable, if available.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a variable in the AST.
	@see https://haxe.org/manual/expression-var.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Catch" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type of the catch.</haxe_doc>
			</type>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the catch variable.</haxe_doc>
			</name>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The expression of the catch.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a catch in the AST.
	@see https://haxe.org/manual/expression-try-catch.html</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ObjectField" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<quotes>
				<x path="Null"><e path="haxe.macro.QuoteStatus"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>How the field name is quoted.</haxe_doc>
			</quotes>
			<field>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</field>
			<expr>
				<t path="haxe.macro.Expr"/>
				<haxe_doc>The field expression.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents the field of an object declaration.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypePath" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<sub>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Sub is set on module sub-type access:
		`pack.Module.Type` has `name = "Module"`, `sub = "Type"`, if available.</haxe_doc>
			</sub>
			<params>
				<x path="Null"><c path="Array"><e path="haxe.macro.TypeParam"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Optional parameters of the type path.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>Represents the package of the type path.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type path.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a type path in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParamDecl" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the type parameter.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the type parameter.</haxe_doc>
			</meta>
			<constraints>
				<x path="Null"><c path="Array"><e path="haxe.macro.ComplexType"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional constraints of the type parameter.</haxe_doc>
			</constraints>
		</a>
		<haxe_doc>Represents a type parameter declaration in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Function" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<ret>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The return type-hint of the function, if available.</haxe_doc>
			</ret>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>An optional list of function parameter type declarations.</haxe_doc>
			</params>
			<expr>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The expression of the function body, if available.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><t path="haxe.macro.FunctionArg"/></c>
				<haxe_doc>A list of function arguments.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.FunctionArg" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<value>
				<x path="Null"><t path="haxe.macro.Expr"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional value of the function argument, if available.</haxe_doc>
			</value>
			<type>
				<x path="Null"><e path="haxe.macro.ComplexType"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The type-hint of the function argument, if available.</haxe_doc>
			</type>
			<opt>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the function argument is optional.</haxe_doc>
			</opt>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the function argument.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The metadata of the function argument.</haxe_doc>
			</meta>
		</a>
		<haxe_doc>Represents a function argument in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetadataEntry" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the metadata entry.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.Expr"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional parameters of the metadata entry.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the metadata entry.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents a metadata entry in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Metadata" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
		<haxe_doc>Represents metadata in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Field" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the field.</haxe_doc>
			</pos>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the field.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldType"/>
				<haxe_doc>The kind of the field.</haxe_doc>
			</kind>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the field, if available. If the field has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
			<access>
				<x path="Null"><c path="Array"><e path="haxe.macro.Access"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The access modifiers of the field. By default fields have private access.
		@see https://haxe.org/manual/class-field-access-modifier.html</haxe_doc>
			</access>
		</a>
		<haxe_doc>Represents a field in the AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeDefinition" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position to the type definition.</haxe_doc>
			</pos>
			<params>
				<x path="Null"><c path="Array"><t path="haxe.macro.TypeParamDecl"/></c></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The parameter type declarations of the type definition.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type definition.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type definition.</haxe_doc>
			</name>
			<meta>
				<x path="Null"><t path="haxe.macro.Metadata"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The optional metadata of the type definition.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.TypeDefKind"/>
				<haxe_doc>The kind of the type definition.</haxe_doc>
			</kind>
			<isExtern>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<fields>
				<c path="Array"><t path="haxe.macro.Field"/></c>
				<haxe_doc>The fields of the type definition.</haxe_doc>
			</fields>
			<doc>
				<x path="Null"><c path="String"/></x>
				<meta><m n=":optional"/></meta>
				<haxe_doc>The documentation of the type, if available. If the type has no
		documentation, the value is `null`.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a type definition.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ImportExpr" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Expr.hx" module="haxe.macro.Expr">
		<a>
			<path>
				<c path="Array"><a>
	<pos><t path="haxe.macro.Position"/></pos>
	<name><c path="String"/></name>
</a></c>
				<haxe_doc>The path to the import expression.</haxe_doc>
			</path>
			<mode>
				<e path="haxe.macro.ImportMode"/>
				<haxe_doc>The mode of the import expression.</haxe_doc>
			</mode>
		</a>
		<haxe_doc>Represents the import expression.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.Ref" params="T" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<toString set="method"><f a=""><c path="String"/></f></toString>
			<get set="method"><f a=""><c path="haxe.macro.Ref.T"/></f></get>
		</a>
		<haxe_doc>Represents a reference to internal compiler structure. It exists to avoid
	expensive encoding if it is not required and to ensure that physical
	equality remains intact.

	A structure is only encoded when user requests it through `ref.get()`.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AnonType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<status>
				<e path="haxe.macro.AnonStatus"/>
				<haxe_doc>The status/kind of the structure.</haxe_doc>
			</status>
			<fields>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The class fields of the structure.</haxe_doc>
			</fields>
		</a>
		<haxe_doc>Represents information for anonymous structure types.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypeParameter" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the type parameter. It is guaranteed to be a `TInst` with a
		`KTypeParameter` kind.</haxe_doc>
			</t>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type parameter.</haxe_doc>
			</name>
		</a>
		<haxe_doc>Represents the declaration of type parameters.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassField" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the class field.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the class field.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the class field.</haxe_doc>
			</params>
			<overloads>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The overload fields of the class field.</haxe_doc>
			</overloads>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the class field.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the class field.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.FieldKind"/>
				<haxe_doc>The class field kind.</haxe_doc>
			</kind>
			<isPublic>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is public.</haxe_doc>
			</isPublic>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is final.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>Whether or not the class field is abstract.</haxe_doc>
			</isAbstract>
			<expr set="method">
				<f a=""><x path="Null"><t path="haxe.macro.TypedExpr"/></x></f>
				<haxe_doc>Returns the typed expression of the class field.</haxe_doc>
			</expr>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a class field.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumField" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the enum constructor.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the enum constructor.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the enum constructor.</haxe_doc>
			</params>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the enum constructor.</haxe_doc>
			</name>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the enum constructor.</haxe_doc>
			</meta>
			<index>
				<x path="Int"/>
				<haxe_doc>The index of the enum constructor, i.e. in which position it appears
		in the syntax.</haxe_doc>
			</index>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the enum constructor.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents an enum constructor.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.BaseType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>The information that all types (`ClassType`, `EnumType`, `DefType`,
	`AbstractType`) have in common.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.ClassType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<superClass>
				<x path="Null"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></x>
				<haxe_doc>The parent class and its type parameters, if available.</haxe_doc>
			</superClass>
			<statics>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The static fields of the class.</haxe_doc>
			</statics>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<overrides>
				<c path="Array"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></c>
				<haxe_doc>The list of fields that have override status.</haxe_doc>
			</overrides>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<kind>
				<e path="haxe.macro.ClassKind"/>
				<haxe_doc>The kind of the class.</haxe_doc>
			</kind>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isInterface>
				<x path="Bool"/>
				<haxe_doc>If true the type is an interface, otherwise it is a class.</haxe_doc>
			</isInterface>
			<isFinal>
				<x path="Bool"/>
				<haxe_doc>If true the class is final and cannot be extended.</haxe_doc>
			</isFinal>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<isAbstract>
				<x path="Bool"/>
				<haxe_doc>If true the class is abstract and cannot be instantiated directly.</haxe_doc>
			</isAbstract>
			<interfaces>
				<c path="Array"><a>
	<t><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></t>
	<params><c path="Array"><e path="haxe.macro.Type"/></c></params>
</a></c>
				<haxe_doc>The implemented interfaces and their type parameters.</haxe_doc>
			</interfaces>
			<init>
				<x path="Null"><t path="haxe.macro.TypedExpr"/></x>
				<haxe_doc>The `__init__` expression of the class, if available.</haxe_doc>
			</init>
			<fields>
				<t path="haxe.macro.Ref"><c path="Array"><t path="haxe.macro.ClassField"/></c></t>
				<haxe_doc>The member fields of the class.</haxe_doc>
			</fields>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructor>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassField"/></t></x>
				<haxe_doc>The constructor of the class, if available.</haxe_doc>
			</constructor>
		</a>
		<haxe_doc>Represents a class type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.EnumType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<names>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>An ordered list of enum constructor names.</haxe_doc>
			</names>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<constructs>
				<t path="Map">
					<c path="String"/>
					<t path="haxe.macro.EnumField"/>
				</t>
				<haxe_doc>The available enum constructors.</haxe_doc>
			</constructs>
		</a>
		<haxe_doc>Represents an enum type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.DefType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The target type of the typedef.</haxe_doc>
			</type>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
		</a>
		<haxe_doc>Represents a typedef.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.AbstractType" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<unops>
				<c path="Array"><a>
	<postFix><x path="Bool"/></postFix>
	<op><e path="haxe.macro.Unop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined unary operators of the abstract.</haxe_doc>
			</unops>
			<type>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The underlying type of the abstract.</haxe_doc>
			</type>
			<to>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit to-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</to>
			<resolveWrite>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolveWrite>
			<resolve>
				<x path="Null"><t path="haxe.macro.ClassField"/></x>
				<haxe_doc>The method used for resolving unknown field access, if available.</haxe_doc>
			</resolve>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the type.</haxe_doc>
			</pos>
			<params>
				<c path="Array"><t path="haxe.macro.TypeParameter"/></c>
				<haxe_doc>The type parameters of the type.</haxe_doc>
			</params>
			<pack>
				<c path="Array"><c path="String"/></c>
				<haxe_doc>The package of the type.</haxe_doc>
			</pack>
			<name>
				<c path="String"/>
				<haxe_doc>The name of the type.</haxe_doc>
			</name>
			<module>
				<c path="String"/>
				<haxe_doc>The module name of the type, which might be different.</haxe_doc>
			</module>
			<meta>
				<t path="haxe.macro.MetaAccess"/>
				<haxe_doc>The metadata of the type.</haxe_doc>
			</meta>
			<isPrivate>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is private.</haxe_doc>
			</isPrivate>
			<isExtern>
				<x path="Bool"/>
				<haxe_doc>Whether or not the type is extern.</haxe_doc>
			</isExtern>
			<impl>
				<x path="Null"><t path="haxe.macro.Ref"><t path="haxe.macro.ClassType"/></t></x>
				<haxe_doc>The implementation class of the abstract, if available.</haxe_doc>
			</impl>
			<from>
				<c path="Array"><a>
	<t><e path="haxe.macro.Type"/></t>
	<field><x path="Null"><t path="haxe.macro.ClassField"/></x></field>
</a></c>
				<haxe_doc>The available implicit from-casts of the abstract.

		@see https://haxe.org/manual/types-abstract-implicit-casts.html</haxe_doc>
			</from>
			<exclude set="method">
				<f a=""><x path="Void"/></f>
				<haxe_doc>Allows excluding the type from compilation.</haxe_doc>
			</exclude>
			<doc>
				<x path="Null"><c path="String"/></x>
				<haxe_doc>The associated documentation of the class field.</haxe_doc>
			</doc>
			<binops>
				<c path="Array"><a>
	<op><e path="haxe.macro.Binop"/></op>
	<field><t path="haxe.macro.ClassField"/></field>
</a></c>
				<haxe_doc>The defined binary operators of the abstract.</haxe_doc>
			</binops>
			<array>
				<c path="Array"><t path="haxe.macro.ClassField"/></c>
				<haxe_doc>The defined array-access fields of the abstract.</haxe_doc>
			</array>
		</a>
		<haxe_doc>Represents an abstract type.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.MetaAccess" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<remove set="method">
				<f a="name">
					<c path="String"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Removes all `name` metadata entries from the origin of `this`
		MetaAccess.

		This method might clear several metadata entries of the same name.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `remove` has no effect on that array.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</remove>
			<has set="method">
				<f a="name">
					<c path="String"/>
					<x path="Bool"/>
				</f>
				<haxe_doc>Tells if the origin of `this` MetaAccess has a `name` metadata entry.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</has>
			<get set="method">
				<f a=""><t path="haxe.macro.Metadata"/></f>
				<haxe_doc>Return the wrapped `Metadata` array.

		Modifying this array has no effect on the origin of `this` MetaAccess.
		The `add` and `remove` methods can be used for that.</haxe_doc>
			</get>
			<extract set="method">
				<f a="name">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.MetadataEntry"/></c>
				</f>
				<haxe_doc>Extract metadata entries by given `name`.

		If there's no metadata with such name, empty array `[]` is returned.

		If `name` is null, compilation fails with an error.</haxe_doc>
			</extract>
			<add set="method">
				<f a="name:params:pos">
					<c path="String"/>
					<c path="Array"><t path="haxe.macro.Expr"/></c>
					<t path="haxe.macro.Position"/>
					<x path="Void"/>
				</f>
				<haxe_doc>Adds the metadata specified by `name`, `params` and `pos` to the origin
		of `this` MetaAccess.

		Metadata names are not unique during compilation, so this method never
		overwrites a previous metadata.

		If a `Metadata` array is obtained through a call to `get`, a subsequent
		call to `add` has no effect on that array.

		If any argument is null, compilation fails with an error.</haxe_doc>
			</add>
		</a>
		<haxe_doc>MetaAccess is a wrapper for the `Metadata` array. It can be used to add
	metadata to and remove metadata from its origin.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TVar" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t set="null">
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the variable.</haxe_doc>
			</t>
			<name set="null">
				<c path="String"/>
				<haxe_doc>The name of the variable.</haxe_doc>
			</name>
			<meta set="null">
				<x path="Null"><t path="haxe.macro.MetaAccess"/></x>
				<haxe_doc>The metadata of the variable.</haxe_doc>
			</meta>
			<id set="null">
				<x path="Int"/>
				<haxe_doc>The unique ID of the variable.</haxe_doc>
			</id>
			<extra set="null">
				<x path="Null"><a>
	<params><c path="Array"><t path="haxe.macro.TypeParameter"/></c></params>
	<expr><x path="Null"><t path="haxe.macro.TypedExpr"/></x></expr>
</a></x>
				<haxe_doc>Special information which is internally used to keep track of closure.
		information</haxe_doc>
			</extra>
			<capture set="null">
				<x path="Bool"/>
				<haxe_doc>Whether or not the variable has been captured by a closure.</haxe_doc>
			</capture>
		</a>
		<haxe_doc>Represents a variable in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TFunc" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The return type of the function.</haxe_doc>
			</t>
			<expr>
				<t path="haxe.macro.TypedExpr"/>
				<haxe_doc>The expression of the function body.</haxe_doc>
			</expr>
			<args>
				<c path="Array"><a>
	<value><x path="Null"><t path="haxe.macro.TypedExpr"/></x></value>
	<v><t path="haxe.macro.TVar"/></v>
</a></c>
				<haxe_doc>A list of function arguments identified by an argument variable `v` and
		an optional initialization `value`.</haxe_doc>
			</args>
		</a>
		<haxe_doc>Represents a function in the typed AST.</haxe_doc>
	</typedef>
	<typedef path="haxe.macro.TypedExpr" params="" file="C:\HaxeToolkit\haxe\std/haxe/macro/Type.hx" module="haxe.macro.Type">
		<a>
			<t>
				<e path="haxe.macro.Type"/>
				<haxe_doc>The type of the expression.</haxe_doc>
			</t>
			<pos>
				<t path="haxe.macro.Position"/>
				<haxe_doc>The position of the expression.</haxe_doc>
			</pos>
			<expr>
				<e path="haxe.macro.TypedExprDef"/>
				<haxe_doc>The expression kind.</haxe_doc>
			</expr>
		</a>
		<haxe_doc>Represents a typed AST node.</haxe_doc>
	</typedef>
	<class path="oimo.collision.broadphase.BroadPhase" params="" file="src/oimo/collision/broadphase/BroadPhase.hx">
		<_type public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_type>
		<_numProxies public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numProxies>
		<_proxyList public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxyList>
		<_proxyListLast public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxyListLast>
		<_proxyPairList public="1">
			<c path="oimo.collision.broadphase.ProxyPair"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxyPairList>
		<_incremental public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_incremental>
		<_testCount public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_testCount>
		<_proxyPairPool>
			<c path="oimo.collision.broadphase.ProxyPair"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxyPairPool>
		<_idCount>
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_idCount>
		<_convexSweep>
			<c path="oimo.collision.broadphase._BroadPhase.ConvexSweepGeometry"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_convexSweep>
		<_aabb>
			<c path="oimo.collision.broadphase._BroadPhase.AabbGeometry"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabb>
		<identity><c path="oimo.common.Transform"/></identity>
		<zero><c path="oimo.common.Vec3"/></zero>
		<rayCastHit><c path="oimo.collision.geometry.RayCastHit"/></rayCastHit>
		<createProxy public="1" set="method" line="182">
			<f a="userData:aabb">
				<x path="Any"/>
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.broadphase.Proxy"/>
			</f>
			<haxe_doc>* Returns a new proxy connected with the user data `userData` containing the axis-aligned
	 * bounding box `aabb`, and adds the proxy into the collision space.</haxe_doc>
		</createProxy>
		<destroyProxy public="1" set="method" line="189">
			<f a="proxy">
				<c path="oimo.collision.broadphase.Proxy"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the proxy `proxy` from the collision space.</haxe_doc>
		</destroyProxy>
		<moveProxy public="1" set="method" line="197">
			<f a="proxy:aabb:displacement">
				<c path="oimo.collision.broadphase.Proxy"/>
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Moves the proxy `proxy` to the axis-aligned bounding box `aabb`. `displacement` is the
	 * difference between current and previous center of the AABB. This is used for predicting
	 * movement of the proxy.</haxe_doc>
		</moveProxy>
		<isOverlapping public="1" get="inline" set="null" line="204">
			<f a="proxy1:proxy2">
				<c path="oimo.collision.broadphase.Proxy"/>
				<c path="oimo.collision.broadphase.Proxy"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether the pair of `proxy1` and `proxy2` is overlapping. As proxies can be larger
	 * than the containing AABBs, two proxies may overlap even though their inner AABBs are separate.</haxe_doc>
		</isOverlapping>
		<collectPairs public="1" set="method" line="215">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Collects overlapping pairs of the proxies and put them into a linked list. The linked list
	 * can be get through `BroadPhase.getProxyPairList` method.
	 *
	 * Note that in order to collect pairs, the broad-phase algorithm requires to be informed of
	 * movements of proxies through `BroadPhase.moveProxy` method.</haxe_doc>
		</collectPairs>
		<getProxyPairList public="1" get="inline" set="null" line="221">
			<f a=""><c path="oimo.collision.broadphase.ProxyPair"/></f>
			<haxe_doc>* Returns the linked list of collected pairs of proxies.</haxe_doc>
		</getProxyPairList>
		<isIncremental public="1" get="inline" set="null" line="230">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether to collect only pairs created in the last step. If this returns
	 * true, the pairs that are not collected might still be overlapping. Otherwise, such
	 * pairs are guaranteed to be separated.</haxe_doc>
		</isIncremental>
		<getTestCount public="1" get="inline" set="null" line="237">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of broad-phase AABB tests.</haxe_doc>
		</getTestCount>
		<rayCast public="1" set="method" line="245">
			<f a="begin:end:callback">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs a ray casting. `callback.process` is called for all proxies the line segment
	 * from `begin` to `end` intersects.</haxe_doc>
		</rayCast>
		<convexCast public="1" set="method" line="253">
			<f a="convex:begin:translation:callback">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs a convex casting. `callback.process` is called for all shapes the convex geometry
	 * `convex` hits. The convex geometry translates by `translation` starting from the beginning
	 * transform `begin`.</haxe_doc>
		</convexCast>
		<aabbTest public="1" set="method" line="260">
			<f a="aabb:callback">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs an AABB query. `callback.process` is called for all proxies that their AABB
	 * and `aabb` intersect.</haxe_doc>
		</aabbTest>
		<new public="1" set="method" line="38">
			<f a="type">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The abstract class of a broad-phase collision detection algorithm.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.Geometry" params="" file="src/oimo/collision/geometry/Geometry.hx">
		<_type public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_type>
		<_volume public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_volume>
		<_inertiaCoeff00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff00>
		<_inertiaCoeff01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff01>
		<_inertiaCoeff02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff02>
		<_inertiaCoeff10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff10>
		<_inertiaCoeff11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff11>
		<_inertiaCoeff12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff12>
		<_inertiaCoeff20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff20>
		<_inertiaCoeff21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff21>
		<_inertiaCoeff22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_inertiaCoeff22>
		<_updateMass public="1" set="method" line="26">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="29">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<_rayCastLocal public="1" set="method" line="32">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<getType public="1" get="inline" set="null" line="43">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the type of the collision geometry.
	 *
	 * See `GeometryType` for details.</haxe_doc>
		</getType>
		<getVolume public="1" get="inline" set="null" line="50">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the volume of the collision geometry.</haxe_doc>
		</getVolume>
		<rayCast public="1" set="method" line="59">
			<f a="begin:end:transform:hit">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Performs ray casting. Returns `true` and sets the result information to `hit` if
	 * the line segment from `begin` to `end` and the geometry transformed by `transform`
	 * intersect. Returns `false` if the line segment and the geometry do not intersect.</haxe_doc>
		</rayCast>
		<new set="method" line="19">
			<f a="type">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* Abstract collision geometry.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.ConvexGeometry" params="" file="src/oimo/collision/geometry/ConvexGeometry.hx">
		<extends path="oimo.collision.geometry.Geometry"/>
		<_gjkMargin public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_gjkMargin>
		<_useGjkRayCast public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_useGjkRayCast>
		<getGjkMergin public="1" get="inline" set="null" line="29">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the GJK mergin around the "core" of the convex geometry.</haxe_doc>
		</getGjkMergin>
		<setGjkMergin public="1" get="inline" set="null" line="36">
			<f a="gjkMergin">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the GJK mergin around the "core" to `gjkMergin`.</haxe_doc>
		</setGjkMergin>
		<computeLocalSupportingVertex public="1" set="method" line="46">
			<f a="dir:out">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Computes supporting vertex of the "core" of the geometry in local coordinates.
	 * Note that the direction vector `dir` might not be normalized. `out` is set to
	 * the computed supporting vertex.</haxe_doc>
		</computeLocalSupportingVertex>
		<rayCast public="1" set="method" line="49" override="1"><f a="begin:end:transform:hit">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.geometry.RayCastHit"/>
	<x path="Bool"/>
</f></rayCast>
		<new public="1" set="method" line="20">
			<f a="type">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* Abstract class of the convex collision geometries supported by GJK/EPA collision detection.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.broadphase._BroadPhase.ConvexSweepGeometry" params="" file="src/oimo/collision/broadphase/BroadPhase.hx" private="1" module="oimo.collision.broadphase.BroadPhase">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<c><c path="oimo.collision.geometry.ConvexGeometry"/></c>
		<localTranslation><c path="oimo.common.Vec3"/></localTranslation>
		<init public="1" set="method" line="273"><f a="c:transform:translation">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></init>
		<computeLocalSupportingVertex public="1" set="method" line="288" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<new public="1" set="method" line="269"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase._BroadPhase.AabbGeometry" params="" file="src/oimo/collision/broadphase/BroadPhase.hx" private="1" module="oimo.collision.broadphase.BroadPhase">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<min public="1"><c path="oimo.common.Vec3"/></min>
		<max public="1"><c path="oimo.common.Vec3"/></max>
		<computeLocalSupportingVertex public="1" set="method" line="306" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<new public="1" set="method" line="300"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.broadphase.BroadPhaseProxyCallback" params="" file="src/oimo/collision/broadphase/BroadPhaseProxyCallback.hx">
		<process public="1" set="method" line="16">
			<f a="proxy">
				<c path="oimo.collision.broadphase.Proxy"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called every time a broad phase algorithm reports a proxy `proxy`.</haxe_doc>
		</process>
		<new public="1" set="method" line="10">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A callback class for queries in a broad phase.</haxe_doc>
	</class>
	<class path="oimo.collision.broadphase.BroadPhaseType" params="" file="src/oimo/collision/broadphase/BroadPhaseType.hx">
		<_BRUTE_FORCE public="1" get="inline" set="null" expr="1" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_BRUTE_FORCE>
		<_BVH public="1" get="inline" set="null" expr="2" line="9" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_BVH>
		<BRUTE_FORCE public="1" set="null" expr="_BRUTE_FORCE" line="15" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_BRUTE_FORCE</e></m></meta>
			<haxe_doc>* The brute force algorithm searches all the possible pairs of the proxies every time.
	 * This is **very slow** and so users should not choose this algorithm without exceptional reasons.</haxe_doc>
		</BRUTE_FORCE>
		<BVH public="1" set="null" expr="_BVH" line="20" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_BVH</e></m></meta>
			<haxe_doc>* The BVH algorithm uses bounding volume hierarchy for detecting overlapping pairs of proxies efficiently.</haxe_doc>
		</BVH>
		<haxe_doc>* Types of broad-phase algorithms.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.broadphase.Proxy" params="" file="src/oimo/collision/broadphase/Proxy.hx">
		<_prev public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_next public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_aabbMinX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinX>
		<_aabbMinY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinY>
		<_aabbMinZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinZ>
		<_aabbMaxX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxX>
		<_aabbMaxY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxY>
		<_aabbMaxZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxZ>
		<_id public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_id>
		<userData public="1">
			<x path="Any"/>
			<haxe_doc>* Extra field that users can use for their own purposes. **Do not modify this property if
	 * you use the physics part of the library**, as the physics part of the library uses this property
	 * for connecting proxies and shapes of rigid bodies.</haxe_doc>
		</userData>
		<getId public="1" set="method" line="51">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the unique id of the proxy.</haxe_doc>
		</getId>
		<getFatAabb public="1" set="method" line="58">
			<f a=""><c path="oimo.collision.geometry.Aabb"/></f>
			<haxe_doc>* Returns the fat AABB of the proxy.</haxe_doc>
		</getFatAabb>
		<getFatAabbTo public="1" set="method" line="70">
			<f a="aabb">
				<c path="oimo.collision.geometry.Aabb"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `aabb` to the fat AABB of the proxy.
	 *
	 * This does not create a new instance of `Aabb`.</haxe_doc>
		</getFatAabbTo>
		<new public="1" set="method" line="30">
			<f a="userData:id">
				<x path="Any"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A proxy is an object that can be added to a broad-phase collision detection algorithm.
 * Users of the collision part of the library can move an axis-aligned bounding box of
 * a proxy through `BroadPhase` class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.ProxyPair" params="" file="src/oimo/collision/broadphase/ProxyPair.hx">
		<_next public="1">
			<c path="oimo.collision.broadphase.ProxyPair"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_p1 public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_p1>
		<_p2 public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_p2>
		<getProxy1 public="1" set="method" line="25">
			<f a=""><c path="oimo.collision.broadphase.Proxy"/></f>
			<haxe_doc>* Returns the first proxy of the pair.</haxe_doc>
		</getProxy1>
		<getProxy2 public="1" set="method" line="32">
			<f a=""><c path="oimo.collision.broadphase.Proxy"/></f>
			<haxe_doc>* Returns the second proxy of the pair.</haxe_doc>
		</getProxy2>
		<getNext public="1" set="method" line="39">
			<f a=""><c path="oimo.collision.broadphase.ProxyPair"/></f>
			<haxe_doc>* Returns the next pair.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="15">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A pair between two proxies. Broad-phase collision algorithms collect pairs of proxies
 * as linked list of ProxyPair.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bruteforce.BruteForceBroadPhase" params="" file="src/oimo/collision/broadphase/bruteforce/BruteForceBroadPhase.hx">
		<extends path="oimo.collision.broadphase.BroadPhase"/>
		<createProxy public="1" set="method" line="32" override="1"><f a="userData:aabb">
	<d/>
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.collision.broadphase.Proxy"/>
</f></createProxy>
		<destroyProxy public="1" set="method" line="40" override="1"><f a="proxy">
	<c path="oimo.collision.broadphase.Proxy"/>
	<x path="Void"/>
</f></destroyProxy>
		<moveProxy public="1" set="method" line="46" override="1"><f a="proxy:aabb:dislacement">
	<c path="oimo.collision.broadphase.Proxy"/>
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></moveProxy>
		<collectPairs public="1" set="method" line="50" override="1"><f a=""><x path="Void"/></f></collectPairs>
		<rayCast public="1" set="method" line="65" override="1"><f a="begin:end:callback">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></rayCast>
		<convexCast public="1" set="method" line="86" override="1"><f a="convex:begin:translation:callback">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></convexCast>
		<aabbTest public="1" set="method" line="95" override="1"><f a="aabb:callback">
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></aabbTest>
		<new public="1" set="method" line="19">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* Brute force implementation of broad-phase collision detection. Time complexity is O(n^2).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhBroadPhase" params="" file="src/oimo/collision/broadphase/bvh/BvhBroadPhase.hx">
		<extends path="oimo.collision.broadphase.BroadPhase"/>
		<_tree public="1">
			<c path="oimo.collision.broadphase.bvh.BvhTree"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tree>
		<movedProxies><x path="haxe.ds.Vector"><c path="oimo.collision.broadphase.bvh.BvhProxy"/></x></movedProxies>
		<numMovedProxies><x path="Int"/></numMovedProxies>
		<collide set="method" line="73"><f a="n1:n2">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<x path="Void"/>
</f></collide>
		<rayCastRecursive set="method" line="101"><f a="node:_p1X:_p1Y:_p1Z:_p2X:_p2Y:_p2Z:callback">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></rayCastRecursive>
		<convexCastRecursive set="method" line="121"><f a="node:convex:begin:translation:callback">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></convexCastRecursive>
		<aabbTestRecursive set="method" line="136"><f a="node:aabb:callback">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></aabbTestRecursive>
		<createProxy public="1" set="method" line="152" override="1"><f a="userData:aabb">
	<d/>
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.collision.broadphase.Proxy"/>
</f></createProxy>
		<destroyProxy public="1" set="method" line="163" override="1"><f a="proxy">
	<c path="oimo.collision.broadphase.Proxy"/>
	<x path="Void"/>
</f></destroyProxy>
		<moveProxy public="1" set="method" line="177" override="1"><f a="proxy:aabb:displacement">
	<c path="oimo.collision.broadphase.Proxy"/>
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></moveProxy>
		<collectPairs public="1" set="method" line="188" override="1"><f a=""><x path="Void"/></f></collectPairs>
		<rayCast public="1" set="method" line="226" override="1"><f a="begin:end:callback">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></rayCast>
		<convexCast public="1" set="method" line="237" override="1"><f a="convex:begin:translation:callback">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></convexCast>
		<aabbTest public="1" set="method" line="243" override="1"><f a="aabb:callback">
	<c path="oimo.collision.geometry.Aabb"/>
	<c path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
	<x path="Void"/>
</f></aabbTest>
		<getTreeBalance public="1" get="inline" set="null" line="252">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the balance of the bounding volume tree.</haxe_doc>
		</getTreeBalance>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The broad-phase collision detection algorithm based on bounding volume hierarchy (BVH).
 * Average time complexity is O(NlogN) or lower.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhInsertionStrategy" params="" file="src/oimo/collision/broadphase/bvh/BvhInsertionStrategy.hx">
		<SIMPLE public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</SIMPLE>
		<MINIMIZE_SURFACE_AREA public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</MINIMIZE_SURFACE_AREA>
		<haxe_doc>* Internal class.
 *
 * Strategies of leaf insertion.</haxe_doc>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhNode" params="" file="src/oimo/collision/broadphase/bvh/BvhNode.hx">
		<_next public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_prevLeaf public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prevLeaf>
		<_nextLeaf public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_nextLeaf>
		<_children public="1">
			<x path="haxe.ds.Vector"><c path="oimo.collision.broadphase.bvh.BvhNode"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_children>
		<_childIndex public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_childIndex>
		<_parent public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_parent>
		<_height public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_height>
		<_proxy public="1">
			<c path="oimo.collision.broadphase.bvh.BvhProxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxy>
		<_aabbMinX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinX>
		<_aabbMinY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinY>
		<_aabbMinZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMinZ>
		<_aabbMaxX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxX>
		<_aabbMaxY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxY>
		<_aabbMaxZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbMaxZ>
		<_tmpX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpX>
		<_tmpY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpY>
		<_tmpZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpZ>
		<new public="1" set="method" line="34"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.
 *
 * BVH Node</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhProxy" params="" file="src/oimo/collision/broadphase/bvh/BvhProxy.hx">
		<extends path="oimo.collision.broadphase.Proxy"/>
		<_leaf public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_leaf>
		<_moved public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_moved>
		<new public="1" set="method" line="15"><f a="userData:id">
	<d/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class.
 *
 * BVH Proxy</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhStrategy" params="" file="src/oimo/collision/broadphase/bvh/BvhStrategy.hx">
		<_insertionStrategy public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_insertionStrategy>
		<_balancingEnabled public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_balancingEnabled>
		<_decideInsertion public="1" set="method" line="30">
			<f a="currentNode:leaf">
				<c path="oimo.collision.broadphase.bvh.BvhNode"/>
				<c path="oimo.collision.broadphase.bvh.BvhNode"/>
				<x path="Int"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Returns the next step of leaf insertion.
	 * `0` or `1` to descend to corresponding child of current node.
	 * `-1` to stop descending and make common parent with current node.</haxe_doc>
		</_decideInsertion>
		<_splitLeaves public="1" set="method" line="46">
			<f a="leaves:from:until">
				<x path="haxe.ds.Vector"><c path="oimo.collision.broadphase.bvh.BvhNode"/></x>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
			<haxe_doc>* Sorts `leaves` and returns the split index `k` of the half-open interval [`from`, `until`).
	 * Leaves are separated into [`from`, `k`) and [`k`, `until`).</haxe_doc>
		</_splitLeaves>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.
 *
 * BVH strategy for BVH tree</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.broadphase.bvh.BvhTree" params="" file="src/oimo/collision/broadphase/bvh/BvhTree.hx">
		<_root public="1">
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_root>
		<_numLeaves public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numLeaves>
		<_strategy public="1">
			<c path="oimo.collision.broadphase.bvh.BvhStrategy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_strategy>
		<_nodePool>
			<c path="oimo.collision.broadphase.bvh.BvhNode"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_nodePool>
		<leafList><c path="oimo.collision.broadphase.bvh.BvhNode"/></leafList>
		<leafListLast><c path="oimo.collision.broadphase.bvh.BvhNode"/></leafListLast>
		<tmp><x path="haxe.ds.Vector"><c path="oimo.collision.broadphase.bvh.BvhNode"/></x></tmp>
		<_print public="1" set="method" line="36">
			<f a="root:?indent" v=":&quot;&quot;">
				<c path="oimo.collision.broadphase.bvh.BvhNode"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta>
				<m n=":value"><e>{ indent : "" }</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_print>
		<_getBalance public="1" set="method" line="126">
			<f a=""><x path="Int"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getBalance>
		<deleteRecursive set="method" line="142"><f a="root">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<x path="Void"/>
</f></deleteRecursive>
		<decomposeRecursive set="method" line="154"><f a="root">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<x path="Void"/>
</f></decomposeRecursive>
		<buildTopDownRecursive set="method" line="165"><f a="leaves:from:until">
	<x path="haxe.ds.Vector"><c path="oimo.collision.broadphase.bvh.BvhNode"/></x>
	<x path="Int"/>
	<x path="Int"/>
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
</f></buildTopDownRecursive>
		<getBalanceRecursive set="method" line="187"><f a="root">
	<c path="oimo.collision.broadphase.bvh.BvhNode"/>
	<x path="Int"/>
</f></getBalanceRecursive>
		<new public="1" set="method" line="24"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.
 *
 * BVH Tree</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.geometry.Aabb" params="" file="src/oimo/collision/geometry/Aabb.hx">
		<_minX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_minX>
		<_minY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_minY>
		<_minZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_minZ>
		<_maxX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxX>
		<_maxY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxY>
		<_maxZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxZ>
		<init public="1" get="inline" set="null" line="28">
			<f a="min:max">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Sets the minimum and maximum point and returns `this`.
	 *
	 * Equivallent to `setMin(min).setMax(max)`.</haxe_doc>
		</init>
		<getMin public="1" get="inline" set="null" line="37">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the minimum point of the axis-aligned bounding box.</haxe_doc>
		</getMin>
		<getMinTo public="1" get="inline" set="null" line="48">
			<f a="min">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the minimum point of the axis-aligned bounding box to `min`.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getMinTo>
		<setMin public="1" get="inline" set="null" line="55">
			<f a="min">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Sets the minimum point of the axis-aligned bounding box to `min` and returns `this`.</haxe_doc>
		</setMin>
		<getMax public="1" get="inline" set="null" line="63">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the maximum point of the axis-aligned bounding box.</haxe_doc>
		</getMax>
		<getMaxTo public="1" get="inline" set="null" line="74">
			<f a="max">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the maximum point of the axis-aligned bounding box to `max`.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getMaxTo>
		<setMax public="1" get="inline" set="null" line="81">
			<f a="max">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Sets the maximum point of the axis-aligned bounding box to `max` and returns `this`.</haxe_doc>
		</setMax>
		<getCenter public="1" get="inline" set="null" line="89">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the center of the AABB.</haxe_doc>
		</getCenter>
		<getCenterTo public="1" get="inline" set="null" line="103">
			<f a="center">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `center` to the center of the AABB.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getCenterTo>
		<getExtents public="1" get="inline" set="null" line="113">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the half extents of the AABB.</haxe_doc>
		</getExtents>
		<getExtentsTo public="1" get="inline" set="null" line="127">
			<f a="halfExtents">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `halfExtents` to the half extents of the AABB.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getExtentsTo>
		<combine public="1" get="inline" set="null" line="137">
			<f a="other">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Combines `other` into this AABB and returns `this`.</haxe_doc>
		</combine>
		<combined public="1" get="inline" set="null" line="145">
			<f a="other">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Returns the combined aabb of `this` and `other`.</haxe_doc>
		</combined>
		<overlap public="1" get="inline" set="null" line="154">
			<f a="other">
				<c path="oimo.collision.geometry.Aabb"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Returns whether `this` and `other` intersect.</haxe_doc>
		</overlap>
		<getIntersection public="1" get="inline" set="null" line="161">
			<f a="other">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Returns the intersection of `this` and `other`.</haxe_doc>
		</getIntersection>
		<getIntersectionTo public="1" get="inline" set="null" line="173">
			<f a="other:intersection">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.geometry.Aabb"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `intersection` to the intersection of `this` and `other`.
	 *
	 * This does not create a new instance of `Aabb`.</haxe_doc>
		</getIntersectionTo>
		<copyFrom public="1" set="method" line="181">
			<f a="aabb">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.collision.geometry.Aabb"/>
			</f>
			<haxe_doc>* Copies AABB from `aabb` to and returns `this`.</haxe_doc>
		</copyFrom>
		<clone public="1" set="method" line="190">
			<f a=""><c path="oimo.collision.geometry.Aabb"/></f>
			<haxe_doc>* Returns a clone of the AABB.</haxe_doc>
		</clone>
		<new public="1" set="method" line="18">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates an empty AABB. Minimum and maximum points are set to zero.</haxe_doc>
		</new>
		<haxe_doc>* The axis-aligned bounding box.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.geometry.BoxGeometry" params="" file="src/oimo/collision/geometry/BoxGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_halfExtentsX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfExtentsX>
		<_halfExtentsY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfExtentsY>
		<_halfExtentsZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfExtentsZ>
		<_halfAxisXX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisXX>
		<_halfAxisXY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisXY>
		<_halfAxisXZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisXZ>
		<_halfAxisYX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisYX>
		<_halfAxisYY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisYY>
		<_halfAxisYZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisYZ>
		<_halfAxisZX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisZX>
		<_halfAxisZY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisZY>
		<_halfAxisZZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfAxisZZ>
		<getHalfExtents public="1" get="inline" set="null" line="52">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the half-extents of the box.</haxe_doc>
		</getHalfExtents>
		<getHalfExtentsTo public="1" get="inline" set="null" line="61">
			<f a="halfExtents">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `halfExtents` to the half-extents of the box.</haxe_doc>
		</getHalfExtentsTo>
		<_updateMass public="1" set="method" line="65" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="76" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="94" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<_rayCastLocal public="1" set="method" line="105" override="1">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<new public="1" set="method" line="22">
			<f a="halfExtents">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a box collision geometry of half-extents `halfExtents`.</haxe_doc>
		</new>
		<haxe_doc>* A box collision geometry.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.CapsuleGeometry" params="" file="src/oimo/collision/geometry/CapsuleGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_radius public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_radius>
		<_halfHeight public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfHeight>
		<getRadius public="1" get="inline" set="null" line="31">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the radius of the capsule.</haxe_doc>
		</getRadius>
		<getHalfHeight public="1" get="inline" set="null" line="38">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the half-height of the capsule.</haxe_doc>
		</getHalfHeight>
		<_updateMass public="1" set="method" line="42" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="65" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="79" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<_rayCastLocal public="1" set="method" line="87" override="1">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<new public="1" set="method" line="20">
			<f a="radius:halfHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a capsule collision geometry of radius `radius` and half-height `halfHeight`.</haxe_doc>
		</new>
		<haxe_doc>* A capsule collision geometry aligned with the y-axis.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.ConeGeometry" params="" file="src/oimo/collision/geometry/ConeGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_radius public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_radius>
		<_halfHeight public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfHeight>
		<sinTheta><x path="Float"/></sinTheta>
		<cosTheta><x path="Float"/></cosTheta>
		<getRadius public="1" get="inline" set="null" line="35">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the radius of the cone.</haxe_doc>
		</getRadius>
		<getHalfHeight public="1" get="inline" set="null" line="42">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the half-height of the cone.</haxe_doc>
		</getHalfHeight>
		<_updateMass public="1" set="method" line="46" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="57" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="92" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<_rayCastLocal public="1" set="method" line="115" override="1">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<new public="1" set="method" line="23">
			<f a="radius:halfHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a cone collision geometry of radius `radius` and half-height `halfHeight`.</haxe_doc>
		</new>
		<haxe_doc>* A cone collision geometry aligned with the y-axis.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.ConvexHullGeometry" params="" file="src/oimo/collision/geometry/ConvexHullGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_vertices public="1">
			<x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_vertices>
		<_tmpVertices public="1">
			<x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpVertices>
		<_numVertices public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numVertices>
		<getVertices public="1" get="inline" set="null" line="37">
			<f a=""><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></f>
			<haxe_doc>* Returns the vertices of the convex hull.</haxe_doc>
		</getVertices>
		<_updateMass public="1" set="method" line="41" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="87" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="115" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<new public="1" set="method" line="21">
			<f a="vertices">
				<c path="Array"><c path="oimo.common.Vec3"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a convex hull collision geometry of the vertices `vertices`.</haxe_doc>
		</new>
		<haxe_doc>* A convex hull collision geometry. A convex hull of the vertices is the smallest convex
 * polyhedron which contains all vertices.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.CylinderGeometry" params="" file="src/oimo/collision/geometry/CylinderGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_radius public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_radius>
		<_halfHeight public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_halfHeight>
		<getRadius public="1" get="inline" set="null" line="30">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the radius of the cylinder.</haxe_doc>
		</getRadius>
		<getHalfHeight public="1" get="inline" set="null" line="37">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the half-height of the cylinder.</haxe_doc>
		</getHalfHeight>
		<_updateMass public="1" set="method" line="41" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="52" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="77" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<_rayCastLocal public="1" set="method" line="91" override="1">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<new public="1" set="method" line="20">
			<f a="radius:halfHeight">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a cylinder collision geometry of radius `radius` and half-height `halfHeight`.</haxe_doc>
		</new>
		<haxe_doc>* A cylinder collision geometry aligned with the y-axis.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.GeometryType" params="" file="src/oimo/collision/geometry/GeometryType.hx">
		<_SPHERE public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_SPHERE>
		<_BOX public="1" get="inline" set="null" expr="1" line="9" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_BOX>
		<_CYLINDER public="1" get="inline" set="null" expr="2" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CYLINDER>
		<_CONE public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>3</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CONE>
		<_CAPSULE public="1" get="inline" set="null" expr="4" line="12" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>4</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CAPSULE>
		<_CONVEX_HULL public="1" get="inline" set="null" expr="5" line="13" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CONVEX_HULL>
		<_CONVEX_MIN public="1" get="inline" set="null" expr="0" line="15" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CONVEX_MIN>
		<_CONVEX_MAX public="1" get="inline" set="null" expr="5" line="16" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CONVEX_MAX>
		<SPHERE public="1" set="null" expr="_SPHERE" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_SPHERE</e></m></meta>
			<haxe_doc>* Represents a sphere collision geometry.
	 *
	 * See `SphereGeometry`.</haxe_doc>
		</SPHERE>
		<BOX public="1" set="null" expr="_BOX" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_BOX</e></m></meta>
			<haxe_doc>* Represents a box collision geometry.
	 *
	 * See `BoxGeometry`.</haxe_doc>
		</BOX>
		<CYLINDER public="1" set="null" expr="_CYLINDER" line="37" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_CYLINDER</e></m></meta>
			<haxe_doc>* Represents a cylinder collision geometry.
	 *
	 * See `CylinderGeometry`.</haxe_doc>
		</CYLINDER>
		<CONE public="1" set="null" expr="_CONE" line="44" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_CONE</e></m></meta>
			<haxe_doc>* Represents a cone collision geometry.
	 *
	 * See `ConeGeometry`.</haxe_doc>
		</CONE>
		<CAPSULE public="1" set="null" expr="_CAPSULE" line="51" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_CAPSULE</e></m></meta>
			<haxe_doc>* Represents a capsule collision geometry.
	 *
	 * See `CapsuleGeometry`.</haxe_doc>
		</CAPSULE>
		<CONVEX_HULL public="1" set="null" expr="_CONVEX_HULL" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_CONVEX_HULL</e></m></meta>
			<haxe_doc>* Represents a convex hull collision geometry.
	 *
	 * See `ConvexHullGeometry`.</haxe_doc>
		</CONVEX_HULL>
		<haxe_doc>* The list of collision geometry types.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.geometry.RayCastHit" params="" file="src/oimo/collision/geometry/RayCastHit.hx">
		<position public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The position the ray hit at.</haxe_doc>
		</position>
		<normal public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The normal vector of the surface the ray hit.</haxe_doc>
		</normal>
		<fraction public="1">
			<x path="Float"/>
			<haxe_doc>* The ratio of the position the ray hit from the start point to the end point.</haxe_doc>
		</fraction>
		<new public="1" set="method" line="26">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A single ray cast hit data.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.geometry.SphereGeometry" params="" file="src/oimo/collision/geometry/SphereGeometry.hx">
		<extends path="oimo.collision.geometry.ConvexGeometry"/>
		<_radius public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_radius>
		<getRadius public="1" get="inline" set="null" line="29">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the radius of the sphere.</haxe_doc>
		</getRadius>
		<_updateMass public="1" set="method" line="33" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateMass>
		<_computeAabb public="1" set="method" line="42" override="1">
			<f a="aabb:tf">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_computeAabb>
		<computeLocalSupportingVertex public="1" set="method" line="49" override="1"><f a="dir:out">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></computeLocalSupportingVertex>
		<_rayCastLocal public="1" set="method" line="53" override="1">
			<f a="beginX:beginY:beginZ:endX:endY:endZ:hit">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastLocal>
		<new public="1" set="method" line="19">
			<f a="radius">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a sphere collision geometry of radius `radius`.</haxe_doc>
		</new>
		<haxe_doc>* A sphere collision geometry.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.narrowphase.CollisionMatrix" params="" file="src/oimo/collision/narrowphase/CollisionMatrix.hx">
		<detectors><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector.Detector"/></x></x></detectors>
		<getDetector public="1" get="inline" set="null" line="85">
			<f a="geomType1:geomType2">
				<x path="Int"/>
				<x path="Int"/>
				<c path="oimo.collision.narrowphase.detector.Detector"/>
			</f>
			<haxe_doc>* Returns an appropriate collision detector of two geometries of types `geomType1` and `geomType2`.
	 *
	 * This method is **not symmetric**, so `getDetector(a, b)` may not be equal to `getDetector(b, a)`.</haxe_doc>
		</getDetector>
		<new public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* CollisionMatrix provides corresponding collision detector for a pair of
 * two geometries of given types.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.narrowphase.DetectorResult" params="" file="src/oimo/collision/narrowphase/DetectorResult.hx">
		<numPoints public="1">
			<x path="Int"/>
			<haxe_doc>* The number of the result points.</haxe_doc>
		</numPoints>
		<points public="1">
			<x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.DetectorResultPoint"/></x>
			<haxe_doc>* The result points. Note that **only the first `DetectorResult.numPoints` points are
	 * computed by the collision detector**.</haxe_doc>
		</points>
		<normal public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The normal vector of the contact plane.</haxe_doc>
		</normal>
		<incremental public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the result points are to be used for incremental menifold update.</haxe_doc>
		</incremental>
		<getMaxDepth public="1" set="method" line="53">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the maximum depth of the result points. Returns `0.0` if no result
	 * points are available.</haxe_doc>
		</getMaxDepth>
		<clear public="1" get="inline" set="null" line="66">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Cleans up the result data.</haxe_doc>
		</clear>
		<new public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* The result of narrow-phase collision detection. This is used for generating contact
 * points of a contact constraint at once or incrementally.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.DetectorResultPoint" params="" file="src/oimo/collision/narrowphase/DetectorResultPoint.hx">
		<position1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first collision geometry's closest point.</haxe_doc>
		</position1>
		<position2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second collision geometry's closest point.</haxe_doc>
		</position2>
		<depth public="1">
			<x path="Float"/>
			<haxe_doc>* The amount of the overlap. This becomes negative if two geometries are
	 * separate.</haxe_doc>
		</depth>
		<id public="1">
			<x path="Int"/>
			<haxe_doc>* The identification of the result point.</haxe_doc>
		</id>
		<new public="1" set="method" line="33">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The result point is a pair of the closest points of collision geometries
 * detected by a collision detector. This holds relative closest points for
 * each collision geometry and the amount of the overlap.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.Detector" params="" file="src/oimo/collision/narrowphase/detector/Detector.hx">
		<swapped><x path="Bool"/></swapped>
		<setNormal set="method" line="22"><f a="result:nX:nY:nZ">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setNormal>
		<addPoint set="method" line="29"><f a="result:pos1X:pos1Y:pos1Z:pos2X:pos2Y:pos2Z:depth:id">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></addPoint>
		<detectImpl set="method" line="42"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<detect public="1" set="method" line="53">
			<f a="result:geom1:geom2:transform1:transform2:cachedData">
				<c path="oimo.collision.narrowphase.DetectorResult"/>
				<c path="oimo.collision.geometry.Geometry"/>
				<c path="oimo.collision.geometry.Geometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Computes the contact manifold of two collision geometries `geom1` and `geom2` with the transforms
	 * `transform1` and `transform2`, and stores it to `result`. `cachedData` is used to improve performance
	 * of collision detection in some detectors.</haxe_doc>
		</detect>
		<new public="1" set="method" line="16">
			<f a="swapped">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* Interface of a collision detector for narrow-phase collision detection.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.BoxBoxDetector" params="" file="src/oimo/collision/narrowphase/detector/BoxBoxDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<EDGE_BIAS_MULT get="inline" set="null" expr="1.0" line="17" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</EDGE_BIAS_MULT>
		<clipper><c path="oimo.collision.narrowphase.detector._BoxBoxDetector.FaceClipper"/></clipper>
		<detectImpl set="method" line="29" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Box vs Box detector.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector._BoxBoxDetector.IncidentVertex" params="" file="src/oimo/collision/narrowphase/detector/BoxBoxDetector.hx" private="1" module="oimo.collision.narrowphase.detector.BoxBoxDetector">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<wx public="1"><x path="Float"/></wx>
		<wy public="1"><x path="Float"/></wy>
		<wz public="1"><x path="Float"/></wz>
		<new public="1" set="method" line="577"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.narrowphase.detector._BoxBoxDetector.FaceClipper" params="" file="src/oimo/collision/narrowphase/detector/BoxBoxDetector.hx" private="1" module="oimo.collision.narrowphase.detector.BoxBoxDetector">
		<w public="1"><x path="Float"/></w>
		<h public="1"><x path="Float"/></h>
		<numVertices public="1"><x path="Int"/></numVertices>
		<vertices public="1"><x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector._BoxBoxDetector.IncidentVertex"/></x></vertices>
		<numTmpVertices><x path="Int"/></numTmpVertices>
		<tmpVertices><x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector._BoxBoxDetector.IncidentVertex"/></x></tmpVertices>
		<clip public="1" set="method" line="646">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clips the incident face by the reference face, generates up to eight vertices.</haxe_doc>
		</clip>
		<reduce public="1" set="method" line="660">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Reduces vertices up to four.</haxe_doc>
		</reduce>
		<new public="1" set="method" line="619"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.BoxBoxDetectorMacro" params="" file="src/oimo/collision/narrowphase/detector/BoxBoxDetectorMacro.hx"><meta>
	<m n=":dox"><e>hide</e></m>
	<m n=":extern"/>
</meta></class>
	<class path="oimo.collision.narrowphase.detector.CachedDetectorData" params="" file="src/oimo/collision/narrowphase/detector/CachedDetectorData.hx">
		<_gjkCache public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.GjkCache"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_gjkCache>
		<_clear public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_clear>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* This is used for caching narrow-phase data of a pair of collision geometries.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.CapsuleCapsuleDetector" params="" file="src/oimo/collision/narrowphase/detector/CapsuleCapsuleDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<detectImpl set="method" line="21" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Capsule vs Capsule detector.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.GjkEpaDetector" params="" file="src/oimo/collision/narrowphase/detector/GjkEpaDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<detectImpl set="method" line="20" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="16">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* General convex collision detector using GJK/EPA</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.SphereBoxDetector" params="" file="src/oimo/collision/narrowphase/detector/SphereBoxDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<detectImpl set="method" line="23" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="19">
			<f a="swapped">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If `swapped` is `true`, the collision detector expects `BoxGeometry` and `SphereGeometry` for the
	 * first and second argument of `SphereBoxDetector.detect`. If `swapped` is `false`, the collision detector expects
	 * `SphereGeometry` and `BoxGeometry` instead.</haxe_doc>
		</new>
		<haxe_doc>* Sphere vs Box collision detector.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.SphereCapsuleDetector" params="" file="src/oimo/collision/narrowphase/detector/SphereCapsuleDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<detectImpl set="method" line="23" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="19">
			<f a="swapped">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* If `swapped` is `true`, the collision detector expects `CapsuleGeometry` and `SphereGeometry` for the
	 * first and second argument of `SphereCapsuleDetector.detect`. If `swapped` is `false`, the collision detector expects
	 * `SphereGeometry` and `CapsuleGeometry` instead.</haxe_doc>
		</new>
		<haxe_doc>* Sphere vs Capsule detector.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.SphereSphereDetector" params="" file="src/oimo/collision/narrowphase/detector/SphereSphereDetector.hx">
		<extends path="oimo.collision.narrowphase.detector.Detector"/>
		<detectImpl set="method" line="21" override="1"><f a="result:geom1:geom2:tf1:tf2:cachedData">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.collision.geometry.Geometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Void"/>
</f></detectImpl>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Sphere vs Sphere detector.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.EpaPolyhedron" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/EpaPolyhedron.hx">
		<_vertices public="1">
			<x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_vertices>
		<_numVertices public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numVertices>
		<_triangleList public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_triangleList>
		<_triangleListLast public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_triangleListLast>
		<_numTriangles public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numTriangles>
		<_trianglePool public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_trianglePool>
		<_vertexPool public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_vertexPool>
		<_center public="1">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_center>
		<_status public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_status>
		<dumpHoleEdge set="method" line="61"><f a="first">
	<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
	<x path="Void"/>
</f></dumpHoleEdge>
		<validate set="method" line="79"><f a=""><x path="Bool"/></f></validate>
		<findEdgeLoop set="method" line="101"><f a="id:base:from">
	<x path="Int"/>
	<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></findEdgeLoop>
		<_init public="1" set="method" line="171">
			<f a="v1:v2:v3:v4">
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_init>
		<_addVertex public="1" set="method" line="217">
			<f a="vertex:base">
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addVertex>
		<_dumpAsObjModel public="1" set="method" line="270">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_dumpAsObjModel>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.EpaPolyhedronState" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/EpaPolyhedronState.hx">
		<OK public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</OK>
		<INVALID_TRIANGLE public="1" get="inline" set="null" expr="1" line="9" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</INVALID_TRIANGLE>
		<NO_ADJACENT_PAIR_INDEX public="1" get="inline" set="null" expr="2" line="10" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</NO_ADJACENT_PAIR_INDEX>
		<NO_ADJACENT_TRIANGLE public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>3</e></m></meta>
		</NO_ADJACENT_TRIANGLE>
		<EDGE_LOOP_BROKEN public="1" get="inline" set="null" expr="4" line="12" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</EDGE_LOOP_BROKEN>
		<NO_OUTER_TRIANGLE public="1" get="inline" set="null" expr="5" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>5</e></m></meta>
		</NO_OUTER_TRIANGLE>
		<TRIANGLE_INVISIBLE public="1" get="inline" set="null" expr="6" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</TRIANGLE_INVISIBLE>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta><m n=":dox"><e>hide</e></m></meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/EpaTriangle.hx">
		<count public="1" expr="0" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</count>
		<_next public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_prev public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_vertices public="1">
			<x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_vertices>
		<_adjacentTriangles public="1">
			<x path="haxe.ds.Vector"><c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_adjacentTriangles>
		<_adjacentPairIndex public="1">
			<x path="haxe.ds.Vector"><x path="Int"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_adjacentPairIndex>
		<_normal public="1">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_normal>
		<_distanceSq public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_distanceSq>
		<_nextIndex public="1">
			<x path="haxe.ds.Vector"><x path="Int"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_nextIndex>
		<_tmpDfsId public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpDfsId>
		<_tmpDfsVisible public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpDfsVisible>
		<tmp><c path="oimo.common.Vec3"/></tmp>
		<id public="1" expr="++count">
			<x path="Int"/>
			<meta><m n=":value"><e>++count</e></m></meta>
		</id>
		<init public="1" set="method" line="58">
			<f a="vertex1:vertex2:vertex3:center:?autoCheck" v="::::false">
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
				<c path="oimo.common.Vec3"/>
				<x path="Bool"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ autoCheck : false }</e></m></meta>
		</init>
		<setAdjacentTriangle public="1" set="method" line="107"><f a="triangle">
	<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
	<x path="Bool"/>
</f></setAdjacentTriangle>
		<removeAdjacentTriangles public="1" get="inline" set="null" line="130"><f a=""><x path="Void"/></f></removeAdjacentTriangles>
		<removeReferences public="1" set="method" line="143"><f a=""><x path="Void"/></f></removeReferences>
		<dump public="1" set="method" line="160"><f a=""><x path="Void"/></f></dump>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/EpaVertex.hx">
		<_next public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<v public="1"><c path="oimo.common.Vec3"/></v>
		<w1 public="1"><c path="oimo.common.Vec3"/></w1>
		<w2 public="1"><c path="oimo.common.Vec3"/></w2>
		<_tmpEdgeLoopNext public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpEdgeLoopNext>
		<_tmpEdgeLoopOuterTriangle public="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.EpaTriangle"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tmpEdgeLoopOuterTriangle>
		<randId public="1" expr="Std.int(Math.random() * 100000)">
			<x path="Int"/>
			<meta><m n=":value"><e>Std.int(Math.random() * 100000)</e></m></meta>
		</randId>
		<init public="1" set="method" line="27"><f a="v:w1:w2">
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.narrowphase.detector.gjkepa.EpaVertex"/>
</f></init>
		<removeReferences public="1" set="method" line="37"><f a=""><x path="Void"/></f></removeReferences>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.GjkCache" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/GjkCache.hx">
		<prevClosestDir public="1"><c path="oimo.common.Vec3"/></prevClosestDir>
		<clear public="1" set="method" line="17"><f a=""><x path="Void"/></f></clear>
		<new public="1" set="method" line="13"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.common.Vec3" params="" file="src/oimo/common/Vec3.hx">
		<numCreations public="1" expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of instance creation.</haxe_doc>
		</numCreations>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The x-value of the vector.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The y-value of the vector.</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>* The z-value of the vector.</haxe_doc>
		</z>
		<init public="1" set="method" line="47">
			<f a="x:y:z">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets all values at once and returns `this`.</haxe_doc>
		</init>
		<zero public="1" set="method" line="57">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Sets this vector to zero vector and returns `this`.</haxe_doc>
		</zero>
		<add public="1" get="inline" set="null" line="74">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns `this` + `v`.</haxe_doc>
		</add>
		<add3 public="1" get="inline" set="null" line="81">
			<f a="vx:vy:vz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns (`this.x` + `vx`, `this.y` + `vy`, `this.z` + `vz`).</haxe_doc>
		</add3>
		<addScaled public="1" get="inline" set="null" line="88">
			<f a="v:s">
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns `this` + `v` * `s`.</haxe_doc>
		</addScaled>
		<sub public="1" get="inline" set="null" line="95">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns `this` - `v`.</haxe_doc>
		</sub>
		<sub3 public="1" get="inline" set="null" line="102">
			<f a="vx:vy:vz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns (`this.x` - `vx`, `this.y` - `vy`, `this.z` - `vz`).</haxe_doc>
		</sub3>
		<scale public="1" get="inline" set="null" line="109">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns `this` * `s`.</haxe_doc>
		</scale>
		<scale3 public="1" get="inline" set="null" line="116">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns (`this.x` * `sx`, `this.y` * `sy`, `this.z` * `sz`).</haxe_doc>
		</scale3>
		<dot public="1" get="inline" set="null" line="123">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the dot product of `this` and `v`.</haxe_doc>
		</dot>
		<cross public="1" get="inline" set="null" line="130">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the cross product of `this` and `v`.</haxe_doc>
		</cross>
		<addEq public="1" get="inline" set="null" line="141">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to `this` + `v` and returns `this`.</haxe_doc>
		</addEq>
		<add3Eq public="1" get="inline" set="null" line="148">
			<f a="vx:vy:vz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to (`this.x` + `vx`, `this.y` + `vy`, `this.z` + `vz`) and returns `this`.</haxe_doc>
		</add3Eq>
		<addScaledEq public="1" get="inline" set="null" line="155">
			<f a="v:s">
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to `this` + `v` * `s` and returns `this`.</haxe_doc>
		</addScaledEq>
		<subEq public="1" get="inline" set="null" line="162">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to `this` - `v` and returns `this`.</haxe_doc>
		</subEq>
		<sub3Eq public="1" get="inline" set="null" line="169">
			<f a="vx:vy:vz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to (`this.x` - `vx`, `this.y` - `vy`, `this.z` - `vz`) and returns `this`.</haxe_doc>
		</sub3Eq>
		<scaleEq public="1" get="inline" set="null" line="176">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to `this` * `s` and returns `this`.</haxe_doc>
		</scaleEq>
		<scale3Eq public="1" get="inline" set="null" line="183">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to (`this.x` * `sx`, `this.y` * `sy`, `this.z` * `sz`) and returns `this`.</haxe_doc>
		</scale3Eq>
		<crossEq public="1" get="inline" set="null" line="190">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to the cross product of `this` and `s`, and returns `this`.</haxe_doc>
		</crossEq>
		<mulMat3 public="1" get="inline" set="null" line="201">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the transformed vector by `m`.</haxe_doc>
		</mulMat3>
		<mulMat4 public="1" get="inline" set="null" line="212">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the transformed vector by `m`.</haxe_doc>
		</mulMat4>
		<mulTransform public="1" get="inline" set="null" line="223">
			<f a="tf">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the transformed vector by `tf`.</haxe_doc>
		</mulTransform>
		<mulMat3Eq public="1" get="inline" set="null" line="236">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to the transformed vector by `m` and returns `this`.</haxe_doc>
		</mulMat3Eq>
		<mulMat4Eq public="1" get="inline" set="null" line="247">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to the transformed vector by `m` and returns `this`.</haxe_doc>
		</mulMat4Eq>
		<mulTransformEq public="1" get="inline" set="null" line="258">
			<f a="tf">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Sets this vector to the transformed vector by `tf` and returns `this`.</haxe_doc>
		</mulTransformEq>
		<length public="1" get="inline" set="null" line="270">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the length of the vector.</haxe_doc>
		</length>
		<lengthSq public="1" get="inline" set="null" line="277">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the squared length of the vector.</haxe_doc>
		</lengthSq>
		<normalized public="1" get="inline" set="null" line="286">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the normalized vector.
	 *
	 * If the length is zero, zero vector is returned.</haxe_doc>
		</normalized>
		<normalize public="1" get="inline" set="null" line="297">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Normalize this vector and returns `this`.
	 *
	 * If the length is zero, this vector is set to zero vector.</haxe_doc>
		</normalize>
		<negate public="1" get="inline" set="null" line="306">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the nagated vector.</haxe_doc>
		</negate>
		<negateEq public="1" get="inline" set="null" line="313">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Negate the vector and returns `this`.</haxe_doc>
		</negateEq>
		<copyFrom public="1" get="inline" set="null" line="320">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Copies values from `v` and returns `this`.</haxe_doc>
		</copyFrom>
		<clone public="1" get="inline" set="null" line="330">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns a clone of the vector.</haxe_doc>
		</clone>
		<toString public="1" set="method" line="337">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the string representation of the vector.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="37">
			<f a="?x:?y:?z" v="0:0:0">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ z : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Creates a new vector. The vector is zero vector by default.</haxe_doc>
		</new>
		<haxe_doc>* 3D vector class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.common.Transform" params="" file="src/oimo/common/Transform.hx">
		<_positionX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_positionX>
		<_positionY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_positionY>
		<_positionZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_positionZ>
		<_rotation00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation00>
		<_rotation01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation01>
		<_rotation02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation02>
		<_rotation10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation10>
		<_rotation11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation11>
		<_rotation12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation12>
		<_rotation20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation20>
		<_rotation21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation21>
		<_rotation22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotation22>
		<identity public="1" get="inline" set="null" line="31">
			<f a=""><c path="oimo.common.Transform"/></f>
			<haxe_doc>* Sets the transformation to identity and returns `this`.</haxe_doc>
		</identity>
		<getPosition public="1" get="inline" set="null" line="40">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the position of the transformation.</haxe_doc>
		</getPosition>
		<getPositionTo public="1" get="inline" set="null" line="51">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `position` to the position of the transformation.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getPositionTo>
		<setPosition public="1" get="inline" set="null" line="58">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Transform"/>
			</f>
			<haxe_doc>* Sets the position of the transformation to `position` and returns `this`.</haxe_doc>
		</setPosition>
		<translate public="1" get="inline" set="null" line="66">
			<f a="translation">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Translates the position by `translation`.</haxe_doc>
		</translate>
		<getRotation public="1" get="inline" set="null" line="75">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the rotation matrix.</haxe_doc>
		</getRotation>
		<getRotationTo public="1" get="inline" set="null" line="86">
			<f a="out">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `out` to the rotation matrix.
	 *
	 * This does not create a new instance of `Mat3`.</haxe_doc>
		</getRotationTo>
		<setRotation public="1" get="inline" set="null" line="93">
			<f a="rotation">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Transform"/>
			</f>
			<haxe_doc>* Sets the rotation matrix to `rotation` and returns `this`.</haxe_doc>
		</setRotation>
		<setRotationXyz public="1" get="inline" set="null" line="101">
			<f a="eulerAngles">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rotation by Euler angles `eulerAngles` in radians.</haxe_doc>
		</setRotationXyz>
		<rotate public="1" get="inline" set="null" line="110">
			<f a="rotation">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies rotation by the rotation matrix `rotation`.</haxe_doc>
		</rotate>
		<rotateXyz public="1" get="inline" set="null" line="119">
			<f a="eulerAngles">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the rotation by Euler angles `eulerAngles` in radians.</haxe_doc>
		</rotateXyz>
		<getOrientation public="1" get="inline" set="null" line="130">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns the rotation as a quaternion.</haxe_doc>
		</getOrientation>
		<getOrientationTo public="1" get="inline" set="null" line="143">
			<f a="orientation">
				<c path="oimo.common.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `orientation` to the quaternion representing the rotation.
	 *
	 * This does not create a new instance of `Quat`.</haxe_doc>
		</getOrientationTo>
		<setOrientation public="1" get="inline" set="null" line="152">
			<f a="quaternion">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Transform"/>
			</f>
			<haxe_doc>* Sets the rotation from a quaternion `quaternion` and returns `this`.</haxe_doc>
		</setOrientation>
		<clone public="1" get="inline" set="null" line="162">
			<f a=""><c path="oimo.common.Transform"/></f>
			<haxe_doc>* Returns a clone of the transformation.</haxe_doc>
		</clone>
		<copyFrom public="1" get="inline" set="null" line="172">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
			</f>
			<haxe_doc>* Sets the transformation to `transform` and returns `this`.</haxe_doc>
		</copyFrom>
		<new public="1" set="method" line="23">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Creates a new identical transform.</haxe_doc>
		</new>
		<haxe_doc>* Transform class provides a set of translation and rotation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.common.Setting" params="" file="src/oimo/common/Setting.hx">
		<defaultFriction public="1" expr="0.2" line="18" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.2</e></m></meta>
		</defaultFriction>
		<defaultRestitution public="1" expr="0.2" line="19" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.2</e></m></meta>
		</defaultRestitution>
		<defaultDensity public="1" expr="1" line="20" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</defaultDensity>
		<defaultCollisionGroup public="1" expr="1" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</defaultCollisionGroup>
		<defaultCollisionMask public="1" expr="1" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</defaultCollisionMask>
		<maxTranslationPerStep public="1" expr="20" line="25" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>20</e></m></meta>
		</maxTranslationPerStep>
		<maxRotationPerStep public="1" expr="MathUtil.PI" line="26" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>MathUtil.PI</e></m></meta>
		</maxRotationPerStep>
		<bvhProxyPadding public="1" expr="0.1" line="29" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.1</e></m></meta>
		</bvhProxyPadding>
		<bvhIncrementalCollisionThreshold public="1" expr="0.45" line="30" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.45</e></m></meta>
		</bvhIncrementalCollisionThreshold>
		<defaultGJKMargin public="1" expr="0.05" line="33" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</defaultGJKMargin>
		<enableGJKCaching public="1" expr="true" line="34" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>true</e></m></meta>
		</enableGJKCaching>
		<maxEPAVertices public="1" expr="128" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</maxEPAVertices>
		<maxEPAPolyhedronFaces public="1" expr="128" line="36" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</maxEPAPolyhedronFaces>
		<contactEnableBounceThreshold public="1" expr="0.5" line="39" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</contactEnableBounceThreshold>
		<velocityBaumgarte public="1" expr="0.2" line="40" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.2</e></m></meta>
		</velocityBaumgarte>
		<positionSplitImpulseBaumgarte public="1" expr="0.4" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.4</e></m></meta>
		</positionSplitImpulseBaumgarte>
		<positionNgsBaumgarte public="1" expr="1.0" line="42" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</positionNgsBaumgarte>
		<contactUseAlternativePositionCorrectionAlgorithmDepthThreshold public="1" expr="0.05" line="45" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</contactUseAlternativePositionCorrectionAlgorithmDepthThreshold>
		<defaultContactPositionCorrectionAlgorithm public="1" expr="PositionCorrectionAlgorithm._BAUMGARTE" line="46" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>PositionCorrectionAlgorithm._BAUMGARTE</e></m></meta>
		</defaultContactPositionCorrectionAlgorithm>
		<alternativeContactPositionCorrectionAlgorithm public="1" expr="PositionCorrectionAlgorithm._SPLIT_IMPULSE" line="47" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>PositionCorrectionAlgorithm._SPLIT_IMPULSE</e></m></meta>
		</alternativeContactPositionCorrectionAlgorithm>
		<contactPersistenceThreshold public="1" expr="0.05" line="48" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.05</e></m></meta>
		</contactPersistenceThreshold>
		<maxManifoldPoints public="1" expr="4" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</maxManifoldPoints>
		<defaultJointConstraintSolverType public="1" expr="ConstraintSolverType._ITERATIVE" line="52" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>ConstraintSolverType._ITERATIVE</e></m></meta>
		</defaultJointConstraintSolverType>
		<defaultJointPositionCorrectionAlgorithm public="1" expr="PositionCorrectionAlgorithm._BAUMGARTE" line="53" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>PositionCorrectionAlgorithm._BAUMGARTE</e></m></meta>
		</defaultJointPositionCorrectionAlgorithm>
		<jointWarmStartingFactorForBaungarte public="1" expr="0.8" line="54" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.8</e></m></meta>
		</jointWarmStartingFactorForBaungarte>
		<jointWarmStartingFactor public="1" expr="0.95" line="55" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.95</e></m></meta>
		</jointWarmStartingFactor>
		<minSpringDamperDampingRatio public="1" expr="1e-6" line="56" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-6</e></m></meta>
		</minSpringDamperDampingRatio>
		<minRagdollMaxSwingAngle public="1" expr="1e-6" line="57" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-6</e></m></meta>
		</minRagdollMaxSwingAngle>
		<maxJacobianRows public="1" expr="6" line="58" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>6</e></m></meta>
		</maxJacobianRows>
		<directMlcpSolverEps public="1" expr="1e-9" line="61" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e-9</e></m></meta>
		</directMlcpSolverEps>
		<islandInitialRigidBodyArraySize public="1" expr="128" line="64" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</islandInitialRigidBodyArraySize>
		<islandInitialConstraintArraySize public="1" expr="128" line="65" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>128</e></m></meta>
		</islandInitialConstraintArraySize>
		<sleepingVelocityThreshold public="1" expr="0.2" line="68" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.2</e></m></meta>
		</sleepingVelocityThreshold>
		<sleepingAngularVelocityThreshold public="1" expr="0.5" line="69" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</sleepingAngularVelocityThreshold>
		<sleepingTimeThreshold public="1" expr="1.0" line="70" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1.0</e></m></meta>
		</sleepingTimeThreshold>
		<disableSleeping public="1" expr="false" line="71" static="1">
			<x path="Bool"/>
			<meta><m n=":value"><e>false</e></m></meta>
		</disableSleeping>
		<linearSlop public="1" expr="0.005" line="74" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0.005</e></m></meta>
		</linearSlop>
		<angularSlop public="1" expr="1 * MathUtil.TO_RADIANS" line="75" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1 * MathUtil.TO_RADIANS</e></m></meta>
		</angularSlop>
		<haxe_doc>* Setting provides advenced parameters used by the physics simulation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.GjkEpa" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/GjkEpa.hx">
		<instance expr="new GjkEpa()" line="21" static="1">
			<c path="oimo.collision.narrowphase.detector.gjkepa.GjkEpa"/>
			<meta><m n=":value"><e>new GjkEpa()</e></m></meta>
		</instance>
		<getInstance public="1" get="inline" set="null" line="869" static="1">
			<f a=""><c path="oimo.collision.narrowphase.detector.gjkepa.GjkEpa"/></f>
			<haxe_doc>* Returns an instance of `GjkEpa`.</haxe_doc>
		</getInstance>
		<c1><c path="oimo.collision.geometry.ConvexGeometry"/></c1>
		<c2><c path="oimo.collision.geometry.ConvexGeometry"/></c2>
		<tf1><c path="oimo.common.Transform"/></tf1>
		<tf2><c path="oimo.common.Transform"/></tf2>
		<s><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></s>
		<simplexSize><x path="Int"/></simplexSize>
		<w1><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></w1>
		<w2><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></w2>
		<tempVec3s><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></tempVec3s>
		<tempTransform><c path="oimo.common.Transform"/></tempTransform>
		<dir><c path="oimo.common.Vec3"/></dir>
		<closest><c path="oimo.common.Vec3"/></closest>
		<baseDirs><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></baseDirs>
		<tl1><c path="oimo.common.Vec3"/></tl1>
		<tl2><c path="oimo.common.Vec3"/></tl2>
		<rayX><c path="oimo.common.Vec3"/></rayX>
		<rayR><c path="oimo.common.Vec3"/></rayR>
		<depth><x path="Float"/></depth>
		<polyhedron><c path="oimo.collision.narrowphase.detector.gjkepa.EpaPolyhedron"/></polyhedron>
		<closestPoint1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* Computed closest point of the first geometry in world coordinate system.</haxe_doc>
		</closestPoint1>
		<closestPoint2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* Computed closest point of the second geometry in world coordinate system.</haxe_doc>
		</closestPoint2>
		<distance public="1">
			<x path="Float"/>
			<haxe_doc>* Computed distance between two geometries. This value may be negative if two
	 * geometries are overlapping.</haxe_doc>
		</distance>
		<computeClosestPointsImpl set="method" line="111"><f a="c1:c2:tf1:tf2:cache:useEpa">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
	<x path="Bool"/>
	<x path="Int"/>
</f></computeClosestPointsImpl>
		<convexCastImpl set="method" line="259"><f a="c1:c2:tf1:tf2:tl1:tl2:hit">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.common.Vec3"/>
	<c path="oimo.collision.geometry.RayCastHit"/>
	<x path="Bool"/>
</f></convexCastImpl>
		<interpolateClosestPoints set="method" line="422"><f a=""><x path="Void"/></f></interpolateClosestPoints>
		<loadCache set="method" line="510"><f a="gjkCache">
	<c path="oimo.collision.narrowphase.detector.gjkepa.GjkCache"/>
	<x path="Void"/>
</f></loadCache>
		<saveCache set="method" line="515"><f a="gjkCache">
	<c path="oimo.collision.narrowphase.detector.gjkepa.GjkCache"/>
	<x path="Void"/>
</f></saveCache>
		<shrinkSimplex set="method" line="520"><f a="vertexBits">
	<x path="Int"/>
	<x path="Void"/>
</f></shrinkSimplex>
		<computeWitnessPoint1 set="method" line="596"><f a="addMargin">
	<x path="Bool"/>
	<x path="Void"/>
</f></computeWitnessPoint1>
		<computeWitnessPoint2 set="method" line="623"><f a="addMargin">
	<x path="Bool"/>
	<x path="Void"/>
</f></computeWitnessPoint2>
		<pointToTetrahedron set="method" line="651"><f a=""><x path="Void"/></f></pointToTetrahedron>
		<lineToTetrahedron set="method" line="671"><f a=""><x path="Void"/></f></lineToTetrahedron>
		<triangleToTetrahedron set="method" line="706"><f a=""><x path="Void"/></f></triangleToTetrahedron>
		<isValidTetrahedron set="method" line="741"><f a=""><x path="Bool"/></f></isValidTetrahedron>
		<computeDepth set="method" line="757"><f a="convex1:convex2:tf1:tf2:initialPolyhedron:initialPolyhedron1:initialPolyhedron2">
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.collision.geometry.ConvexGeometry"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x>
	<x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x>
	<x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x>
	<x path="Int"/>
</f></computeDepth>
		<computeClosestPoints public="1" get="inline" set="null" line="881">
			<f a="c1:c2:tf1:tf2:cache">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Computes the closest points of two convex geometries `c1` and `c2` with transforms `tf1` and `tf2`
	 * respectively, and returns the status of the result (see `GjkEpaResultState` for details). If cached
	 * data `cache` is not `null`, this tries to exploit the previous result in `cache` to improve performance,
	 * and stores the new result to `cache`.
	 *
	 * Set the compiler option `OIMO_GJK_EPA_DEBUG` for debugging (warning: massive logging).</haxe_doc>
		</computeClosestPoints>
		<computeDistance public="1" get="inline" set="null" line="894">
			<f a="c1:c2:tf1:tf2:cache">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Computes the distance between two convex geometries `c1` and `c2` with transforms `tf1` and `tf2`
	 * respectively, and returns the status of the result (see `GjkEpaResultState` for details). Different
	 * from `GjkEpa.computeClosestPoints`, this does not compute negative distances and closest points if
	 * two geometries are overlapping. If cached data `cache` is not `null`, this tries to exploit the
	 * previous result in `cache` to improve performance, and stores the new result to `cache`.
	 *
	 * Set the compiler option `OIMO_GJK_EPA_DEBUG` for debugging (warning: massive logging).</haxe_doc>
		</computeDistance>
		<convexCast public="1" set="method" line="905">
			<f a="c1:c2:tf1:tf2:tl1:tl2:hit">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Performs a convex casting between `c1` and `c2`. Returns `true` and sets the result information
	 * to `hit` if the convex geometries intersect. Each convex geometries translates by `tl1` and `tl2`,
	 * starting from the beginning transforms `tf1` and `tf2` respectively.
	 *
	 * Set the compiler option `OIMO_GJK_EPA_DEBUG` for debugging (warning: massive logging).</haxe_doc>
		</convexCast>
		<rayCast public="1" set="method" line="916">
			<f a="c:tf:begin:end:hit">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>* Performs ray cansting against the convex geometry `c` with transform `tf`. Returns `true` and sets
	 * the result information to `hit` if the line segment from `begin` to `end` intersects the convex
	 * geometry. Otherwise returns `false`.
	 *
	 * Set the compiler option `OIMO_GJK_EPA_DEBUG` for debugging (warning: massive logging).</haxe_doc>
		</rayCast>
		<new public="1" set="method" line="78">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor. Consider using `GjkEpa.getInstance` instead of creating a new
	 * instance.</haxe_doc>
		</new>
		<haxe_doc>* GJK algorithm and EPA for narrow-phase collision detection.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.GjkEpaLog" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/GjkEpaLog.hx"><meta>
	<m n=":extern"/>
	<m n=":dox"><e>hide</e></m>
</meta></class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.GjkEpaResultState" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/GjkEpaResultState.hx">
		<_SUCCEEDED public="1" get="inline" set="null" expr="0x000" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x000</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_SUCCEEDED>
		<_GJK_FAILED_TO_MAKE_TETRAHEDRON public="1" get="inline" set="null" expr="0x001" line="9" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x001</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_GJK_FAILED_TO_MAKE_TETRAHEDRON>
		<_GJK_DID_NOT_CONVERGE public="1" get="inline" set="null" expr="0x002" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x002</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_GJK_DID_NOT_CONVERGE>
		<_EPA_FAILED_TO_INIT public="1" get="inline" set="null" expr="0x101" line="11" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x101</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_EPA_FAILED_TO_INIT>
		<_EPA_FAILED_TO_ADD_VERTEX public="1" get="inline" set="null" expr="0x102" line="12" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x102</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_EPA_FAILED_TO_ADD_VERTEX>
		<_EPA_DID_NOT_CONVERGE public="1" get="inline" set="null" expr="0x103" line="13" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0x103</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_EPA_DID_NOT_CONVERGE>
		<SUCCEEDED public="1" set="null" expr="_SUCCEEDED" line="18" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_SUCCEEDED</e></m></meta>
			<haxe_doc>* GJK/EPA computation is successfully finished.</haxe_doc>
		</SUCCEEDED>
		<GJK_FAILED_TO_MAKE_TETRAHEDRON public="1" set="null" expr="_GJK_FAILED_TO_MAKE_TETRAHEDRON" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_GJK_FAILED_TO_MAKE_TETRAHEDRON</e></m></meta>
			<haxe_doc>* Failed to construct a tetrahedron enclosing the origin in GJK computation.</haxe_doc>
		</GJK_FAILED_TO_MAKE_TETRAHEDRON>
		<GJK_DID_NOT_CONVERGE public="1" set="null" expr="_GJK_DID_NOT_CONVERGE" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_GJK_DID_NOT_CONVERGE</e></m></meta>
			<haxe_doc>* GJK iterations did not converge in time.</haxe_doc>
		</GJK_DID_NOT_CONVERGE>
		<EPA_FAILED_TO_INIT public="1" set="null" expr="_EPA_FAILED_TO_INIT" line="33" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_EPA_FAILED_TO_INIT</e></m></meta>
			<haxe_doc>* Failed to construct initial polyhedron in EPA construction.</haxe_doc>
		</EPA_FAILED_TO_INIT>
		<EPA_FAILED_TO_ADD_VERTEX public="1" set="null" expr="_EPA_FAILED_TO_ADD_VERTEX" line="38" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_EPA_FAILED_TO_ADD_VERTEX</e></m></meta>
			<haxe_doc>* Failed to add a new vertex to the polyhedron in EPA computation.</haxe_doc>
		</EPA_FAILED_TO_ADD_VERTEX>
		<EPA_DID_NOT_CONVERGE public="1" set="null" expr="_EPA_DID_NOT_CONVERGE" line="43" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_EPA_DID_NOT_CONVERGE</e></m></meta>
			<haxe_doc>* EPA iterations did not converge in time.</haxe_doc>
		</EPA_DID_NOT_CONVERGE>
		<haxe_doc>* The list of the state of a result of `GjkEpa.computeClosestPoints`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.collision.narrowphase.detector.gjkepa.SimplexUtil" params="" file="src/oimo/collision/narrowphase/detector/gjkepa/SimplexUtil.hx">
		<projectOrigin2 public="1" get="inline" set="null" line="15" static="1">
			<f a="vec1:vec2:out">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Sets `out` to the minimum length point on the line (`vec1`, `vec2`)
	 * and returns the index of the voronoi region.</haxe_doc>
		</projectOrigin2>
		<projectOrigin3 public="1" get="inline" set="null" line="47" static="1">
			<f a="vec1:vec2:vec3:out">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Sets `out` to the minimum length point on the triangle (`vec1`, `vec2`, `vec3`)
	 * and returns the index of the voronoi region.</haxe_doc>
		</projectOrigin3>
		<projectOrigin4 public="1" get="inline" set="null" line="122" static="1">
			<f a="vec1:vec2:vec3:vec4:out">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Int"/>
			</f>
			<haxe_doc>* Sets `out` to the minimum length point on the tetrahedron (`vec1`, `vec2`, `vec3`, `vec4`)
	 * and returns the index of the voronoi region.</haxe_doc>
		</projectOrigin4>
		<haxe_doc>* Simplex utilities for GJK/EPA computations.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.common.Mat3" params="" file="src/oimo/common/Mat3.hx">
		<numCreations public="1" expr="0" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of instance creation.</haxe_doc>
		</numCreations>
		<e00 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 0.</haxe_doc>
		</e00>
		<e01 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 1.</haxe_doc>
		</e01>
		<e02 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 2.</haxe_doc>
		</e02>
		<e10 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 0.</haxe_doc>
		</e10>
		<e11 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 1.</haxe_doc>
		</e11>
		<e12 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 2.</haxe_doc>
		</e12>
		<e20 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 0.</haxe_doc>
		</e20>
		<e21 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 1.</haxe_doc>
		</e21>
		<e22 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 2.</haxe_doc>
		</e22>
		<init public="1" get="inline" set="null" line="119">
			<f a="e00:e01:e02:e10:e11:e12:e20:e21:e22">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets all elements at once and returns `this`.</haxe_doc>
		</init>
		<identity public="1" get="inline" set="null" line="135">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Sets this matrix to identity matrix and returns `this`.</haxe_doc>
		</identity>
		<add public="1" get="inline" set="null" line="147">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` + `m`</haxe_doc>
		</add>
		<sub public="1" get="inline" set="null" line="158">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` - `m`</haxe_doc>
		</sub>
		<scale public="1" get="inline" set="null" line="169">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` * `s`</haxe_doc>
		</scale>
		<mul public="1" get="inline" set="null" line="180">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` * `m`</haxe_doc>
		</mul>
		<addEq public="1" get="inline" set="null" line="197">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` + `m` and returns `this`.</haxe_doc>
		</addEq>
		<subEq public="1" get="inline" set="null" line="208">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` - `m` and returns `this`.</haxe_doc>
		</subEq>
		<scaleEq public="1" get="inline" set="null" line="219">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * `s` and returns `this`.</haxe_doc>
		</scaleEq>
		<mulEq public="1" get="inline" set="null" line="230">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * `m` and returns `this`.</haxe_doc>
		</mulEq>
		<prependScale public="1" get="inline" set="null" line="250">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns *scaling matrix* * `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependScale>
		<appendScale public="1" get="inline" set="null" line="264">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` * *scaling matrix*.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendScale>
		<prependRotation public="1" get="inline" set="null" line="278">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns *rotation matrix* * `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</prependRotation>
		<appendRotation public="1" get="inline" set="null" line="310">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Returns `this` * *rotation matrix*.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</appendRotation>
		<prependScaleEq public="1" get="inline" set="null" line="342">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to *scaling matrix* * `this`, and returns `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependScaleEq>
		<appendScaleEq public="1" get="inline" set="null" line="356">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * *scaling matrix*, and returns `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendScaleEq>
		<prependRotationEq public="1" get="inline" set="null" line="370">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to *rotation matrix* * `this`, and returns `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</prependRotationEq>
		<appendRotationEq public="1" get="inline" set="null" line="402">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * *rotation matrix*, and returns `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</appendRotationEq>
		<transpose public="1" get="inline" set="null" line="431">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the transposed matrix.</haxe_doc>
		</transpose>
		<transposeEq public="1" get="inline" set="null" line="442">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Sets this matrix to the transposed matrix and returns `this`.</haxe_doc>
		</transposeEq>
		<determinant public="1" get="inline" set="null" line="453">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the determinant.</haxe_doc>
		</determinant>
		<trace public="1" get="inline" set="null" line="460">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the trace.</haxe_doc>
		</trace>
		<inverse public="1" get="inline" set="null" line="469">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the inverse matrix.
	 *
	 * If the determinant is zero, zero matrix is returned.</haxe_doc>
		</inverse>
		<inverseEq public="1" get="inline" set="null" line="493">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Sets this matrix to the inverse matrix and returns `this`.
	 *
	 * If the determinant is zero, this matrix is set to zero matrix.</haxe_doc>
		</inverseEq>
		<toArray public="1" get="inline" set="null" line="518">
			<f a="?columnMajor" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ columnMajor : false }</e></m></meta>
			<haxe_doc>* Returns an array of the elements of this matrix.
	 *
	 * If `columnMajor` is true, the array is arranged in column-major order.
	 * Otherwise, the array is arranged in row-major order.</haxe_doc>
		</toArray>
		<copyFrom public="1" get="inline" set="null" line="537">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Copies values from `m` and returns `this`.</haxe_doc>
		</copyFrom>
		<clone public="1" get="inline" set="null" line="553">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns a clone of the matrix.</haxe_doc>
		</clone>
		<fromQuat public="1" get="inline" set="null" line="564">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to the representation of the quaternion `q`, and returns `this`.</haxe_doc>
		</fromQuat>
		<toQuat public="1" get="inline" set="null" line="598">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns a quaternion which represents this matrix.
	 *
	 * This matrix must be a rotation matrix, that is, must be orthogonalized and have determinant 1.</haxe_doc>
		</toQuat>
		<fromEulerXyz public="1" get="inline" set="null" line="606">
			<f a="eulerAngles">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix to the rotation matrix represented by Euler angles `eulerAngles`, and returns `this`.
	 * Rotation order is first X-axis, then rotated Y-axis, finally rotated Z-axis.</haxe_doc>
		</fromEulerXyz>
		<toEulerXyz public="1" get="inline" set="null" line="625">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns a vector `(angleX, angleY, angleZ)` represents the Euler angles of this matrix.
	 * Rotation order is first X-axis, then rotated Y-axis, finally rotated Z-axis.
	 * Note that `angleX`, `angleY`, and `angleZ` are in range of -PI to PI, -PI/2 to PI/2, and -PI to PI respectively.</haxe_doc>
		</toEulerXyz>
		<getRow public="1" get="inline" set="null" line="694">
			<f a="index">
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the `index`th row vector of the matrix.
	 *
	 * If `index` is less than `0` or greater than `2`, `null` will be returned.</haxe_doc>
		</getRow>
		<getCol public="1" get="inline" set="null" line="708">
			<f a="index">
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the `index`th column vector of the matrix.
	 *
	 * If `index` is less than `0` or greater than `2`, `null` will be returned.</haxe_doc>
		</getCol>
		<getRowTo public="1" get="inline" set="null" line="722">
			<f a="index:dst">
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `dst` to the `index`th row vector of the matrix.
	 *
	 * If `index` is less than `0` or greater than `2`, `dst` will be set to the zero vector.</haxe_doc>
		</getRowTo>
		<getColTo public="1" get="inline" set="null" line="734">
			<f a="index:dst">
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `dst` to the `index`th column vector of the matrix.
	 *
	 * If `index` is less than `0` or greater than `2`, `dst` will be set to the zero vector.</haxe_doc>
		</getColTo>
		<fromRows public="1" get="inline" set="null" line="744">
			<f a="row0:row1:row2">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix by row vectors and returns `this`.</haxe_doc>
		</fromRows>
		<fromCols public="1" get="inline" set="null" line="755">
			<f a="col0:col1:col2">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Mat3"/>
			</f>
			<haxe_doc>* Sets this matrix by column vectors and returns `this`.</haxe_doc>
		</fromCols>
		<toString public="1" set="method" line="766">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the string representation of the matrix.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="71">
			<f a="?e00:?e01:?e02:?e10:?e11:?e12:?e20:?e21:?e22" v="1:0:0:0:1:0:0:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ e22 : 1, e21 : 0, e20 : 0, e12 : 0, e11 : 1, e10 : 0, e02 : 0, e01 : 0, e00 : 1 }</e></m></meta>
			<haxe_doc>* Creates a new matrix. The matrix is identity by default.</haxe_doc>
		</new>
		<haxe_doc>* 3x3 Matrix class.
 *
 * Note that columns and rows are 0-indexed.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.common.Mat4" params="" file="src/oimo/common/Mat4.hx">
		<numCreations public="1" expr="0" line="13" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of instance creation.</haxe_doc>
		</numCreations>
		<e00 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 0.</haxe_doc>
		</e00>
		<e01 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 1.</haxe_doc>
		</e01>
		<e02 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 2.</haxe_doc>
		</e02>
		<e03 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 0 column 3.</haxe_doc>
		</e03>
		<e10 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 0.</haxe_doc>
		</e10>
		<e11 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 1.</haxe_doc>
		</e11>
		<e12 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 2.</haxe_doc>
		</e12>
		<e13 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 1 column 3.</haxe_doc>
		</e13>
		<e20 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 0.</haxe_doc>
		</e20>
		<e21 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 1.</haxe_doc>
		</e21>
		<e22 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 2.</haxe_doc>
		</e22>
		<e23 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 2 column 3.</haxe_doc>
		</e23>
		<e30 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 3 column 0.</haxe_doc>
		</e30>
		<e31 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 3 column 1.</haxe_doc>
		</e31>
		<e32 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 3 column 2.</haxe_doc>
		</e32>
		<e33 public="1">
			<x path="Float"/>
			<haxe_doc>* The element at row 3 column 3.</haxe_doc>
		</e33>
		<init public="1" get="inline" set="null" line="174">
			<f a="e00:e01:e02:e03:e10:e11:e12:e13:e20:e21:e22:e23:e30:e31:e32:e33">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets all elements at once and returns `this`.</haxe_doc>
		</init>
		<identity public="1" get="inline" set="null" line="197">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Sets this matrix to identity matrix and returns `this`.</haxe_doc>
		</identity>
		<add public="1" get="inline" set="null" line="210">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` + `m`</haxe_doc>
		</add>
		<sub public="1" get="inline" set="null" line="222">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` - `m`</haxe_doc>
		</sub>
		<scale public="1" get="inline" set="null" line="234">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` * `s`</haxe_doc>
		</scale>
		<mul public="1" get="inline" set="null" line="246">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` * `m`</haxe_doc>
		</mul>
		<addEq public="1" get="inline" set="null" line="270">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` + `m` and returns `this`.</haxe_doc>
		</addEq>
		<subEq public="1" get="inline" set="null" line="282">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` - `m` and returns `this`.</haxe_doc>
		</subEq>
		<scaleEq public="1" get="inline" set="null" line="294">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * `s` and returns `this`.</haxe_doc>
		</scaleEq>
		<mulEq public="1" get="inline" set="null" line="306">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * `m` and returns `this`.</haxe_doc>
		</mulEq>
		<prependScale public="1" get="inline" set="null" line="333">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns *scaling matrix* * `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependScale>
		<appendScale public="1" get="inline" set="null" line="348">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` * *scaling matrix*.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendScale>
		<prependRotation public="1" get="inline" set="null" line="363">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns *rotation matrix* * `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</prependRotation>
		<appendRotation public="1" get="inline" set="null" line="399">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` * *rotation matrix*.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</appendRotation>
		<prependTranslation public="1" get="inline" set="null" line="438">
			<f a="tx:ty:tz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns *translation matrix* * `this`.
	 *
	 * Where *translation matrix* is a matrix which translates `sx`, `sy` and `sz` along
	 * the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependTranslation>
		<appendTranslation public="1" get="inline" set="null" line="453">
			<f a="tx:ty:tz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Returns `this` * *translation matrix*.
	 *
	 * Where *translation matrix* is a matrix which translates `sx`, `sy` and `sz` along
	 * the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendTranslation>
		<prependScaleEq public="1" get="inline" set="null" line="468">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *scaling matrix* * `this`, and returns `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependScaleEq>
		<appendScaleEq public="1" get="inline" set="null" line="483">
			<f a="sx:sy:sz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * *scaling matrix*, and returns `this`.
	 *
	 * Where *scaling matrix* is a matrix which scales `sx` times, `sy` times and
	 * `sz` times along the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendScaleEq>
		<prependRotationEq public="1" get="inline" set="null" line="498">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *rotation matrix* * `this`, and returns `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</prependRotationEq>
		<appendRotationEq public="1" get="inline" set="null" line="525">
			<f a="rad:axisX:axisY:axisZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * *rotation matrix*, and returns `this`.
	 *
	 * Where *rotation matrix* is a matrix which rotates `rad` in radians around the **normalized**
	 * vector (`axisX`, `axisY`, `axisZ`).</haxe_doc>
		</appendRotationEq>
		<prependTranslationEq public="1" get="inline" set="null" line="552">
			<f a="tx:ty:tz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *translation matrix* * `this`, and returns `this`.
	 *
	 * Where *translation matrix* is a matrix which translates `sx`, `sy` and `sz` along
	 * the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</prependTranslationEq>
		<appendTranslationEq public="1" get="inline" set="null" line="567">
			<f a="tx:ty:tz">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to `this` * *translation matrix*, and returns `this`.
	 *
	 * Where *translation matrix* is a matrix which translates `sx`, `sy` and `sz` along
	 * the x-axis, y-axis and z-axis respectively.</haxe_doc>
		</appendTranslationEq>
		<transpose public="1" get="inline" set="null" line="579">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Returns the transposed matrix.</haxe_doc>
		</transpose>
		<transposeEq public="1" get="inline" set="null" line="591">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Sets this matrix to the transposed matrix and returns `this`.</haxe_doc>
		</transposeEq>
		<determinant public="1" get="inline" set="null" line="603">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the determinant.</haxe_doc>
		</determinant>
		<trace public="1" get="inline" set="null" line="621">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the trace.</haxe_doc>
		</trace>
		<inverse public="1" get="inline" set="null" line="630">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Returns the inverse matrix.
	 *
	 * If the determinant is zero, zero matrix is returned.</haxe_doc>
		</inverse>
		<inverseEq public="1" get="inline" set="null" line="674">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Sets this matrix to the inverse matrix and returns `this`.
	 *
	 * If the determinant is zero, this matrix is set to zero matrix.</haxe_doc>
		</inverseEq>
		<lookAt public="1" get="inline" set="null" line="720">
			<f a="eyeX:eyeY:eyeZ:atX:atY:atZ:upX:upY:upZ">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *view matrix* and returns `this`.
	 *
	 * Where *view matrix* is a matrix which represents the viewing transformation with
	 * eyes at (`eyeX`, `eyeY`, `eyeZ`), fixation point at (`atX`, `atY`, `atZ`), and
	 * up vector (`upX`, `upY`, `upZ`).</haxe_doc>
		</lookAt>
		<perspective public="1" get="inline" set="null" line="764">
			<f a="fovY:aspect:near:far">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *perspecive projection matrix* and returns `this`.
	 *
	 * Where *perspecive projection matrix* is a matrix which represents the perspective
	 * projection transformation with field of view in the y direction `fovY` in radians,
	 * aspect ratio `aspect`, and z-value of near and far clipping plane `near`, `far`.</haxe_doc>
		</perspective>
		<ortho public="1" get="inline" set="null" line="793">
			<f a="width:height:near:far">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to *orthogonal projection matrix* and returns `this`.
	 *
	 * Where *orthogonal projection matrix* is a matrix which represents the orthogonal
	 * projection transformation with screen width and height `width`, `height`, and
	 * z-value of near and far clipping plane `near`, `far`.</haxe_doc>
		</ortho>
		<toArray public="1" get="inline" set="null" line="820">
			<f a="?columnMajor" v="false">
				<x path="Bool"/>
				<c path="Array"><x path="Float"/></c>
			</f>
			<meta><m n=":value"><e>{ columnMajor : false }</e></m></meta>
			<haxe_doc>* Returns an array of the elements of this matrix.
	 *
	 * If `columnMajor` is true, the array is arranged in column-major order.
	 * Otherwise, the array is arranged in row-major order.</haxe_doc>
		</toArray>
		<copyFrom public="1" get="inline" set="null" line="841">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Copies values from `m` and returns `this`.</haxe_doc>
		</copyFrom>
		<fromMat3 public="1" get="inline" set="null" line="866">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to the extension of `m` and returns `this`.
	 *
	 * `this.e33` is set to `1` and other components don't exist in `m` are set to `0`.</haxe_doc>
		</fromMat3>
		<fromTransform public="1" get="inline" set="null" line="878">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Mat4"/>
			</f>
			<haxe_doc>* Sets this matrix to the representation of `transform` and returns `this`.</haxe_doc>
		</fromTransform>
		<clone public="1" get="inline" set="null" line="886">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Returns a clone of the matrix.</haxe_doc>
		</clone>
		<toString public="1" set="method" line="898">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the string representation of the matrix.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="103">
			<f a="?e00:?e01:?e02:?e03:?e10:?e11:?e12:?e13:?e20:?e21:?e22:?e23:?e30:?e31:?e32:?e33" v="1:0:0:0:0:1:0:0:0:0:1:0:0:0:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ e33 : 1, e32 : 0, e31 : 0, e30 : 0, e23 : 0, e22 : 1, e21 : 0, e20 : 0, e13 : 0, e12 : 0, e11 : 1, e10 : 0, e03 : 0, e02 : 0, e01 : 0, e00 : 1 }</e></m></meta>
			<haxe_doc>* Creates a new matrix. The matrix is identity by default.</haxe_doc>
		</new>
		<haxe_doc>* 4x4 Matrix class.
 *
 * Note that columns and rows are 0-indexed.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.common.MathUtil" params="" file="src/oimo/common/MathUtil.hx">
		<POSITIVE_INFINITY public="1" get="inline" set="null" expr="1e65536" line="11" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>1e65536</e></m></meta>
			<haxe_doc>* Positive infinity.</haxe_doc>
		</POSITIVE_INFINITY>
		<NEGATIVE_INFINITY public="1" get="inline" set="null" expr="-1e65536" line="16" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>-1e65536</e></m></meta>
			<haxe_doc>* Negative infinity.</haxe_doc>
		</NEGATIVE_INFINITY>
		<PI public="1" get="inline" set="null" expr="3.14159265358979" line="21" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>3.14159265358979</e></m></meta>
			<haxe_doc>* The ratio of the circumference of a circle to its diameter.</haxe_doc>
		</PI>
		<TWO_PI public="1" get="inline" set="null" expr="PI * 2" line="26" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>PI * 2</e></m></meta>
			<haxe_doc>* Shorthand for `PI * 2`.</haxe_doc>
		</TWO_PI>
		<HALF_PI public="1" get="inline" set="null" expr="PI / 2" line="31" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>PI / 2</e></m></meta>
			<haxe_doc>* Shorthand for `PI / 2`.</haxe_doc>
		</HALF_PI>
		<TO_RADIANS public="1" get="inline" set="null" expr="PI / 180" line="36" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>PI / 180</e></m></meta>
			<haxe_doc>* Shorthand for `PI / 180`.</haxe_doc>
		</TO_RADIANS>
		<TO_DEGREES public="1" get="inline" set="null" expr="180 / PI" line="41" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>180 / PI</e></m></meta>
			<haxe_doc>* Shorthand for `180 / PI`.</haxe_doc>
		</TO_DEGREES>
		<abs public="1" get="inline" set="null" line="46" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the absolute value of `x`.</haxe_doc>
		</abs>
		<sin public="1" get="inline" set="null" line="53" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.sin(x)`.</haxe_doc>
		</sin>
		<cos public="1" get="inline" set="null" line="60" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.cos(x)`.</haxe_doc>
		</cos>
		<tan public="1" get="inline" set="null" line="67" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.tan(x)`.</haxe_doc>
		</tan>
		<asin public="1" get="inline" set="null" line="74" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.asin(x)`.</haxe_doc>
		</asin>
		<acos public="1" get="inline" set="null" line="81" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.acos(x)`.</haxe_doc>
		</acos>
		<atan public="1" get="inline" set="null" line="88" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.atan(x)`.</haxe_doc>
		</atan>
		<safeAsin public="1" get="inline" set="null" line="96" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.asin(clamp(-1, x, 1))`.
	 * This never returns `NaN` as long as `x` is not `NaN`.</haxe_doc>
		</safeAsin>
		<safeAcos public="1" get="inline" set="null" line="106" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.acos(clamp(-1, x, 1))`.
	 * This never returns `NaN` as long as `x` is not `NaN`.</haxe_doc>
		</safeAcos>
		<atan2 public="1" get="inline" set="null" line="115" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.atan2(y, x)`</haxe_doc>
		</atan2>
		<sqrt public="1" get="inline" set="null" line="122" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns `Math.sqrt(x)`.</haxe_doc>
		</sqrt>
		<clamp public="1" get="inline" set="null" line="129" static="1">
			<f a="x:min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns a clamped value of `x` from `min` to `max`.</haxe_doc>
		</clamp>
		<rand public="1" get="inline" set="null" line="136" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns `Math.random()`.</haxe_doc>
		</rand>
		<randIn public="1" get="inline" set="null" line="143" static="1">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns a random value from `min` inclusive to `max` exclusive.</haxe_doc>
		</randIn>
		<randVec3In public="1" get="inline" set="null" line="150" static="1">
			<f a="min:max">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns a random `Vec3` from `(min, min, min)` inclusive to `(max, max, max)` exclusive.</haxe_doc>
		</randVec3In>
		<randVec3 public="1" get="inline" set="null" line="157" static="1">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns a random `Vec3` from `(-1.0, -1.0, -1.0)` inclusive to `(1.0, 1.0, 1.0)` exclusive.</haxe_doc>
		</randVec3>
		<haxe_doc>* This class provides mathematical operations for internal purposes.</haxe_doc>
	</class>
	<class path="oimo.common.Pool" params="" file="src/oimo/common/Pool.hx">
		<stackVec3><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></stackVec3>
		<sizeVec3><x path="Int"/></sizeVec3>
		<stackMat3><x path="haxe.ds.Vector"><c path="oimo.common.Mat3"/></x></stackMat3>
		<sizeMat3><x path="Int"/></sizeMat3>
		<stackMat4><x path="haxe.ds.Vector"><c path="oimo.common.Mat4"/></x></stackMat4>
		<sizeMat4><x path="Int"/></sizeMat4>
		<stackQuat><x path="haxe.ds.Vector"><c path="oimo.common.Quat"/></x></stackQuat>
		<sizeQuat><x path="Int"/></sizeQuat>
		<vec3 public="1" get="inline" set="null" line="40">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns a `Vec3` object. If an unused object of `Vec3` is pooled, this does
	 * not create a new instance.</haxe_doc>
		</vec3>
		<mat3 public="1" get="inline" set="null" line="48">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns a `Mat3` object. If an unused object of `Mat3` is pooled, this does
	 * not create a new instance.</haxe_doc>
		</mat3>
		<mat4 public="1" get="inline" set="null" line="56">
			<f a=""><c path="oimo.common.Mat4"/></f>
			<haxe_doc>* Returns a `Mat4` object. If an unused object of `Vec3` is pooled, this does
	 * not create a new instance.</haxe_doc>
		</mat4>
		<quat public="1" get="inline" set="null" line="64">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns a `Quat` object. If an unused object of `Quat` is pooled, this does
	 * not create a new instance.</haxe_doc>
		</quat>
		<dispose public="1" get="inline" set="null" line="71">
			<f a="?vec3:?mat3:?mat4:?quat">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat4"/>
				<c path="oimo.common.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disposes an object got from `Pool.vec3`, `Pool.mat3`, `Pool.mat4`, or `Pool.quat`.</haxe_doc>
		</dispose>
		<disposeVec3 public="1" get="inline" set="null" line="89">
			<f a="v">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disposes an `Vec3` object got from `Pool.vec3`.</haxe_doc>
		</disposeVec3>
		<disposeMat3 public="1" get="inline" set="null" line="97">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disposes an `Mat3` object got from `Pool.mat3`.</haxe_doc>
		</disposeMat3>
		<disposeMat4 public="1" get="inline" set="null" line="105">
			<f a="m">
				<c path="oimo.common.Mat4"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disposes an `Mat4` object got from `Pool.mat4`.</haxe_doc>
		</disposeMat4>
		<disposeQuat public="1" get="inline" set="null" line="113">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Disposes an `Quat` object got from `Pool.quat`.</haxe_doc>
		</disposeQuat>
		<new public="1" set="method" line="25">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* The object pool system of `Vec3`, `Mat3`, `Mat4`, and `Quat`.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.common.Quat" params="" file="src/oimo/common/Quat.hx">
		<numCreations public="1" expr="0" line="14" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
			<haxe_doc>* The number of instance creation.</haxe_doc>
		</numCreations>
		<x public="1">
			<x path="Float"/>
			<haxe_doc>* The x-value of the imaginary part of the quaternion.</haxe_doc>
		</x>
		<y public="1">
			<x path="Float"/>
			<haxe_doc>* The y-value of the imaginary part of the quaternion.</haxe_doc>
		</y>
		<z public="1">
			<x path="Float"/>
			<haxe_doc>* The z-value of the imaginary part of the quaternion.</haxe_doc>
		</z>
		<w public="1">
			<x path="Float"/>
			<haxe_doc>* The real part of the quaternion.</haxe_doc>
		</w>
		<identity public="1" get="inline" set="null" line="62">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Sets the quaternion to identity quaternion and returns `this`.</haxe_doc>
		</identity>
		<init public="1" get="inline" set="null" line="69">
			<f a="x:y:z:w">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets all values at once and returns `this`.</haxe_doc>
		</init>
		<add public="1" get="inline" set="null" line="80">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Returns `this` + `v`.</haxe_doc>
		</add>
		<sub public="1" get="inline" set="null" line="87">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Returns `this` - `v`.</haxe_doc>
		</sub>
		<scale public="1" get="inline" set="null" line="94">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Returns `this` * `s`.</haxe_doc>
		</scale>
		<addEq public="1" get="inline" set="null" line="101">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets this quaternion to `this` + `v` and returns `this`.</haxe_doc>
		</addEq>
		<subEq public="1" get="inline" set="null" line="108">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets this quaternion to `this` - `v` and returns `this`.</haxe_doc>
		</subEq>
		<scaleEq public="1" get="inline" set="null" line="115">
			<f a="s">
				<x path="Float"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets this quaternion to `this` * `s` and returns `this`.</haxe_doc>
		</scaleEq>
		<length public="1" get="inline" set="null" line="122">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the length of the quaternion.</haxe_doc>
		</length>
		<lengthSq public="1" get="inline" set="null" line="129">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the squared length of the quaternion.</haxe_doc>
		</lengthSq>
		<dot public="1" get="inline" set="null" line="136">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns the dot product of `this` and `q`.</haxe_doc>
		</dot>
		<normalized public="1" get="inline" set="null" line="145">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns the normalized quaternion.
	 *
	 * If the length is zero, zero quaterinon is returned.</haxe_doc>
		</normalized>
		<normalize public="1" get="inline" set="null" line="156">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Sets this quaternion to the normalized quaternion and returns `this`.
	 *
	 * If the length is zero, this quaternion is set to zero quaternion.</haxe_doc>
		</normalize>
		<setArc public="1" set="method" line="166">
			<f a="v1:v2">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets this quaternion to the quaternion representing the shortest arc
	 * rotation from `v1` to `v2`, and return `this`.</haxe_doc>
		</setArc>
		<slerp public="1" set="method" line="222">
			<f a="q:t">
				<c path="oimo.common.Quat"/>
				<x path="Float"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Returns the spherical linear interpolation between two quaternions `this` and `q` with interpolation paraeter `t`.
	 * Both quaternions `this` and `q` must be normalized.</haxe_doc>
		</slerp>
		<copyFrom public="1" get="inline" set="null" line="267">
			<f a="q">
				<c path="oimo.common.Quat"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Copies values from `q` and returns `this`.</haxe_doc>
		</copyFrom>
		<clone public="1" get="inline" set="null" line="278">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns a clone of the quaternion.</haxe_doc>
		</clone>
		<fromMat3 public="1" get="inline" set="null" line="287">
			<f a="m">
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Quat"/>
			</f>
			<haxe_doc>* Sets this quaternion to the representation of the matrix `m`, and returns `this`.
	 *
	 * The matrix `m` must be a rotation matrix, that is, must be orthogonalized and have determinant 1.</haxe_doc>
		</fromMat3>
		<toMat3 public="1" get="inline" set="null" line="333">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns a rotation matrix which represents this quaternion.</haxe_doc>
		</toMat3>
		<toString public="1" get="inline" set="null" line="340">
			<f a=""><c path="String"/></f>
			<haxe_doc>* Returns the string representation of the quaternion.</haxe_doc>
		</toString>
		<new public="1" get="inline" set="null" line="39">
			<f a="?x:?y:?z:?w" v="0:0:0:1">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ w : 1, z : 0, y : 0, x : 0 }</e></m></meta>
			<haxe_doc>* Creates a new quaternion. The quaternion is identity by default.</haxe_doc>
		</new>
		<haxe_doc>* Quaternion class.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.Contact" params="" file="src/oimo/dynamics/Contact.hx">
		<_next public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_prev public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_link1 public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_link1>
		<_link2 public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_link2>
		<_s1 public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_s1>
		<_s2 public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_s2>
		<_b1 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b1>
		<_b2 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b2>
		<_detector public="1">
			<c path="oimo.collision.narrowphase.detector.Detector"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_detector>
		<_cachedDetectorData public="1">
			<c path="oimo.collision.narrowphase.detector.CachedDetectorData"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_cachedDetectorData>
		<_detectorResult public="1">
			<c path="oimo.collision.narrowphase.DetectorResult"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_detectorResult>
		<_latest public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_latest>
		<_shouldBeSkipped public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_shouldBeSkipped>
		<_manifold public="1">
			<c path="oimo.dynamics.constraint.contact.Manifold"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_manifold>
		<_updater public="1">
			<c path="oimo.dynamics.constraint.contact.ManifoldUpdater"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updater>
		<_contactConstraint public="1">
			<c path="oimo.dynamics.constraint.contact.ContactConstraint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactConstraint>
		<_touching public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_touching>
		<_updateManifold public="1" set="method" line="171">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateManifold>
		<_postSolve public="1" set="method" line="219">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_postSolve>
		<getShape1 public="1" get="inline" set="null" line="228">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the first shape of the contact.</haxe_doc>
		</getShape1>
		<getShape2 public="1" get="inline" set="null" line="235">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the second shape of the contact.</haxe_doc>
		</getShape2>
		<isTouching public="1" get="inline" set="null" line="242">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether the shapes are touching.</haxe_doc>
		</isTouching>
		<getManifold public="1" get="inline" set="null" line="249">
			<f a=""><c path="oimo.dynamics.constraint.contact.Manifold"/></f>
			<haxe_doc>* Returns the contact manifold.</haxe_doc>
		</getManifold>
		<getContactConstraint public="1" get="inline" set="null" line="256">
			<f a=""><c path="oimo.dynamics.constraint.contact.ContactConstraint"/></f>
			<haxe_doc>* Returns the contact constraint.</haxe_doc>
		</getContactConstraint>
		<getPrev public="1" get="inline" set="null" line="265">
			<f a=""><c path="oimo.dynamics.Contact"/></f>
			<haxe_doc>* Returns the previous contact in the world.
	 *
	 * If the previous contact does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" get="inline" set="null" line="274">
			<f a=""><c path="oimo.dynamics.Contact"/></f>
			<haxe_doc>* Returns the next contact in the world.
	 *
	 * If the next contact does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="46">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A contact is a cached pair of overlapping shapes in the physics world. contacts
 * are created by `ContactManager` when two AABBs of shapes begin overlapping.
 *
 * As AABBs are larger than its shapes, shapes of a contact don't always
 * touching or colliding though their AABBs are overlapping.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.ContactLink" params="" file="src/oimo/dynamics/ContactLink.hx">
		<_prev public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_next public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_contact public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contact>
		<_other public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_other>
		<getContact public="1" get="inline" set="null" line="28">
			<f a=""><c path="oimo.dynamics.Contact"/></f>
			<haxe_doc>* Returns the contact of the link.</haxe_doc>
		</getContact>
		<getOther public="1" get="inline" set="null" line="36">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the other rigid body of the link. This provides a quick access from a
	 * rigid body to the other one of the contact.</haxe_doc>
		</getOther>
		<getPrev public="1" get="inline" set="null" line="45">
			<f a=""><c path="oimo.dynamics.ContactLink"/></f>
			<haxe_doc>* Returns the previous contact link in the rigid body.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" get="inline" set="null" line="54">
			<f a=""><c path="oimo.dynamics.ContactLink"/></f>
			<haxe_doc>* Returns the next contact link in the rigid body.
	 *
	 * If the next one does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="18">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A contact link is used to build a constraint graph for clustering rigid bodies.
 * In a constraint graph, rigid bodies are nodes and constraints are edges.
 * See also `JointLink`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.ContactManager" params="" file="src/oimo/dynamics/ContactManager.hx">
		<_numContacts public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numContacts>
		<_contactList public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactList>
		<_contactListLast public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactListLast>
		<_contactPool public="1">
			<c path="oimo.dynamics.Contact"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactPool>
		<_broadPhase public="1">
			<c path="oimo.collision.broadphase.BroadPhase"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_broadPhase>
		<_collisionMatrix public="1">
			<c path="oimo.collision.narrowphase.CollisionMatrix"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_collisionMatrix>
		<createContacts set="method" line="33"><f a=""><x path="Void"/></f></createContacts>
		<destroyOutdatedContacts set="method" line="90"><f a=""><x path="Void"/></f></destroyOutdatedContacts>
		<shouldCollide set="method" line="136"><f a="s1:s2">
	<c path="oimo.dynamics.rigidbody.Shape"/>
	<c path="oimo.dynamics.rigidbody.Shape"/>
	<x path="Bool"/>
</f></shouldCollide>
		<_updateContacts public="1" set="method" line="180">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateContacts>
		<_postSolve public="1" set="method" line="187">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_postSolve>
		<getNumContacts public="1" get="inline" set="null" line="220">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the contacts in the world.</haxe_doc>
		</getNumContacts>
		<getContactList public="1" get="inline" set="null" line="227">
			<f a=""><c path="oimo.dynamics.Contact"/></f>
			<haxe_doc>* Returns the linked list of the contacts in the world.</haxe_doc>
		</getContactList>
		<new public="1" set="method" line="25">
			<f a="broadPhase">
				<c path="oimo.collision.broadphase.BroadPhase"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The manager of the contacts in the physics world. A contact of two
 * shapes is created when the AABBs of them begin overlapping, and
 * is destroyed when they end overlapping.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.Island" params="" file="src/oimo/dynamics/Island.hx">
		<gravityX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</gravityX>
		<gravityY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</gravityY>
		<gravityZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</gravityZ>
		<numRigidBodies><x path="Int"/></numRigidBodies>
		<rigidBodies><x path="haxe.ds.Vector"><c path="oimo.dynamics.rigidbody.RigidBody"/></x></rigidBodies>
		<numSolvers><x path="Int"/></numSolvers>
		<solvers><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.ConstraintSolver"/></x></solvers>
		<numSolversSi><x path="Int"/></numSolversSi>
		<solversSi><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.ConstraintSolver"/></x></solversSi>
		<numSolversNgs><x path="Int"/></numSolversNgs>
		<solversNgs><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.ConstraintSolver"/></x></solversNgs>
		<_clear public="1" set="method" line="67">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_clear>
		<_addRigidBody public="1" set="method" line="78">
			<f a="rigidBody">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addRigidBody>
		<_addConstraintSolver public="1" set="method" line="86">
			<f a="solver:positionCorrection">
				<c path="oimo.dynamics.constraint.ConstraintSolver"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addConstraintSolver>
		<_stepSingleRigidBody public="1" set="method" line="102">
			<f a="timeStep:rb">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_stepSingleRigidBody>
		<_step public="1" set="method" line="148">
			<f a="timeStep:numVelocityIterations:numPositionIterations">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_step>
		<new public="1" set="method" line="33"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Simulation island.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.TimeStep" params="" file="src/oimo/dynamics/TimeStep.hx">
		<dt public="1">
			<x path="Float"/>
			<haxe_doc>* The time step of simulation.</haxe_doc>
		</dt>
		<invDt public="1">
			<x path="Float"/>
			<haxe_doc>* The inverse time step of simulation, equivalent to simulation FPS.</haxe_doc>
		</invDt>
		<dtRatio public="1">
			<x path="Float"/>
			<haxe_doc>* The ratio of time steps. Defined by current time step divided by previous
	 * time step.</haxe_doc>
		</dtRatio>
		<new public="1" set="method" line="24">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* Information of time-step sizes of the simulation.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.World" params="" file="src/oimo/dynamics/World.hx">
		<_rigidBodyList public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rigidBodyList>
		<_rigidBodyListLast public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rigidBodyListLast>
		<_jointList public="1">
			<c path="oimo.dynamics.constraint.joint.Joint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_jointList>
		<_jointListLast public="1">
			<c path="oimo.dynamics.constraint.joint.Joint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_jointListLast>
		<_broadPhase public="1">
			<c path="oimo.collision.broadphase.BroadPhase"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_broadPhase>
		<_contactManager public="1">
			<c path="oimo.dynamics.ContactManager"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactManager>
		<_numRigidBodies public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numRigidBodies>
		<_numJoints public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numJoints>
		<_numShapes public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numShapes>
		<_numIslands public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numIslands>
		<_numVelocityIterations public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numVelocityIterations>
		<_numPositionIterations public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numPositionIterations>
		<_gravity public="1">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_gravity>
		<_timeStep>
			<c path="oimo.dynamics.TimeStep"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_timeStep>
		<_island>
			<c path="oimo.dynamics.Island"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_island>
		<_rigidBodyStack>
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.rigidbody.RigidBody"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rigidBodyStack>
		<_solversInIslands>
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.ConstraintSolver"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_solversInIslands>
		<_numSolversInIslands>
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numSolversInIslands>
		<_debugDraw>
			<c path="oimo.dynamics.common.DebugDraw"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_debugDraw>
		<_rayCastWrapper>
			<c path="oimo.dynamics._World.RayCastWrapper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rayCastWrapper>
		<_convexCastWrapper>
			<c path="oimo.dynamics._World.ConvexCastWrapper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_convexCastWrapper>
		<_aabbTestWrapper>
			<c path="oimo.dynamics._World.AabbTestWrapper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabbTestWrapper>
		<_pool>
			<c path="oimo.common.Pool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pool>
		<_shapeIdCount>
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_shapeIdCount>
		<_updateContacts set="method" line="106">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateContacts>
		<_solveIslands set="method" line="117">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_solveIslands>
		<buildIsland set="method" line="185"><f a="base">
	<c path="oimo.dynamics.rigidbody.RigidBody"/>
	<x path="Void"/>
</f></buildIsland>
		<_drawBvh set="method" line="279">
			<f a="d:tree">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.collision.broadphase.bvh.BvhTree"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawBvh>
		<_drawBvhNode set="method" line="285">
			<f a="d:node:level:color">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.collision.broadphase.bvh.BvhNode"/>
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawBvhNode>
		<_drawRigidBodies set="method" line="300">
			<f a="d">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawRigidBodies>
		<_drawConstraints set="method" line="456">
			<f a="d">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawConstraints>
		<_drawRotationalLimit set="method" line="679">
			<f a="d:center:ex:ey:needle:radius:min:max:color">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawRotationalLimit>
		<_drawTranslationalLimit set="method" line="692">
			<f a="d:center:ex:min:max:color">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawTranslationalLimit>
		<_drawTranslationalLimit3D set="method" line="702">
			<f a="d:center:ex:ey:ez:xlm:ylm:zlm:color">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
				<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
				<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawTranslationalLimit3D>
		<_drawEllipseOnSphere set="method" line="744">
			<f a="d:center:normal:x:y:radiansX:radiansY:radius:color">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_drawEllipseOnSphere>
		<step public="1" set="method" line="789">
			<f a="timeStep">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Advances the simulation by the time step `timeStep`.</haxe_doc>
		</step>
		<addRigidBody public="1" set="method" line="805">
			<f a="rigidBody">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds the rigid body `rigidBody` to the simulation world.</haxe_doc>
		</addRigidBody>
		<removeRigidBody public="1" set="method" line="826">
			<f a="rigidBody">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the rigid body `rigidBody` from the simulation world.</haxe_doc>
		</removeRigidBody>
		<addJoint public="1" set="method" line="846">
			<f a="joint">
				<c path="oimo.dynamics.constraint.joint.Joint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds the joint `joint` to the simulation world.</haxe_doc>
		</addJoint>
		<removeJoint public="1" set="method" line="862">
			<f a="joint">
				<c path="oimo.dynamics.constraint.joint.Joint"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the joint `joint` from the simulation world.</haxe_doc>
		</removeJoint>
		<setDebugDraw public="1" get="inline" set="null" line="876">
			<f a="debugDraw">
				<c path="oimo.dynamics.common.DebugDraw"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the debug draw interface to `debugDraw`. Call `World.debugDraw` to draw the simulation world.</haxe_doc>
		</setDebugDraw>
		<getDebugDraw public="1" get="inline" set="null" line="883">
			<f a=""><c path="oimo.dynamics.common.DebugDraw"/></f>
			<haxe_doc>* Returns the debug draw interface.</haxe_doc>
		</getDebugDraw>
		<debugDraw public="1" set="method" line="890">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Draws the simulation world for debugging. Call `World.setDebugDraw` to set the debug draw interface.</haxe_doc>
		</debugDraw>
		<rayCast public="1" set="method" line="905">
			<f a="begin:end:callback">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.callback.RayCastCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs a ray casting. `callback.process` is called for all shapes the ray
	 * from `begin` to `end` hits.</haxe_doc>
		</rayCast>
		<convexCast public="1" set="method" line="918">
			<f a="convex:begin:translation:callback">
				<c path="oimo.collision.geometry.ConvexGeometry"/>
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.callback.RayCastCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs a convex casting. `callback.process` is called for all shapes the convex geometry
	 * `convex` hits. The convex geometry translates by `translation` starting from the beginning
	 * transform `begin`.</haxe_doc>
		</convexCast>
		<aabbTest public="1" set="method" line="931">
			<f a="aabb:callback">
				<c path="oimo.collision.geometry.Aabb"/>
				<c path="oimo.dynamics.callback.AabbTestCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs an AABB query. `callback.process` is called for all shapes that their
	 * AABB and `aabb` intersect.</haxe_doc>
		</aabbTest>
		<getRigidBodyList public="1" get="inline" set="null" line="941">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the list of the rigid bodies added to the world.</haxe_doc>
		</getRigidBodyList>
		<getJointList public="1" get="inline" set="null" line="948">
			<f a=""><c path="oimo.dynamics.constraint.joint.Joint"/></f>
			<haxe_doc>* Returns the list of the joints added to the world.</haxe_doc>
		</getJointList>
		<getBroadPhase public="1" get="inline" set="null" line="955">
			<f a=""><c path="oimo.collision.broadphase.BroadPhase"/></f>
			<haxe_doc>* Returns the broad-phase collision detection algorithm.</haxe_doc>
		</getBroadPhase>
		<getContactManager public="1" get="inline" set="null" line="962">
			<f a=""><c path="oimo.dynamics.ContactManager"/></f>
			<haxe_doc>* Returns the contact manager.</haxe_doc>
		</getContactManager>
		<getNumRigidBodies public="1" get="inline" set="null" line="969">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the rigid bodies added to the world.</haxe_doc>
		</getNumRigidBodies>
		<getNumJoints public="1" get="inline" set="null" line="976">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the joints added to the world.</haxe_doc>
		</getNumJoints>
		<getNumShapes public="1" get="inline" set="null" line="983">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the shapes added to the world.</haxe_doc>
		</getNumShapes>
		<getNumIslands public="1" get="inline" set="null" line="990">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of simulation islands.</haxe_doc>
		</getNumIslands>
		<getNumVelocityIterations public="1" get="inline" set="null" line="997">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of velocity iterations of constraint solvers.</haxe_doc>
		</getNumVelocityIterations>
		<setNumVelocityIterations public="1" get="inline" set="null" line="1004">
			<f a="numVelocityIterations">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the number of velocity iterations of constraint solvers to `numVelocityIterations`.</haxe_doc>
		</setNumVelocityIterations>
		<getNumPositionIterations public="1" get="inline" set="null" line="1011">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of position iterations of constraint solvers.</haxe_doc>
		</getNumPositionIterations>
		<setNumPositionIterations public="1" get="inline" set="null" line="1018">
			<f a="numPositionIterations">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the number of position iterations of constraint solvers to `numPositionIterations`.</haxe_doc>
		</setNumPositionIterations>
		<getGravity public="1" get="inline" set="null" line="1025">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the gravitational acceleration of the simulation world.</haxe_doc>
		</getGravity>
		<setGravity public="1" get="inline" set="null" line="1032">
			<f a="gravity">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the gravitational acceleration of the simulation world to `gravity`.</haxe_doc>
		</setGravity>
		<new public="1" set="method" line="63">
			<f a="?broadPhaseType:?gravity" v="BroadPhaseType._BVH:null">
				<x path="Int"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ gravity : null, broadPhaseType : BroadPhaseType._BVH }</e></m></meta>
			<haxe_doc>* Creates a new physics world, with broad-phase collision detection algorithm `broadPhaseType` and
	 * gravitational acceleration `gravity`.</haxe_doc>
		</new>
		<haxe_doc>* The physics simulation world. This manages entire the dynamic simulation. You can add
 * rigid bodies and joints to the world to simulate them.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics._World.RayCastWrapper" params="" file="src/oimo/dynamics/World.hx" private="1" module="oimo.dynamics.World">
		<extends path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
		<callback public="1"><c path="oimo.dynamics.callback.RayCastCallback"/></callback>
		<begin public="1"><c path="oimo.common.Vec3"/></begin>
		<end public="1"><c path="oimo.common.Vec3"/></end>
		<rayCastHit><c path="oimo.collision.geometry.RayCastHit"/></rayCastHit>
		<process public="1" set="method" line="1055" override="1"><f a="proxy">
	<c path="oimo.collision.broadphase.Proxy"/>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="1046"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics._World.ConvexCastWrapper" params="" file="src/oimo/dynamics/World.hx" private="1" module="oimo.dynamics.World">
		<extends path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
		<callback public="1"><c path="oimo.dynamics.callback.RayCastCallback"/></callback>
		<begin public="1"><c path="oimo.common.Transform"/></begin>
		<translation public="1"><c path="oimo.common.Vec3"/></translation>
		<convex public="1"><c path="oimo.collision.geometry.ConvexGeometry"/></convex>
		<rayCastHit><c path="oimo.collision.geometry.RayCastHit"/></rayCastHit>
		<zero><c path="oimo.common.Vec3"/></zero>
		<process public="1" set="method" line="1085" override="1"><f a="proxy">
	<c path="oimo.collision.broadphase.Proxy"/>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="1074"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics._World.AabbTestWrapper" params="" file="src/oimo/dynamics/World.hx" private="1" module="oimo.dynamics.World">
		<extends path="oimo.collision.broadphase.BroadPhaseProxyCallback"/>
		<_callback public="1"><c path="oimo.dynamics.callback.AabbTestCallback"/></_callback>
		<_aabb public="1"><c path="oimo.collision.geometry.Aabb"/></_aabb>
		<process public="1" set="method" line="1109" override="1"><f a="proxy">
	<c path="oimo.collision.broadphase.Proxy"/>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="1102"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.callback.AabbTestCallback" params="" file="src/oimo/dynamics/callback/AabbTestCallback.hx">
		<process public="1" set="method" line="20">
			<f a="shape">
				<c path="oimo.dynamics.rigidbody.Shape"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called every time the world detects a shape `shape` that
	 * the query aabb intersects.</haxe_doc>
		</process>
		<new public="1" set="method" line="13">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A callback interface for aabb tests in a world.</haxe_doc>
		<meta><m n=":interface"/></meta>
	</class>
	<class path="oimo.dynamics.callback.ContactCallback" params="" file="src/oimo/dynamics/callback/ContactCallback.hx">
		<beginContact public="1" set="method" line="27">
			<f a="c">
				<c path="oimo.dynamics.Contact"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called when two shapes start touching each other. `c` is the contact of
	 * the two shapes.</haxe_doc>
		</beginContact>
		<preSolve public="1" set="method" line="34">
			<f a="c">
				<c path="oimo.dynamics.Contact"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called every frame **before** velocity solver iterations while two shapes
	 * are touching. `c` is the contact for the two shapes.</haxe_doc>
		</preSolve>
		<postSolve public="1" set="method" line="41">
			<f a="c">
				<c path="oimo.dynamics.Contact"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called every frame **after** velocity solver iterations while two shapes
	 * are touching. `c` is the contact for the two shapes.</haxe_doc>
		</postSolve>
		<endContact public="1" set="method" line="48">
			<f a="c">
				<c path="oimo.dynamics.Contact"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called when two shapes end touching each other. `c` is the contact of
	 * the two shapes.</haxe_doc>
		</endContact>
		<new public="1" set="method" line="20">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A callback class for contact events. Contact events between two shapes
 * will occur in following order:
 *
 * 1. `beginContact`
 * 1. `preSolve` (before velocity update)
 * 1. `postSolve` (after velocity update)
 * 1. (repeats 2. and 3. every frame while the shapes are touching)
 * 1. `endContact`</haxe_doc>
		<meta><m n=":interface"/></meta>
	</class>
	<class path="oimo.dynamics.callback.RayCastCallback" params="" file="src/oimo/dynamics/callback/RayCastCallback.hx">
		<process public="1" set="method" line="21">
			<f a="shape:hit">
				<c path="oimo.dynamics.rigidbody.Shape"/>
				<c path="oimo.collision.geometry.RayCastHit"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* This is called every time the world detects a shape `shape` that
	 * the ray intersects with the hit data `hit`.</haxe_doc>
		</process>
		<new public="1" set="method" line="14">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A callback class for ray casts in a world.</haxe_doc>
		<meta><m n=":interface"/></meta>
	</class>
	<class path="oimo.dynamics.callback.RayCastClosest" params="" file="src/oimo/dynamics/callback/RayCastClosest.hx">
		<extends path="oimo.dynamics.callback.RayCastCallback"/>
		<shape public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<haxe_doc>* The shape the ray hit.</haxe_doc>
		</shape>
		<position public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The position the ray hit at.</haxe_doc>
		</position>
		<normal public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The normal vector of the surface the ray hit.</haxe_doc>
		</normal>
		<fraction public="1">
			<x path="Float"/>
			<haxe_doc>* The ratio of the position the ray hit from the start point to the end point.</haxe_doc>
		</fraction>
		<hit public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the ray hit any shape in the world.</haxe_doc>
		</hit>
		<clear public="1" get="inline" set="null" line="50">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Clears the result data.</haxe_doc>
		</clear>
		<process public="1" set="method" line="58" override="1"><f a="shape:hit">
	<c path="oimo.dynamics.rigidbody.Shape"/>
	<c path="oimo.collision.geometry.RayCastHit"/>
	<x path="Void"/>
</f></process>
		<new public="1" set="method" line="40">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A ray cast callback implementation that keeps only the closest hit data.
 * This is reusable, but make sure to clear the old result by calling
 * `RayCastClosest.clear` if used once or more before.</haxe_doc>
	</class>
	<class path="oimo.dynamics.common.DebugDraw" params="" file="src/oimo/dynamics/common/DebugDraw.hx">
		<SPHERE_PHI_DIVISION get="inline" set="null" expr="8" line="90" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</SPHERE_PHI_DIVISION>
		<SPHERE_THETA_DIVISION get="inline" set="null" expr="4" line="91" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>4</e></m></meta>
		</SPHERE_THETA_DIVISION>
		<CIRCLE_THETA_DIVISION get="inline" set="null" expr="8" line="96" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>8</e></m></meta>
		</CIRCLE_THETA_DIVISION>
		<wireframe public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether the shapes are drawn in wireframe mode.</haxe_doc>
		</wireframe>
		<drawShapes public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the shapes.</haxe_doc>
		</drawShapes>
		<drawBvh public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the bounding volume hierarchy of the broad-phase collision
	 * detection. If `BvhBroadPhase` is not used, nothing will be drawn regardless
	 * of the value of this parameter.</haxe_doc>
		</drawBvh>
		<drawBvhMinLevel public="1">
			<x path="Int"/>
			<haxe_doc>* The minimum depth of the BVH to be drawn. If `DebugDrawer.drawBvh` is set to
	 * `false`, the entire BVH will not be drawn.</haxe_doc>
		</drawBvhMinLevel>
		<drawBvhMaxLevel public="1">
			<x path="Int"/>
			<haxe_doc>* The maximum depth of the BVH to be drawn. If `DebugDrawer.drawBvh` is set to
	 * `false`, the entire BVH will not be drawn.</haxe_doc>
		</drawBvhMaxLevel>
		<drawAabbs public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the AABBs.</haxe_doc>
		</drawAabbs>
		<drawBases public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the bases of the rigid bodies.</haxe_doc>
		</drawBases>
		<drawPairs public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the overlapping pairs of the AABBs.</haxe_doc>
		</drawPairs>
		<drawContacts public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the contacts.</haxe_doc>
		</drawContacts>
		<drawContactBases public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the bases (normals, tangents, and binormals) of the contacts.</haxe_doc>
		</drawContactBases>
		<drawJoints public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the joints.</haxe_doc>
		</drawJoints>
		<drawJointLimits public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to draw the limits of the joints.</haxe_doc>
		</drawJointLimits>
		<style public="1">
			<c path="oimo.dynamics.common.DebugDrawStyle"/>
			<haxe_doc>* The rendering style of the debug draw.</haxe_doc>
		</style>
		<p><c path="oimo.common.Pool"/></p>
		<sphereCoords><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></x></sphereCoords>
		<tmpSphereVerts><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></x></tmpSphereVerts>
		<tmpSphereNorms><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></x></tmpSphereNorms>
		<circleCoords><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></circleCoords>
		<circleCoordsShift><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></circleCoordsShift>
		<tmpCircleVerts1><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></tmpCircleVerts1>
		<tmpCircleVerts2><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></tmpCircleVerts2>
		<tmpCircleNorms><x path="haxe.ds.Vector"><c path="oimo.common.Vec3"/></x></tmpCircleNorms>
		<aabb public="1" set="method" line="246">
			<f a="min:max:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws an axis-aligned bounding box.
	 *
	 * `min` is the minimum point of the AABB.
	 *
	 * `max` is the maximum point of the AABB.
	 *
	 * `color` is the color of the AABB.</haxe_doc>
		</aabb>
		<basis public="1" set="method" line="288">
			<f a="transform:length:colorX:colorY:colorZ">
				<c path="oimo.common.Transform"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws the basis of a transform `transform`.
	 *
	 * `length` is the length of the lines to be drawn.
	 *
	 * `colorX` is the color of the x-axis of the basis.
	 *
	 * `colorY` is the color of the y-axis of the basis.
	 *
	 * `colorZ` is the color of the z-axis of the basis.</haxe_doc>
		</basis>
		<ellipse public="1" set="method" line="331">
			<f a="center:ex:ey:radiusX:radiusY:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws an ellipse.
	 *
	 * `center` is the center of the ellipse.
	 *
	 * `ex` is the normalized x-axis vector of the ellipse.
	 *
	 * `ey` is the normalized y-axis vector of the ellipse.
	 *
	 * `radiusX` is the radius along the x-axis of the ellipse.
	 *
	 * `radiusY` is the radius along the y-axis of the ellipse.
	 *
	 * `color` is the color of the ellipse.</haxe_doc>
		</ellipse>
		<arc public="1" set="method" line="356">
			<f a="center:ex:ey:radiusX:radiusY:startAngle:endAngle:drawSector:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Bool"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws an arc.
	 *
	 * `center` is the center of the arc.
	 *
	 * `ex` is the normalized x-axis vector of the arc.
	 *
	 * `ey` is the normalized y-axis vector of the arc.
	 *
	 * `radiusX` is the radius along the x-axis of the arc.
	 *
	 * `radiusY` is the radius along the y-axis of the arc.
	 *
	 * `startAngle` is the start angle of the arc in radians.
	 *
	 * `endAngle` is the end angle of the arc in radians.
	 *
	 * `drawSector` is whether to draw line segments between start/end point and center point.
	 *
	 * `color` is the color of the arc.</haxe_doc>
		</arc>
		<cone public="1" set="method" line="406">
			<f a="tf:radius:halfHeight:color">
				<c path="oimo.common.Transform"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a cone locally along to the y-axis. The center of the cone is in the middle of
	 * the vertex and the center of the base circle.
	 *
	 * `tf` is the transformation of the cone.
	 *
	 * `radius` is the radius of the base circle of the cone.
	 *
	 * `halfHeight` is the half-height of the cone. The local position of the vertex of
	 * the cone is `(0, halfHeight, 0)`.
	 *
	 * `color` is the color of the cone.</haxe_doc>
		</cone>
		<cylinder public="1" set="method" line="501">
			<f a="tf:radius:halfHeight:color">
				<c path="oimo.common.Transform"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a cylinder locally along to the y-axis.
	 *
	 * `tf` is the transformation of the cylinder.
	 *
	 * `radius` is the radius of the cylinder.
	 *
	 * `halfHeight` is the half-height of the cylinder.
	 *
	 * `color` is the color of the cylinder.</haxe_doc>
		</cylinder>
		<capsule public="1" set="method" line="609">
			<f a="tf:radius:halfHeight:color">
				<c path="oimo.common.Transform"/>
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a capsule locally along to the y-axis.
	 *
	 * `tf` is the transformation of the capsule.
	 *
	 * `radius` is the radius of the capsule.
	 *
	 * `halfHeight` is the half-height of the capsule.
	 *
	 * `color` is the color of the capsule.</haxe_doc>
		</capsule>
		<sphere public="1" set="method" line="807">
			<f a="tf:radius:color">
				<c path="oimo.common.Transform"/>
				<x path="Float"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a sphere.
	 *
	 * `tf` is the transformation of the sphere.
	 *
	 * `radius` is the radius of the sphere.
	 *
	 * `color` is the color of the sphere.</haxe_doc>
		</sphere>
		<box public="1" set="method" line="908">
			<f a="tf:halfExtents:color">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a box.
	 *
	 * `tf` is the transformation of the box.
	 *
	 * `halfExtents` is the half-extents of the box.
	 *
	 * `color` is the color of the box.</haxe_doc>
		</box>
		<rect public="1" set="method" line="999">
			<f a="v1:v2:v3:v4:n1:n2:n3:n4:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a rectangle.
	 *
	 * `v1`, `v2`, `v3`, `v4` are the rectangle's vertices in CCW order.
	 *
	 * `n1`, `n2`, `n3`, `n4` are the normals of the rectangle's vertices in CCW order.
	 *
	 * `color` is the color of the rectangle.</haxe_doc>
		</rect>
		<point public="1" set="method" line="1009">
			<f a="v:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a point at `v`.
	 *
	 * `color` is the color of the point.</haxe_doc>
		</point>
		<triangle public="1" set="method" line="1022">
			<f a="v1:v2:v3:n1:n2:n3:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a triangle.
	 *
	 * `v1`, `v2`, `v3` are the triangle's vertices in CCW order.
	 *
	 * `n1`, `n2`, `n3` are the normals of the triangle's vertices in CCW order.
	 *
	 * `color` is the color of the triangle.</haxe_doc>
		</triangle>
		<line public="1" set="method" line="1031">
			<f a="v1:v2:color">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Draws a line segment between `v1` and `v2`.
	 *
	 * `color` is the color of the line segment.</haxe_doc>
		</line>
		<new public="1" set="method" line="106">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* The interface of debug drawer. This provides graphical information of a physics world
 * for debugging softwares. Users should override at least three methods `DebugDraw.point`,
 * `DebugDraw.triangle`, `DebugDraw.line`.</haxe_doc>
		<meta><m n=":interface"/></meta>
	</class>
	<class path="oimo.dynamics.common.DebugDrawStyle" params="" file="src/oimo/dynamics/common/DebugDrawStyle.hx">
		<shapeColor1 public="1" expr="new Vec3(0.7, 0.2, 0.4)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.7, 0.2, 0.4)</e></m></meta>
		</shapeColor1>
		<shapeColor2 public="1" expr="new Vec3(1.0, 0.8, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.8, 0.1)</e></m></meta>
		</shapeColor2>
		<sleepyShapeColor1 public="1" expr="new Vec3(0.5, 0.25, 0.6)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.5, 0.25, 0.6)</e></m></meta>
		</sleepyShapeColor1>
		<sleepyShapeColor2 public="1" expr="new Vec3(0.6, 0.8, 0.3)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.6, 0.8, 0.3)</e></m></meta>
		</sleepyShapeColor2>
		<sleepingShapeColor1 public="1" expr="new Vec3(0.3, 0.3, 0.8)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.3, 0.3, 0.8)</e></m></meta>
		</sleepingShapeColor1>
		<sleepingShapeColor2 public="1" expr="new Vec3(0.2, 0.8, 0.5)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.2, 0.8, 0.5)</e></m></meta>
		</sleepingShapeColor2>
		<staticShapeColor public="1" expr="new Vec3(0.7, 0.7, 0.7)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.7, 0.7, 0.7)</e></m></meta>
		</staticShapeColor>
		<kinematicShapeColor public="1" expr="new Vec3(1.0, 0.5, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.5, 0.1)</e></m></meta>
		</kinematicShapeColor>
		<aabbColor public="1" expr="new Vec3(1.0, 0.1, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.1, 0.1)</e></m></meta>
		</aabbColor>
		<bvhNodeColor public="1" expr="new Vec3(0.4, 0.4, 0.4)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.4, 0.4, 0.4)</e></m></meta>
		</bvhNodeColor>
		<pairColor public="1" expr="new Vec3(1.0, 1.0, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 1.0, 0.1)</e></m></meta>
		</pairColor>
		<contactColor public="1" expr="new Vec3(1.0, 0.1, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.1, 0.1)</e></m></meta>
		</contactColor>
		<contactColor2 public="1" expr="new Vec3(1.0, 0.6, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.6, 0.1)</e></m></meta>
		</contactColor2>
		<contactColor3 public="1" expr="new Vec3(0.1, 0.8, 0.6)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.1, 0.8, 0.6)</e></m></meta>
		</contactColor3>
		<contactColor4 public="1" expr="new Vec3(0.8, 0.1, 1.0)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.8, 0.1, 1.0)</e></m></meta>
		</contactColor4>
		<newContactColor public="1" expr="new Vec3(1.0, 1.0, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 1.0, 0.1)</e></m></meta>
		</newContactColor>
		<disabledContactColor public="1" expr="new Vec3(0.5, 0.1, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.5, 0.1, 0.1)</e></m></meta>
		</disabledContactColor>
		<contactNormalColor public="1" expr="new Vec3(1.0, 0.1, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.1, 0.1)</e></m></meta>
		</contactNormalColor>
		<contactTangentColor public="1" expr="new Vec3(0.1, 0.8, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.1, 0.8, 0.1)</e></m></meta>
		</contactTangentColor>
		<contactBinormalColor public="1" expr="new Vec3(0.2, 0.2, 1.0)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.2, 0.2, 1.0)</e></m></meta>
		</contactBinormalColor>
		<contactNormalLength public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</contactNormalLength>
		<contactTangentLength public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</contactTangentLength>
		<contactBinormalLength public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</contactBinormalLength>
		<jointLineColor public="1" expr="new Vec3(0.8, 0.8, 0.8)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.8, 0.8, 0.8)</e></m></meta>
		</jointLineColor>
		<jointErrorColor public="1" expr="new Vec3(1.0, 0.1, 0.1)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.1, 0.1)</e></m></meta>
		</jointErrorColor>
		<jointRotationalConstraintRadius public="1" expr="0.3">
			<x path="Float"/>
			<meta><m n=":value"><e>0.3</e></m></meta>
		</jointRotationalConstraintRadius>
		<basisLength public="1" expr="0.5">
			<x path="Float"/>
			<meta><m n=":value"><e>0.5</e></m></meta>
		</basisLength>
		<basisColorX public="1" expr="new Vec3(1.0, 0.0, 0.0)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(1.0, 0.0, 0.0)</e></m></meta>
		</basisColorX>
		<basisColorY public="1" expr="new Vec3(0.0, 1.0, 0.0)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.0, 1.0, 0.0)</e></m></meta>
		</basisColorY>
		<basisColorZ public="1" expr="new Vec3(0.0, 0.0, 1.0)">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":value"><e>new Vec3(0.0, 0.0, 1.0)</e></m></meta>
		</basisColorZ>
		<new public="1" set="method" line="48">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Style settings of the debug draw.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.common.Performance" params="" file="src/oimo/dynamics/common/Performance.hx">
		<broadPhaseCollisionTime public="1" expr="0" line="7" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</broadPhaseCollisionTime>
		<narrowPhaseCollisionTime public="1" expr="0" line="8" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</narrowPhaseCollisionTime>
		<dynamicsTime public="1" expr="0" line="9" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</dynamicsTime>
		<totalTime public="1" expr="0" line="10" static="1">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</totalTime>
		<haxe_doc>* Performance</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.constraint.ConstraintSolver" params="" file="src/oimo/dynamics/constraint/ConstraintSolver.hx">
		<_b1 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b1>
		<_b2 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b2>
		<_addedToIsland public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addedToIsland>
		<preSolveVelocity public="1" set="method" line="27">
			<f a="timeStep">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Prepares for velocity iteration. Time step information `timeStep` is given for
	 * computing time-depending data.</haxe_doc>
		</preSolveVelocity>
		<warmStart public="1" set="method" line="33">
			<f a="timeStep">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies initial impulses.</haxe_doc>
		</warmStart>
		<solveVelocity public="1" set="method" line="39">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Performs single velocity iteration.</haxe_doc>
		</solveVelocity>
		<postSolveVelocity public="1" set="method" line="46">
			<f a="timeStep">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs post-processes of velocity part. Time step information `timeStep` is given
	 * for computing time-depending data.</haxe_doc>
		</postSolveVelocity>
		<preSolvePosition public="1" set="method" line="55">
			<f a="timeStep">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Prepares for position iteration (split impulse or nonlinear Gauss-Seidel). Time step
	 * information `timeStep` is given for computing time-depending data.
	 *
	 * This may not be called depending on position correction algorithm.</haxe_doc>
		</preSolvePosition>
		<solvePositionSplitImpulse public="1" set="method" line="61">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Performs single position iteration (split impulse)</haxe_doc>
		</solvePositionSplitImpulse>
		<solvePositionNgs public="1" set="method" line="67">
			<f a="timeStep">
				<c path="oimo.dynamics.TimeStep"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Performs single position iteration (nonlinear Gauss-Seidel)</haxe_doc>
		</solvePositionNgs>
		<postSolve public="1" set="method" line="73">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Performs post-processes.</haxe_doc>
		</postSolve>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The base class of all constarint solvers.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.PositionCorrectionAlgorithm" params="" file="src/oimo/dynamics/constraint/PositionCorrectionAlgorithm.hx">
		<_BAUMGARTE public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_BAUMGARTE>
		<_SPLIT_IMPULSE public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_SPLIT_IMPULSE>
		<_NGS public="1" get="inline" set="null" expr="2" line="12" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_NGS>
		<BAUMGARTE public="1" set="null" expr="_BAUMGARTE" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_BAUMGARTE</e></m></meta>
			<haxe_doc>* Baumgarte stabilizaiton. Fastest but introduces extra energy.</haxe_doc>
		</BAUMGARTE>
		<SPLIT_IMPULSE public="1" set="null" expr="_SPLIT_IMPULSE" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_SPLIT_IMPULSE</e></m></meta>
			<haxe_doc>* Use split impulse and pseudo velocity. Fast enough and does not introduce extra
	 * energy, but somewhat unstable, especially for joints.</haxe_doc>
		</SPLIT_IMPULSE>
		<NGS public="1" set="null" expr="_NGS" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_NGS</e></m></meta>
			<haxe_doc>* Nonlinear Gauss-Seidel method. Slow but stable.</haxe_doc>
		</NGS>
		<haxe_doc>* The list of the algorithms for position corretion.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.contact.ContactConstraint" params="" file="src/oimo/dynamics/constraint/contact/ContactConstraint.hx">
		<_positionCorrectionAlgorithm public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_positionCorrectionAlgorithm>
		<_manifold public="1">
			<c path="oimo.dynamics.constraint.contact.Manifold"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_manifold>
		<_s1 public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_s1>
		<_s2 public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_s2>
		<_tf1 public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tf1>
		<_tf2 public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tf2>
		<_invM1 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invM1>
		<_invM2 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invM2>
		<_friction public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_friction>
		<_restitution public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_restitution>
		<_invI100 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI100>
		<_invI101 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI101>
		<_invI102 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI102>
		<_invI110 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI110>
		<_invI111 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI111>
		<_invI112 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI112>
		<_invI120 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI120>
		<_invI121 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI121>
		<_invI122 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI122>
		<_invI200 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI200>
		<_invI201 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI201>
		<_invI202 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI202>
		<_invI210 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI210>
		<_invI211 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI211>
		<_invI212 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI212>
		<_invI220 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI220>
		<_invI221 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI221>
		<_invI222 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invI222>
		<_b1 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b1>
		<_b2 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b2>
		<_solver public="1">
			<c path="oimo.dynamics.constraint.ConstraintSolver"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_solver>
		<_getVelocitySolverInfo public="1" set="method" line="70">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.contact.ContactSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="162">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.contact.ContactSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<_syncManifold public="1" set="method" line="198">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncManifold>
		<getShape1 public="1" get="inline" set="null" line="207">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the first shape of the contact.</haxe_doc>
		</getShape1>
		<getShape2 public="1" get="inline" set="null" line="214">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the second shape of the contact.</haxe_doc>
		</getShape2>
		<getManifold public="1" get="inline" set="null" line="221">
			<f a=""><c path="oimo.dynamics.constraint.contact.Manifold"/></f>
			<haxe_doc>* Returns the contact manifold.</haxe_doc>
		</getManifold>
		<isTouching public="1" set="method" line="228">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether the two rigid bodies are touching.</haxe_doc>
		</isTouching>
		<new public="1" set="method" line="45">
			<f a="manifold">
				<c path="oimo.dynamics.constraint.contact.Manifold"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A contact constraint provides collision information for a contact constraint solver.
 * This holds a contact manifold, which has some contact points, contact normals, and
 * contact impulses. See `Manifold` for more information.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.contact.ContactImpulse" params="" file="src/oimo/dynamics/constraint/contact/ContactImpulse.hx">
		<impulseN public="1"><x path="Float"/></impulseN>
		<impulseT public="1"><x path="Float"/></impulseT>
		<impulseB public="1"><x path="Float"/></impulseB>
		<impulseP public="1"><x path="Float"/></impulseP>
		<impulseLX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</impulseLX>
		<impulseLY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</impulseLY>
		<impulseLZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</impulseLZ>
		<copyFrom public="1" set="method" line="39"><f a="imp">
	<c path="oimo.dynamics.constraint.contact.ContactImpulse"/>
	<x path="Void"/>
</f></copyFrom>
		<new public="1" set="method" line="27"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.contact.Manifold" params="" file="src/oimo/dynamics/constraint/contact/Manifold.hx">
		<_normalX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_normalX>
		<_normalY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_normalY>
		<_normalZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_normalZ>
		<_tangentX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tangentX>
		<_tangentY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tangentY>
		<_tangentZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_tangentZ>
		<_binormalX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_binormalX>
		<_binormalY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_binormalY>
		<_binormalZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_binormalZ>
		<_numPoints public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numPoints>
		<_points public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.contact.ManifoldPoint"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_points>
		<_clear public="1" set="method" line="35">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_clear>
		<_buildBasis public="1" set="method" line="42">
			<f a="normal">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_buildBasis>
		<_updateDepthsAndPositions public="1" set="method" line="85">
			<f a="tf1:tf2">
				<c path="oimo.common.Transform"/>
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_updateDepthsAndPositions>
		<getNormal public="1" get="inline" set="null" line="106">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the normal vector of the contact manifold. The normal vector has unit
	 * length and is perpendicular to the contact plane.</haxe_doc>
		</getNormal>
		<getNormalTo public="1" get="inline" set="null" line="118">
			<f a="normal">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `normal` to the normal vector of the contact manifold. The normal vector has
	 * unit length and is perpendicular to the contact plane.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getNormalTo>
		<getTangent public="1" get="inline" set="null" line="126">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the tangent vector of the contact manifold. The tangent vector has unit
	 * length and is perpendicular to the normal vector.</haxe_doc>
		</getTangent>
		<getTangentTo public="1" get="inline" set="null" line="138">
			<f a="tangent">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `tangent` to the tangent vector of the contact manifold. The tangent vector has
	 * unit length and is perpendicular to the normal vector.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getTangentTo>
		<getBinormal public="1" get="inline" set="null" line="146">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the binormal vector of the contact manifold. The binormal vector has unit
	 * length and is perpendicular to both the normal and the tangent vector.</haxe_doc>
		</getBinormal>
		<getBinormalTo public="1" get="inline" set="null" line="158">
			<f a="binormal">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `binormal` to the binormal vector of the contact manifold. The binormal vector has
	 * unit length and is perpendicular to both the normal and the tangent vector.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getBinormalTo>
		<getPoints public="1" get="inline" set="null" line="167">
			<f a=""><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.contact.ManifoldPoint"/></x></f>
			<haxe_doc>* Returns the manifold point vector of the contact manifold. Note that **only the first
	 * `Manifold.getNumPoints` elements of the vector are in use**, and the manifold points may
	 * be disabled (see `ManifoldPoint.isEnabled`).</haxe_doc>
		</getPoints>
		<getNumPoints public="1" get="inline" set="null" line="174">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of existing manifold points.</haxe_doc>
		</getNumPoints>
		<new public="1" set="method" line="22">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A contact manifold holds collision data of a pair of shapes.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.contact.ManifoldPoint" params="" file="src/oimo/dynamics/constraint/contact/ManifoldPoint.hx">
		<_localPos1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos1X>
		<_localPos1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos1Y>
		<_localPos1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos1Z>
		<_localPos2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos2X>
		<_localPos2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos2Y>
		<_localPos2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localPos2Z>
		<_relPos1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos1X>
		<_relPos1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos1Y>
		<_relPos1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos1Z>
		<_relPos2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos2X>
		<_relPos2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos2Y>
		<_relPos2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relPos2Z>
		<_pos1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos1X>
		<_pos1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos1Y>
		<_pos1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos1Z>
		<_pos2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos2X>
		<_pos2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos2Y>
		<_pos2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pos2Z>
		<_depth public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_depth>
		<_impulse public="1">
			<c path="oimo.dynamics.constraint.contact.ContactImpulse"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_impulse>
		<_warmStarted public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_warmStarted>
		<_disabled public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_disabled>
		<_id public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_id>
		<getPosition1 public="1" get="inline" set="null" line="127">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's manifold point in world coordinate.</haxe_doc>
		</getPosition1>
		<getPosition1To public="1" get="inline" set="null" line="137">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `position` to the first rigid body's manifold point in world coordinate.
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getPosition1To>
		<getPosition2 public="1" get="inline" set="null" line="144">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's manifold point in world coordinate.</haxe_doc>
		</getPosition2>
		<getPosition2To public="1" get="inline" set="null" line="154">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `position` to the second rigid body's manifold point in world coordinate.
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getPosition2To>
		<getDepth public="1" get="inline" set="null" line="162">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the amount of the overlap. If the manifold point is separate, a negative
	 * value is returned.</haxe_doc>
		</getDepth>
		<isWarmStarted public="1" get="inline" set="null" line="169">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether the manifold point has existed for more than two steps.</haxe_doc>
		</isWarmStarted>
		<getNormalImpulse public="1" get="inline" set="null" line="176">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the normal impulse of the manifold point.</haxe_doc>
		</getNormalImpulse>
		<getTangentImpulse public="1" get="inline" set="null" line="183">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the tangent impulse of the manifold point.</haxe_doc>
		</getTangentImpulse>
		<getBinormalImpulse public="1" get="inline" set="null" line="190">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the binormal impulse of the manifold point.</haxe_doc>
		</getBinormalImpulse>
		<isEnabled public="1" get="inline" set="null" line="197">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether the manifold point is enabled.</haxe_doc>
		</isEnabled>
		<new public="1" set="method" line="38">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A manifold point is a contact point in a contact manifold. This holds detailed collision
 * data (position, overlap depth, impulse, etc...) for collision response.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.contact.ManifoldUpdater" params="" file="src/oimo/dynamics/constraint/contact/ManifoldUpdater.hx">
		<_manifold>
			<c path="oimo.dynamics.constraint.contact.Manifold"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_manifold>
		<numOldPoints><x path="Int"/></numOldPoints>
		<oldPoints><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.contact.ManifoldPoint"/></x></oldPoints>
		<removeOutdatedPoints set="method" line="33"><f a=""><x path="Void"/></f></removeOutdatedPoints>
		<removeManifoldPoint set="method" line="58"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></removeManifoldPoint>
		<addManifoldPoint set="method" line="68"><f a="point:tf1:tf2">
	<c path="oimo.collision.narrowphase.DetectorResultPoint"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Void"/>
</f></addManifoldPoint>
		<computeTargetIndex set="method" line="82"><f a="newPoint:tf1:tf2">
	<c path="oimo.collision.narrowphase.DetectorResultPoint"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Int"/>
</f></computeTargetIndex>
		<computeRelativePositions set="method" line="165"><f a="tf1:tf2">
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Void"/>
</f></computeRelativePositions>
		<findNearestContactPointIndex set="method" line="175"><f a="target:tf1:tf2">
	<c path="oimo.collision.narrowphase.DetectorResultPoint"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Int"/>
</f></findNearestContactPointIndex>
		<totalUpdate public="1" set="method" line="229"><f a="result:tf1:tf2">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Void"/>
</f></totalUpdate>
		<incrementalUpdate public="1" set="method" line="242"><f a="result:tf1:tf2">
	<c path="oimo.collision.narrowphase.DetectorResult"/>
	<c path="oimo.common.Transform"/>
	<c path="oimo.common.Transform"/>
	<x path="Void"/>
</f></incrementalUpdate>
		<new public="1" set="method" line="21"><f a="manifold">
	<c path="oimo.dynamics.constraint.contact.Manifold"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.info.JacobianRow" params="" file="src/oimo/dynamics/constraint/info/JacobianRow.hx">
		<BIT_LINEAR_SET get="inline" set="null" expr="1" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>1</e></m></meta>
		</BIT_LINEAR_SET>
		<BIT_ANGULAR_SET get="inline" set="null" expr="2" line="17" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>2</e></m></meta>
		</BIT_ANGULAR_SET>
		<lin1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin1X>
		<lin1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin1Y>
		<lin1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin1Z>
		<lin2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin2X>
		<lin2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin2Y>
		<lin2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</lin2Z>
		<ang1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang1X>
		<ang1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang1Y>
		<ang1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang1Z>
		<ang2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang2X>
		<ang2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang2Y>
		<ang2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</ang2Z>
		<flag><x path="Int"/></flag>
		<updateSparsity public="1" set="method" line="35"><f a=""><x path="Void"/></f></updateSparsity>
		<new public="1" set="method" line="20"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* The row of a Jacobian matrix.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.info.contact.ContactSolverInfo" params="" file="src/oimo/dynamics/constraint/info/contact/ContactSolverInfo.hx">
		<b1 public="1"><c path="oimo.dynamics.rigidbody.RigidBody"/></b1>
		<b2 public="1"><c path="oimo.dynamics.rigidbody.RigidBody"/></b2>
		<numRows public="1"><x path="Int"/></numRows>
		<rows public="1"><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.info.contact.ContactSolverInfoRow"/></x></rows>
		<new public="1" set="method" line="17"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.info.contact.ContactSolverInfoRow" params="" file="src/oimo/dynamics/constraint/info/contact/ContactSolverInfoRow.hx">
		<jacobianN public="1">
			<c path="oimo.dynamics.constraint.info.JacobianRow"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</jacobianN>
		<jacobianT public="1">
			<c path="oimo.dynamics.constraint.info.JacobianRow"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</jacobianT>
		<jacobianB public="1">
			<c path="oimo.dynamics.constraint.info.JacobianRow"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</jacobianB>
		<rhs public="1">
			<x path="Float"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</rhs>
		<cfm public="1">
			<x path="Float"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</cfm>
		<friction public="1">
			<x path="Float"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</friction>
		<impulse public="1">
			<c path="oimo.dynamics.constraint.contact.ContactImpulse"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</impulse>
		<new public="1" set="method" line="31"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.info.joint.JointSolverInfo" params="" file="src/oimo/dynamics/constraint/info/joint/JointSolverInfo.hx">
		<b1 public="1"><c path="oimo.dynamics.rigidbody.RigidBody"/></b1>
		<b2 public="1"><c path="oimo.dynamics.rigidbody.RigidBody"/></b2>
		<numRows public="1"><x path="Int"/></numRows>
		<rows public="1"><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.info.joint.JointSolverInfoRow"/></x></rows>
		<new public="1" set="method" line="18"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.info.joint.JointSolverInfoRow" params="" file="src/oimo/dynamics/constraint/info/joint/JointSolverInfoRow.hx">
		<jacobian public="1">
			<c path="oimo.dynamics.constraint.info.JacobianRow"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</jacobian>
		<rhs public="1">
			<x path="Float"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</rhs>
		<cfm public="1">
			<x path="Float"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</cfm>
		<minImpulse public="1">
			<x path="Float"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</minImpulse>
		<maxImpulse public="1">
			<x path="Float"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</maxImpulse>
		<motorSpeed public="1">
			<x path="Float"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</motorSpeed>
		<motorMaxImpulse public="1">
			<x path="Float"/>
			<haxe_doc>Used for velocity solver.</haxe_doc>
		</motorMaxImpulse>
		<impulse public="1">
			<c path="oimo.dynamics.constraint.joint.JointImpulse"/>
			<haxe_doc>Used for both velocity and position solver.</haxe_doc>
		</impulse>
		<new public="1" set="method" line="36"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.BasisTracker" params="" file="src/oimo/dynamics/constraint/joint/BasisTracker.hx">
		<joint><c path="oimo.dynamics.constraint.joint.Joint"/></joint>
		<xX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</xX>
		<xY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</xY>
		<xZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</xZ>
		<yX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</yX>
		<yY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</yY>
		<yZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</yZ>
		<zX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</zX>
		<zY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</zY>
		<zZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</zZ>
		<new public="1" set="method" line="19"><f a="joint">
	<c path="oimo.dynamics.constraint.joint.Joint"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.Joint" params="" file="src/oimo/dynamics/constraint/joint/Joint.hx">
		<_b1 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b1>
		<_b2 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_b2>
		<_link1 public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_link1>
		<_link2 public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_link2>
		<_positionCorrectionAlgorithm public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_positionCorrectionAlgorithm>
		<_allowCollision public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_allowCollision>
		<_prev public="1">
			<c path="oimo.dynamics.constraint.joint.Joint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_next public="1">
			<c path="oimo.dynamics.constraint.joint.Joint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_world public="1">
			<c path="oimo.dynamics.World"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_world>
		<_localAnchor1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor1X>
		<_localAnchor1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor1Y>
		<_localAnchor1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor1Z>
		<_localAnchor2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor2X>
		<_localAnchor2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor2Y>
		<_localAnchor2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localAnchor2Z>
		<_relativeAnchor1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor1X>
		<_relativeAnchor1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor1Y>
		<_relativeAnchor1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor1Z>
		<_relativeAnchor2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor2X>
		<_relativeAnchor2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor2Y>
		<_relativeAnchor2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_relativeAnchor2Z>
		<_anchor1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor1X>
		<_anchor1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor1Y>
		<_anchor1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor1Z>
		<_anchor2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor2X>
		<_anchor2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor2Y>
		<_anchor2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_anchor2Z>
		<_localBasisX1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX1X>
		<_localBasisX1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX1Y>
		<_localBasisX1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX1Z>
		<_localBasisY1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY1X>
		<_localBasisY1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY1Y>
		<_localBasisY1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY1Z>
		<_localBasisZ1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ1X>
		<_localBasisZ1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ1Y>
		<_localBasisZ1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ1Z>
		<_localBasisX2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX2X>
		<_localBasisX2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX2Y>
		<_localBasisX2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisX2Z>
		<_localBasisY2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY2X>
		<_localBasisY2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY2Y>
		<_localBasisY2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisY2Z>
		<_localBasisZ2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ2X>
		<_localBasisZ2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ2Y>
		<_localBasisZ2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localBasisZ2Z>
		<_basisX1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX1X>
		<_basisX1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX1Y>
		<_basisX1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX1Z>
		<_basisY1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY1X>
		<_basisY1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY1Y>
		<_basisY1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY1Z>
		<_basisZ1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ1X>
		<_basisZ1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ1Y>
		<_basisZ1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ1Z>
		<_basisX2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX2X>
		<_basisX2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX2Y>
		<_basisX2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisX2Z>
		<_basisY2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY2X>
		<_basisY2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY2Y>
		<_basisY2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisY2Z>
		<_basisZ2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ2X>
		<_basisZ2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ2Y>
		<_basisZ2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basisZ2Z>
		<_impulses public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.joint.JointImpulse"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_impulses>
		<_appliedForceX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedForceX>
		<_appliedForceY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedForceY>
		<_appliedForceZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedForceZ>
		<_appliedTorqueX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedTorqueX>
		<_appliedTorqueY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedTorqueY>
		<_appliedTorqueZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_appliedTorqueZ>
		<_breakForce public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_breakForce>
		<_breakTorque public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_breakTorque>
		<_type public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_type>
		<_solver public="1">
			<c path="oimo.dynamics.constraint.ConstraintSolver"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_solver>
		<userData public="1">
			<x path="Any"/>
			<haxe_doc>* Extra field that users can use for their own purposes.</haxe_doc>
		</userData>
		<buildLocalBasesFromX set="method" line="117"><f a=""><x path="Void"/></f></buildLocalBasesFromX>
		<buildLocalBasesFromXY set="method" line="143"><f a=""><x path="Void"/></f></buildLocalBasesFromXY>
		<buildLocalBasesFromX1Z2 set="method" line="186"><f a=""><x path="Void"/></f></buildLocalBasesFromX1Z2>
		<buildLocalBasesFromXY1X2 set="method" line="229"><f a=""><x path="Void"/></f></buildLocalBasesFromXY1X2>
		<setSolverInfoRowLinear set="method" line="263"><f a="row:diff:lm:mass:sd:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfoRow"/>
	<x path="Float"/>
	<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
	<x path="Float"/>
	<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSolverInfoRowLinear>
		<setSolverInfoRowAngular set="method" line="338"><f a="row:diff:lm:mass:sd:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfoRow"/>
	<x path="Float"/>
	<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
	<x path="Float"/>
	<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></setSolverInfoRowAngular>
		<getErp set="method" line="419"><f a="timeStep:isPositionPart">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Float"/>
</f></getErp>
		<computeEffectiveInertiaMoment set="method" line="431"><f a="axisX:axisY:axisZ">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></computeEffectiveInertiaMoment>
		<computeEffectiveInertiaMoment2 set="method" line="465"><f a="axis1X:axis1Y:axis1Z:axis2X:axis2Y:axis2Z">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></computeEffectiveInertiaMoment2>
		<_syncAnchors public="1" set="method" line="511">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="532">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="538">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<_checkDestruction public="1" set="method" line="544">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_checkDestruction>
		<getRigidBody1 public="1" get="inline" set="null" line="585">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the first rigid body.</haxe_doc>
		</getRigidBody1>
		<getRigidBody2 public="1" get="inline" set="null" line="592">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the second rigid body.</haxe_doc>
		</getRigidBody2>
		<getType public="1" get="inline" set="null" line="601">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the type of the joint.
	 *
	 * See `JointType` for details.</haxe_doc>
		</getType>
		<getAnchor1 public="1" get="inline" set="null" line="608">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's anchor point in world coordinates.</haxe_doc>
		</getAnchor1>
		<getAnchor2 public="1" get="inline" set="null" line="617">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's anchor point in world coordinates.</haxe_doc>
		</getAnchor2>
		<getAnchor1To public="1" get="inline" set="null" line="628">
			<f a="anchor">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `anchor` to the first rigid body's anchor point in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAnchor1To>
		<getAnchor2To public="1" get="inline" set="null" line="637">
			<f a="anchor">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `anchor` to the second rigid body's anchor point in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAnchor2To>
		<getLocalAnchor1 public="1" get="inline" set="null" line="644">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's local anchor point in world coordinates.</haxe_doc>
		</getLocalAnchor1>
		<getLocalAnchor2 public="1" get="inline" set="null" line="653">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's local anchor point in world coordinates.</haxe_doc>
		</getLocalAnchor2>
		<getLocalAnchor1To public="1" get="inline" set="null" line="664">
			<f a="localAnchor">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `localAnchor` to the first rigid body's anchor point in local coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAnchor1To>
		<getLocalAnchor2To public="1" get="inline" set="null" line="673">
			<f a="localAnchor">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `localAnchor` to the second rigid body's anchor point in local coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAnchor2To>
		<getBasis1 public="1" get="inline" set="null" line="680">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the basis of the joint for the first rigid body in world coordinates.</haxe_doc>
		</getBasis1>
		<getBasis2 public="1" get="inline" set="null" line="691">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the basis of the joint for the second rigid body in world coordinates.</haxe_doc>
		</getBasis2>
		<getBasis1To public="1" get="inline" set="null" line="704">
			<f a="basis">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `basis` to the basis of the joint for the first rigid body in world coordinates.
	 *
	 * This does not create a new instance of `Mat3`.</haxe_doc>
		</getBasis1To>
		<getBasis2To public="1" get="inline" set="null" line="715">
			<f a="basis">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `basis` to the basis of the joint for the second rigid body in world coordinates.
	 *
	 * This does not create a new instance of `Mat3`.</haxe_doc>
		</getBasis2To>
		<getAllowCollision public="1" get="inline" set="null" line="724">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether to allow the connected rigid bodies to collide each other.</haxe_doc>
		</getAllowCollision>
		<setAllowCollision public="1" get="inline" set="null" line="731">
			<f a="allowCollision">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets whether to allow the connected rigid bodies to collide each other.</haxe_doc>
		</setAllowCollision>
		<getBreakForce public="1" get="inline" set="null" line="740">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the magnitude of the constraint force at which the joint will be destroyed.
	 *
	 * Returns `0` if the joint is unbreakable.</haxe_doc>
		</getBreakForce>
		<setBreakForce public="1" get="inline" set="null" line="749">
			<f a="breakForce">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the magnitude of the constraint force at which the joint will be destroyed.
	 *
	 * Set `0` for unbreakable joints.</haxe_doc>
		</setBreakForce>
		<getBreakTorque public="1" get="inline" set="null" line="758">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the magnitude of the constraint torque at which the joint will be destroyed.
	 *
	 * Returns `0` if the joint is unbreakable.</haxe_doc>
		</getBreakTorque>
		<setBreakTorque public="1" get="inline" set="null" line="767">
			<f a="breakTorque">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the magnitude of the constraint force at which the joint will be destroyed.
	 *
	 * Set `0` for unbreakable joints.</haxe_doc>
		</setBreakTorque>
		<getPositionCorrectionAlgorithm public="1" get="inline" set="null" line="776">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the type of the position correction algorithm for the joint.
	 *
	 * See `PositionCorrectionAlgorithm` for details.</haxe_doc>
		</getPositionCorrectionAlgorithm>
		<setPositionCorrectionAlgorithm public="1" get="inline" set="null" line="785">
			<f a="positionCorrectionAlgorithm">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the type of the position correction algorithm to `positionCorrectionAlgorithm` for the joint.
	 *
	 * See `PositionCorrectionAlgorithm` for details.</haxe_doc>
		</setPositionCorrectionAlgorithm>
		<getAppliedForce public="1" get="inline" set="null" line="801">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the force applied to the first rigid body at the last time step.</haxe_doc>
		</getAppliedForce>
		<getAppliedForceTo public="1" get="inline" set="null" line="812">
			<f a="appliedForce">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `appliedForce` to the force applied to the first rigid body at the last time step.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAppliedForceTo>
		<getAppliedTorque public="1" get="inline" set="null" line="819">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the torque applied to the first rigid body at the last time step.</haxe_doc>
		</getAppliedTorque>
		<getAppliedTorqueTo public="1" get="inline" set="null" line="830">
			<f a="appliedTorque">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `appliedTorque` to the torque applied to the first rigid body at the last time step.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAppliedTorqueTo>
		<getPrev public="1" get="inline" set="null" line="839">
			<f a=""><c path="oimo.dynamics.constraint.joint.Joint"/></f>
			<haxe_doc>* Returns the previous joint in the world.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" get="inline" set="null" line="848">
			<f a=""><c path="oimo.dynamics.constraint.joint.Joint"/></f>
			<haxe_doc>* Returns the next joint in the world.
	 *
	 * If the next one does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="75">
			<f a="config:type">
				<c path="oimo.dynamics.constraint.joint.JointConfig"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The base class of joints. Joints are used to connect two rigid bodies
 * in various ways. See `JointType` for all types of joints.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.CylindricalJoint" params="" file="src/oimo/dynamics/constraint/joint/CylindricalJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_translSd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_translSd>
		<_translLm public="1">
			<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_translLm>
		<_rotSd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotSd>
		<_rotLm public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotLm>
		<_basis public="1">
			<c path="oimo.dynamics.constraint.joint.BasisTracker"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basis>
		<angle><x path="Float"/></angle>
		<angularErrorY><x path="Float"/></angularErrorY>
		<angularErrorZ><x path="Float"/></angularErrorZ>
		<translation><x path="Float"/></translation>
		<linearErrorY><x path="Float"/></linearErrorY>
		<linearErrorZ><x path="Float"/></linearErrorZ>
		<getInfo set="method" line="64"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="170" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="178" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="183" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxis1 public="1" get="inline" set="null" line="193">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis1>
		<getAxis2 public="1" get="inline" set="null" line="202">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis2>
		<getAxis1To public="1" get="inline" set="null" line="213">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis1To>
		<getAxis2To public="1" get="inline" set="null" line="222">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis2To>
		<getLocalAxis1 public="1" get="inline" set="null" line="229">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis1>
		<getLocalAxis2 public="1" get="inline" set="null" line="238">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis2>
		<getLocalAxis1To public="1" get="inline" set="null" line="249">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis1To>
		<getLocalAxis2To public="1" get="inline" set="null" line="258">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis2To>
		<getTranslationalSpringDamper public="1" get="inline" set="null" line="265">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the translational spring and damper settings.</haxe_doc>
		</getTranslationalSpringDamper>
		<getRotationalSpringDamper public="1" get="inline" set="null" line="272">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings.</haxe_doc>
		</getRotationalSpringDamper>
		<getTranslationalLimitMotor public="1" get="inline" set="null" line="279">
			<f a=""><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></f>
			<haxe_doc>* Returns the translational limits and motor settings.</haxe_doc>
		</getTranslationalLimitMotor>
		<getRotationalLimitMotor public="1" get="inline" set="null" line="286">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns the rotational limits and motor settings.</haxe_doc>
		</getRotationalLimitMotor>
		<getAngle public="1" get="inline" set="null" line="293">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the rotation angle in radians.</haxe_doc>
		</getAngle>
		<getTranslation public="1" get="inline" set="null" line="300">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the translation of the joint.</haxe_doc>
		</getTranslation>
		<new public="1" set="method" line="39">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.CylindricalJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new cylindrical joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A cylindrical joint constrains two rigid bodies to share their constraint
 * axes, and restricts relative translation and rotation onto the constraint
 * axis. This joint provides two degrees of freedom. You can enable lower and
 * upper limits, motors, spring and damper effects of both translation and
 * rotation part of the constraint.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.JointConfig" params="" file="src/oimo/dynamics/constraint/joint/JointConfig.hx">
		<rigidBody1 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<haxe_doc>* The first rigid body attached to the joint.</haxe_doc>
		</rigidBody1>
		<rigidBody2 public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<haxe_doc>* The second rigid body attached to the joint.</haxe_doc>
		</rigidBody2>
		<localAnchor1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The local position of the first rigid body's anchor point.</haxe_doc>
		</localAnchor1>
		<localAnchor2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The local position of the second rigid body's anchor point.</haxe_doc>
		</localAnchor2>
		<allowCollision public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to allow the connected rigid bodies to collide each other.</haxe_doc>
		</allowCollision>
		<solverType public="1">
			<x path="Int"/>
			<haxe_doc>* The type of the constraint solver for the joint.
	 *
	 * See `ConstraintSolverType` for details.</haxe_doc>
		</solverType>
		<positionCorrectionAlgorithm public="1">
			<x path="Int"/>
			<haxe_doc>* The type of the position correction algorithm for the joint.
	 *
	 * See `PositionCorrectionAlgorithm` for details.</haxe_doc>
		</positionCorrectionAlgorithm>
		<breakForce public="1">
			<x path="Float"/>
			<haxe_doc>* The joint will be destroyed when magnitude of the constraint force exceeds the value.
	 *
	 * Set `0` for unbreakable joints.</haxe_doc>
		</breakForce>
		<breakTorque public="1">
			<x path="Float"/>
			<haxe_doc>* The joint will be destroyed when magnitude of the constraint torque exceeds the value.
	 *
	 * Set `0` for unbreakable joints.</haxe_doc>
		</breakTorque>
		<_init set="method" line="79"><f a="rb1:rb2:worldAnchor">
	<c path="oimo.dynamics.rigidbody.RigidBody"/>
	<c path="oimo.dynamics.rigidbody.RigidBody"/>
	<c path="oimo.common.Vec3"/>
	<x path="Void"/>
</f></_init>
		<new public="1" set="method" line="65">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A joint configuration is used for constructions of various joints.
 * An instance of any kind of the joint configurations can safely be reused.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.CylindricalJointConfig" params="" file="src/oimo/dynamics/constraint/joint/CylindricalJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local constraint axis.</haxe_doc>
		</localAxis1>
		<localAxis2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second body's local constraint axis.</haxe_doc>
		</localAxis2>
		<translationalLimitMotor public="1">
			<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			<haxe_doc>* The translational limit and motor along the constraint axis of the joint.</haxe_doc>
		</translationalLimitMotor>
		<translationalSpringDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The translational spring and damper along constraint the axis of the joint.</haxe_doc>
		</translationalSpringDamper>
		<rotationalLimitMotor public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<haxe_doc>* The rotational limit and motor along the constraint axis of the joint.</haxe_doc>
		</rotationalLimitMotor>
		<rotationalSpringDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper along the constraint axis of the joint.</haxe_doc>
		</rotationalSpringDamper>
		<init public="1" set="method" line="56">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldAxis">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.CylindricalJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local axes
	 * from the world axis `worldAxis`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A cylindrical joint config is used for constructions of cylindrical joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.GenericJoint" params="" file="src/oimo/dynamics/constraint/joint/GenericJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_translSds public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_translSds>
		<_rotSds public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotSds>
		<_translLms public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_translLms>
		<_rotLms public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotLms>
		<_axisXX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXX>
		<_axisXY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXY>
		<_axisXZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXZ>
		<_axisYX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYX>
		<_axisYY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYY>
		<_axisYZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYZ>
		<_axisZX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZX>
		<_axisZY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZY>
		<_axisZZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZZ>
		<_angleX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleX>
		<_angleY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleY>
		<_angleZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleZ>
		<xSingular><x path="Bool"/></xSingular>
		<ySingular><x path="Bool"/></ySingular>
		<zSingular><x path="Bool"/></zSingular>
		<translationX><x path="Float"/></translationX>
		<translationY><x path="Float"/></translationY>
		<translationZ><x path="Float"/></translationZ>
		<getInfo set="method" line="144"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="255" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="263" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="268" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxisX public="1" get="inline" set="null" line="278">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first (x) rotation axis of the relative Euler angles.</haxe_doc>
		</getAxisX>
		<getAxisY public="1" get="inline" set="null" line="287">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second (y) rotation axis of the relative Euler angles.</haxe_doc>
		</getAxisY>
		<getAxisZ public="1" get="inline" set="null" line="296">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the third (z) rotation axis of the relative Euler angles.</haxe_doc>
		</getAxisZ>
		<getTranslationalSpringDampers public="1" get="inline" set="null" line="305">
			<f a=""><c path="Array"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></c></f>
			<haxe_doc>* Returns the translational spring and damper settings along the first body's constraint basis.</haxe_doc>
		</getTranslationalSpringDampers>
		<getRotationalSpringDampers public="1" get="inline" set="null" line="312">
			<f a=""><c path="Array"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></c></f>
			<haxe_doc>* Returns the rotational spring and damper settings along the rotation axes of the relative x-y-z Euler angles.</haxe_doc>
		</getRotationalSpringDampers>
		<getTranslationalLimitMotors public="1" get="inline" set="null" line="319">
			<f a=""><c path="Array"><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></c></f>
			<haxe_doc>* Returns the translational limits and motor settings along the first body's constraint basis.</haxe_doc>
		</getTranslationalLimitMotors>
		<getRotationalLimitMotors public="1" get="inline" set="null" line="326">
			<f a=""><c path="Array"><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></c></f>
			<haxe_doc>* Returns the rotational limits and motor settings along the rotation axes of the relative x-y-z Euler angles.</haxe_doc>
		</getRotationalLimitMotors>
		<getAngles public="1" get="inline" set="null" line="333">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the relative x-y-z Euler angles.</haxe_doc>
		</getAngles>
		<getTranslations public="1" get="inline" set="null" line="340">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the translations along the first rigid body's constraint basis.</haxe_doc>
		</getTranslations>
		<new public="1" set="method" line="47">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.GenericJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new generic joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A generic joint (a.k.a. 6-DoF joint) constrains two rigid bodies in
 * highly flexible way, so that every translational and rotational axis
 * can be locked, unlocked, springy, or powered by a motor like other
 * joints. Note that rotation angles are measured as x-y-z Euler angles,
 * not as z-x-z Euler angles.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.GenericJointConfig" params="" file="src/oimo/dynamics/constraint/joint/GenericJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localBasis1 public="1">
			<c path="oimo.common.Mat3"/>
			<haxe_doc>* The first body's local constraint basis.</haxe_doc>
		</localBasis1>
		<localBasis2 public="1">
			<c path="oimo.common.Mat3"/>
			<haxe_doc>* The second body's local constraint basis.</haxe_doc>
		</localBasis2>
		<translationalLimitMotors public="1">
			<c path="Array"><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></c>
			<haxe_doc>* The translational limits and motors along the first body's the constraint basis.</haxe_doc>
		</translationalLimitMotors>
		<translationalSpringDampers public="1">
			<c path="Array"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></c>
			<haxe_doc>* The translational springs and dampers along the first body's constraint basis.</haxe_doc>
		</translationalSpringDampers>
		<rotationalLimitMotors public="1">
			<c path="Array"><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></c>
			<haxe_doc>* The rotational limits and motors along the rotation axes of the relative x-y-z Euler angles.</haxe_doc>
		</rotationalLimitMotors>
		<rotationalSpringDampers public="1">
			<c path="Array"><c path="oimo.dynamics.constraint.joint.SpringDamper"/></c>
			<haxe_doc>* The rotational springs and dampers along the rotation axes of the relative x-y-z Euler angles.</haxe_doc>
		</rotationalSpringDampers>
		<init public="1" set="method" line="61">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldBasis1:worldBasis2">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Mat3"/>
				<c path="oimo.common.Mat3"/>
				<c path="oimo.dynamics.constraint.joint.GenericJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local bases
	 * from the world bases `worldBasis1` and `worldBasis2`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="47">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A generic joint config is used for constructions of generic joints.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.JointImpulse" params="" file="src/oimo/dynamics/constraint/joint/JointImpulse.hx">
		<impulse public="1"><x path="Float"/></impulse>
		<impulseM public="1"><x path="Float"/></impulseM>
		<impulseP public="1"><x path="Float"/></impulseP>
		<new public="1" set="method" line="15"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.JointLink" params="" file="src/oimo/dynamics/constraint/joint/JointLink.hx">
		<_prev public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_next public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_joint public="1">
			<c path="oimo.dynamics.constraint.joint.Joint"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_joint>
		<_other public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_other>
		<getContact public="1" set="method" line="25">
			<f a=""><c path="oimo.dynamics.constraint.joint.Joint"/></f>
			<haxe_doc>* Returns the contact the rigid body is attached to.</haxe_doc>
		</getContact>
		<getOther public="1" set="method" line="33">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the other rigid body attached to the constraint. This provides a quick access
	 * from a rigid body to the other one attached to the constraint.</haxe_doc>
		</getOther>
		<getPrev public="1" set="method" line="42">
			<f a=""><c path="oimo.dynamics.constraint.joint.JointLink"/></f>
			<haxe_doc>* Returns the previous joint link in the rigid body.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" set="method" line="51">
			<f a=""><c path="oimo.dynamics.constraint.joint.JointLink"/></f>
			<haxe_doc>* Returns the next joint link in the rigid body.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="18">
			<f a="joint">
				<c path="oimo.dynamics.constraint.joint.Joint"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A joint link is used to build a constraint graph for clustering rigid bodies.
 * In a constraint graph, rigid bodies are nodes and constraints are edges.
 * See also `ContactLink`.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.JointMacro" params="" file="src/oimo/dynamics/constraint/joint/JointMacro.hx"><meta>
	<m n=":dox"><e>hide</e></m>
	<m n=":extern"/>
</meta></class>
	<class path="oimo.dynamics.constraint.joint.JointType" params="" file="src/oimo/dynamics/constraint/joint/JointType.hx">
		<_SPHERICAL public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_SPHERICAL>
		<_REVOLUTE public="1" get="inline" set="null" expr="1" line="9" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_REVOLUTE>
		<_CYLINDRICAL public="1" get="inline" set="null" expr="2" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_CYLINDRICAL>
		<_PRISMATIC public="1" get="inline" set="null" expr="3" line="11" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>3</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_PRISMATIC>
		<_UNIVERSAL public="1" get="inline" set="null" expr="4" line="12" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>4</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_UNIVERSAL>
		<_RAGDOLL public="1" get="inline" set="null" expr="5" line="13" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>5</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_RAGDOLL>
		<_GENERIC public="1" get="inline" set="null" expr="6" line="14" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>6</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_GENERIC>
		<SPHERICAL public="1" set="null" expr="_SPHERICAL" line="21" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_SPHERICAL</e></m></meta>
			<haxe_doc>* Represents a spherical joint.
	 *
	 * See `SphericalJoint` for details.</haxe_doc>
		</SPHERICAL>
		<REVOLUTE public="1" set="null" expr="_REVOLUTE" line="28" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_REVOLUTE</e></m></meta>
			<haxe_doc>* Represents a revolute joint.
	 *
	 * See `RevoluteJoint` for details.</haxe_doc>
		</REVOLUTE>
		<CYLINDRICAL public="1" set="null" expr="_CYLINDRICAL" line="35" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_CYLINDRICAL</e></m></meta>
			<haxe_doc>* Represents a cylindrical joint.
	 *
	 * See `CylindricalJoint` for details.</haxe_doc>
		</CYLINDRICAL>
		<PRISMATIC public="1" set="null" expr="_PRISMATIC" line="42" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_PRISMATIC</e></m></meta>
			<haxe_doc>* Represents a prismatic joint.
	 *
	 * See `PrismaticJoint` for details.</haxe_doc>
		</PRISMATIC>
		<UNIVERSAL public="1" set="null" expr="_UNIVERSAL" line="49" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_UNIVERSAL</e></m></meta>
			<haxe_doc>* Represents a universal joint.
	 *
	 * See `UniversalJoint` for details.</haxe_doc>
		</UNIVERSAL>
		<RAGDOLL public="1" set="null" expr="_RAGDOLL" line="56" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_RAGDOLL</e></m></meta>
			<haxe_doc>* Represents a ragdoll joint.
	 *
	 * See `RagdollJoint` for details.</haxe_doc>
		</RAGDOLL>
		<GENERIC public="1" set="null" expr="_GENERIC" line="63" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_GENERIC</e></m></meta>
			<haxe_doc>* Represents a generic joint.
	 *
	 * See `GenericJoint` for details.</haxe_doc>
		</GENERIC>
		<haxe_doc>* The list of the types of the joints.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.PrismaticJoint" params="" file="src/oimo/dynamics/constraint/joint/PrismaticJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_sd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sd>
		<_lm public="1">
			<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_lm>
		<_basis public="1">
			<c path="oimo.dynamics.constraint.joint.BasisTracker"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basis>
		<translation><x path="Float"/></translation>
		<linearErrorY><x path="Float"/></linearErrorY>
		<linearErrorZ><x path="Float"/></linearErrorZ>
		<angularErrorX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</angularErrorX>
		<angularErrorY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</angularErrorY>
		<angularErrorZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</angularErrorZ>
		<getInfo set="method" line="58"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="158" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="166" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="171" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxis1 public="1" get="inline" set="null" line="181">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis1>
		<getAxis2 public="1" get="inline" set="null" line="190">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis2>
		<getAxis1To public="1" get="inline" set="null" line="201">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis1To>
		<getAxis2To public="1" get="inline" set="null" line="210">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis2To>
		<getLocalAxis1 public="1" get="inline" set="null" line="217">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis1>
		<getLocalAxis2 public="1" get="inline" set="null" line="226">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis2>
		<getLocalAxis1To public="1" get="inline" set="null" line="237">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis1To>
		<getLocalAxis2To public="1" get="inline" set="null" line="246">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis2To>
		<getSpringDamper public="1" get="inline" set="null" line="253">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the translational spring and damper settings.</haxe_doc>
		</getSpringDamper>
		<getLimitMotor public="1" get="inline" set="null" line="260">
			<f a=""><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></f>
			<haxe_doc>* Returns the translational limits and motor settings.</haxe_doc>
		</getLimitMotor>
		<getTranslation public="1" get="inline" set="null" line="267">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the translation of the joint.</haxe_doc>
		</getTranslation>
		<new public="1" set="method" line="36">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.PrismaticJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new prismatic joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A prismatic joint (a.k.a. slider joint) constrains two rigid bodies to
 * share their anchor points and constraint axes, and restricts relative
 * translation onto the constraint axis. This joint provides one degree of
 * freedom. You can enable lower and upper limits, a motor, a spring and
 * damper effect of the translational part of the constraint.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.PrismaticJointConfig" params="" file="src/oimo/dynamics/constraint/joint/PrismaticJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local constraint axis.</haxe_doc>
		</localAxis1>
		<localAxis2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second body's local constraint axis.</haxe_doc>
		</localAxis2>
		<limitMotor public="1">
			<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			<haxe_doc>* The translational limit and motor along the constraint axis of the joint.</haxe_doc>
		</limitMotor>
		<springDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The translational spring and damper along the constraint axis of the joint.</haxe_doc>
		</springDamper>
		<init public="1" set="method" line="44">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldAxis">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.PrismaticJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local axes
	 * from the world axis `worldAxis`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A prismatic joint config is used for constructions of prismatic joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.RagdollJoint" params="" file="src/oimo/dynamics/constraint/joint/RagdollJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_twistSd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_twistSd>
		<_swingSd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_swingSd>
		<_twistLm public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_twistLm>
		<_maxSwingAngle1 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxSwingAngle1>
		<_maxSwingAngle2 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxSwingAngle2>
		<swingAxisX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</swingAxisX>
		<swingAxisY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</swingAxisY>
		<swingAxisZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</swingAxisZ>
		<twistAxisX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</twistAxisX>
		<twistAxisY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</twistAxisY>
		<twistAxisZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</twistAxisZ>
		<linearErrorX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorX>
		<linearErrorY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorY>
		<linearErrorZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorZ>
		<swingError><x path="Float"/></swingError>
		<dummySwingLm><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></dummySwingLm>
		<_swingAngle public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_swingAngle>
		<_twistAngle public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_twistAngle>
		<getInfo set="method" line="84"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="253" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="260" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="265" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxis1 public="1" get="inline" set="null" line="275">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis1>
		<getAxis2 public="1" get="inline" set="null" line="284">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis2>
		<getAxis1To public="1" get="inline" set="null" line="295">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis1To>
		<getAxis2To public="1" get="inline" set="null" line="304">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis2To>
		<getLocalAxis1 public="1" get="inline" set="null" line="311">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis1>
		<getLocalAxis2 public="1" get="inline" set="null" line="320">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis2>
		<getLocalAxis1To public="1" get="inline" set="null" line="331">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis1To>
		<getLocalAxis2To public="1" get="inline" set="null" line="340">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis2To>
		<getTwistSpringDamper public="1" get="inline" set="null" line="347">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings along the twist axis.</haxe_doc>
		</getTwistSpringDamper>
		<getTwistLimitMotor public="1" get="inline" set="null" line="354">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns the rotational limits and motor settings along the twist axis.</haxe_doc>
		</getTwistLimitMotor>
		<getSwingSpringDamper public="1" get="inline" set="null" line="361">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings along the swing axis.</haxe_doc>
		</getSwingSpringDamper>
		<getSwingAxis public="1" get="inline" set="null" line="368">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the swing axis in world coordinates.</haxe_doc>
		</getSwingAxis>
		<getSwingAxisTo public="1" get="inline" set="null" line="379">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the swing axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getSwingAxisTo>
		<getSwingAngle public="1" get="inline" set="null" line="386">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the swing angle in radians.</haxe_doc>
		</getSwingAngle>
		<getTwistAngle public="1" get="inline" set="null" line="393">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the twist angle in radians.</haxe_doc>
		</getTwistAngle>
		<new public="1" set="method" line="49">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.RagdollJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new ragdoll joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A ragdoll joint is designed to simulate ragdoll's limbs. It constrains
 * swing and twist angles between two rigid bodies. The two rigid bodies
 * have constraint axes, and the swing angle is defined by the angle of
 * two constraint axes, while the twist angle is defined by the rotation
 * angle along the two axes. In addition to lower and upper limits of the
 * twist angle, You can set an "elliptic cone limit" of the swing angle
 * by specifying two swing axes (though one of them is automatically
 * computed) and corresponding maximum swing angles. You can also enable a
 * motor of the twist part of the constraint, spring and damper effect of
 * the both swing and twist part of the constraint.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.RagdollJointConfig" params="" file="src/oimo/dynamics/constraint/joint/RagdollJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localTwistAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local twist axis.</haxe_doc>
		</localTwistAxis1>
		<localTwistAxis2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second body's local twist axis.</haxe_doc>
		</localTwistAxis2>
		<localSwingAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local swing axis.
	 *
	 * The second swing axis is also attached to the first body. It is perpendicular to the first swing
	 * axis, and is automatically computed when the joint is created.</haxe_doc>
		</localSwingAxis1>
		<twistSpringDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper along the twist axis of the joint.</haxe_doc>
		</twistSpringDamper>
		<twistLimitMotor public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<haxe_doc>* The rotational limit and motor along the twist axis of the joint.</haxe_doc>
		</twistLimitMotor>
		<swingSpringDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper along the swing axis of the joint.</haxe_doc>
		</swingSpringDamper>
		<maxSwingAngle1 public="1">
			<x path="Float"/>
			<haxe_doc>* The max angle of rotation along the first swing axis.
	 * This value must be positive.</haxe_doc>
		</maxSwingAngle1>
		<maxSwingAngle2 public="1">
			<x path="Float"/>
			<haxe_doc>* The max angle of rotation along the second swing axis.
	 * This value must be positive.</haxe_doc>
		</maxSwingAngle2>
		<init public="1" set="method" line="75">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldTwistAxis:worldSwingAxis">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.RagdollJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local twist axes
	 * from the world twist axis `worldTwistAxis`, local swing axis from the world swing axis
	 * `worldSwingAxis`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="58">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A ragdoll joint config is used for constructions of ragdoll joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.RevoluteJoint" params="" file="src/oimo/dynamics/constraint/joint/RevoluteJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_sd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sd>
		<_lm public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_lm>
		<_basis public="1">
			<c path="oimo.dynamics.constraint.joint.BasisTracker"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_basis>
		<angle><x path="Float"/></angle>
		<angularErrorY><x path="Float"/></angularErrorY>
		<angularErrorZ><x path="Float"/></angularErrorZ>
		<linearErrorX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorX>
		<linearErrorY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorY>
		<linearErrorZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorZ>
		<getInfo set="method" line="55"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="164" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="172" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="177" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxis1 public="1" get="inline" set="null" line="187">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis1>
		<getAxis2 public="1" get="inline" set="null" line="196">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis2>
		<getAxis1To public="1" get="inline" set="null" line="207">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis1To>
		<getAxis2To public="1" get="inline" set="null" line="216">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis2To>
		<getLocalAxis1 public="1" get="inline" set="null" line="223">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis1>
		<getLocalAxis2 public="1" get="inline" set="null" line="232">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis2>
		<getLocalAxis1To public="1" get="inline" set="null" line="243">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis1To>
		<getLocalAxis2To public="1" get="inline" set="null" line="252">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis2To>
		<getSpringDamper public="1" get="inline" set="null" line="259">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings.</haxe_doc>
		</getSpringDamper>
		<getLimitMotor public="1" get="inline" set="null" line="266">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns the rotational limits and motor settings.</haxe_doc>
		</getLimitMotor>
		<getAngle public="1" get="inline" set="null" line="273">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the rotation angle in radians.</haxe_doc>
		</getAngle>
		<new public="1" set="method" line="35">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.RevoluteJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new revolute joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A revolute joint (a.k.a. hinge joint) constrains two rigid bodies to share
 * their anchor points and constraint axes, and restricts relative rotation onto
 * the constraint axis. This joint provides one degree of freedom. You can enable
 * lower and upper limits, a motor, a spring and damper effect of the rotational
 * part of the constraint.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.RevoluteJointConfig" params="" file="src/oimo/dynamics/constraint/joint/RevoluteJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local constraint axis.</haxe_doc>
		</localAxis1>
		<localAxis2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second body's local constraint axis.</haxe_doc>
		</localAxis2>
		<springDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper settings.</haxe_doc>
		</springDamper>
		<limitMotor public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<haxe_doc>* The rotational limits and motor settings.</haxe_doc>
		</limitMotor>
		<init public="1" set="method" line="44">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldAxis">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.RevoluteJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local axes
	 * from the world axis `worldAxis`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="32">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A revolute joint config is used for constructions of revolute joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.RotationalLimitMotor" params="" file="src/oimo/dynamics/constraint/joint/RotationalLimitMotor.hx">
		<lowerLimit public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The lower bound of the limit in radians.
	 *
	 * The limit is disabled if `lowerLimit > upperLimit`.]]></haxe_doc>
		</lowerLimit>
		<upperLimit public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The upper bound of the limit in radians.
	 *
	 * The limit is disabled if `lowerLimit > upperLimit`.]]></haxe_doc>
		</upperLimit>
		<motorSpeed public="1">
			<x path="Float"/>
			<haxe_doc>* The target speed of the motor in usually radians per second.</haxe_doc>
		</motorSpeed>
		<motorTorque public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum torque of the motor in usually newton meters.
	 *
	 * The motor is disabled if `motorTorque <= 0`.]]></haxe_doc>
		</motorTorque>
		<setLimits public="1" set="method" line="46">
			<f a="lower:upper">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			</f>
			<haxe_doc>* Sets limit properties at once and returns `this`.
	 * `this.lowerLimit` is set to `lower`, and `this.upperLimit` is set to `upper`.</haxe_doc>
		</setLimits>
		<setMotor public="1" set="method" line="56">
			<f a="speed:torque">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			</f>
			<haxe_doc>* Sets motor properties at once and returns `this`.
	 * `this.motorSpeed` is set to `speed`, and `this.motorTorque` is set to `torque`.</haxe_doc>
		</setMotor>
		<clone public="1" set="method" line="65">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns a clone of the object.</haxe_doc>
		</clone>
		<new public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Rotational limits and motor settings of a joint.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.SphericalJoint" params="" file="src/oimo/dynamics/constraint/joint/SphericalJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_sd public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sd>
		<getInfo set="method" line="32"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_getVelocitySolverInfo public="1" set="method" line="100" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="105" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getSpringDamper public="1" get="inline" set="null" line="115">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the spring and damper settings.</haxe_doc>
		</getSpringDamper>
		<new public="1" set="method" line="24">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.SphericalJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new spherical joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A spherical joint (a.k.a. ball and socket joint) constrains two rigid bodies to share
 * their anchor points. This joint provides three degrees of freedom. You can enable a
 * spring and damper effect of the constraint.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.SphericalJointConfig" params="" file="src/oimo/dynamics/constraint/joint/SphericalJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<springDamper public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The spring and damper setting of the joint.</haxe_doc>
		</springDamper>
		<init public="1" set="method" line="25">
			<f a="rigidBody1:rigidBody2:worldAnchor">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.SphericalJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="17">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A spherical joint config is used for constructions of spherical joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.joint.SpringDamper" params="" file="src/oimo/dynamics/constraint/joint/SpringDamper.hx">
		<frequency public="1">
			<x path="Float"/>
			<haxe_doc>* The frequency of the spring in Hz.
	 * Set `0.0` to disable the spring and make the constraint totally rigid.</haxe_doc>
		</frequency>
		<dampingRatio public="1">
			<x path="Float"/>
			<haxe_doc>* The damping ratio of the constraint.
	 * Set `1.0` to make the constraint critically dumped.</haxe_doc>
		</dampingRatio>
		<useSymplecticEuler public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to use symplectic Euler method instead of implicit Euler method, to numarically integrate the constraint.
	 * Note that symplectic Euler method conserves energy better than implicit Euler method does, but the constraint will be
	 * unstable under the high frequency.</haxe_doc>
		</useSymplecticEuler>
		<setSpring public="1" set="method" line="39">
			<f a="frequency:dampingRatio">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			</f>
			<haxe_doc>* Sets spring and damper parameters at once and returns `this`.
	 * `this.frequency` is set to `frequency`, and `this.dampingRatio` is set to `dampingRatio`.</haxe_doc>
		</setSpring>
		<setSymplecticEuler public="1" set="method" line="45"><f a="useSymplecticEuler">
	<x path="Bool"/>
	<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
</f></setSymplecticEuler>
		<clone public="1" set="method" line="53">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns a clone of the object.</haxe_doc>
		</clone>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Spring and damper settings of a joint.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.TranslationalLimitMotor" params="" file="src/oimo/dynamics/constraint/joint/TranslationalLimitMotor.hx">
		<lowerLimit public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The lower bound of the limit in usually meters.
	 *
	 * The limit is disabled if `lowerLimit > upperLimit`.]]></haxe_doc>
		</lowerLimit>
		<upperLimit public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The upper bound of the limit in usually meters.
	 *
	 * The limit is disabled if `lowerLimit > upperLimit`.]]></haxe_doc>
		</upperLimit>
		<motorSpeed public="1">
			<x path="Float"/>
			<haxe_doc>* The target speed of the motor in usually meters per second.</haxe_doc>
		</motorSpeed>
		<motorForce public="1">
			<x path="Float"/>
			<haxe_doc><![CDATA[* The maximum force of the motor in usually newtons.
	 *
	 * The motor is disabled if `motorForce <= 0`.]]></haxe_doc>
		</motorForce>
		<setLimits public="1" set="method" line="46">
			<f a="lower:upper">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			</f>
			<haxe_doc>* Sets limit properties at once and returns `this`.
	 * `this.lowerLimit` is set to `lower`, and `this.upperLimit` is set to `upper`.</haxe_doc>
		</setLimits>
		<setMotor public="1" set="method" line="56">
			<f a="speed:force">
				<x path="Float"/>
				<x path="Float"/>
				<c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/>
			</f>
			<haxe_doc>* Sets motor properties at once and returns `this`.
	 * `this.motorSpeed` is set to `speed`, and `this.motorForce` is set to `force`.</haxe_doc>
		</setMotor>
		<clone public="1" set="method" line="65">
			<f a=""><c path="oimo.dynamics.constraint.joint.TranslationalLimitMotor"/></f>
			<haxe_doc>* Returns a clone of the object.</haxe_doc>
		</clone>
		<new public="1" set="method" line="36">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* Translational limits and motor settings of a joint.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.UniversalJoint" params="" file="src/oimo/dynamics/constraint/joint/UniversalJoint.hx">
		<extends path="oimo.dynamics.constraint.joint.Joint"/>
		<_sd1 public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sd1>
		<_sd2 public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sd2>
		<_lm1 public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_lm1>
		<_lm2 public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_lm2>
		<_axisXX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXX>
		<_axisXY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXY>
		<_axisXZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisXZ>
		<_axisYX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYX>
		<_axisYY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYY>
		<_axisYZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisYZ>
		<_axisZX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZX>
		<_axisZY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZY>
		<_axisZZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_axisZZ>
		<_angleX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleX>
		<_angleY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleY>
		<_angleZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angleZ>
		<xSingular><x path="Bool"/></xSingular>
		<ySingular><x path="Bool"/></ySingular>
		<zSingular><x path="Bool"/></zSingular>
		<linearErrorX>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorX>
		<linearErrorY>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorY>
		<linearErrorZ>
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</linearErrorZ>
		<getInfo set="method" line="116"><f a="info:timeStep:isPositionPart">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Bool"/>
	<x path="Void"/>
</f></getInfo>
		<_syncAnchors public="1" set="method" line="233" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_syncAnchors>
		<_getVelocitySolverInfo public="1" set="method" line="241" override="1">
			<f a="timeStep:info">
				<c path="oimo.dynamics.TimeStep"/>
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getVelocitySolverInfo>
		<_getPositionSolverInfo public="1" set="method" line="246" override="1">
			<f a="info">
				<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_getPositionSolverInfo>
		<getAxis1 public="1" get="inline" set="null" line="256">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis1>
		<getAxis2 public="1" get="inline" set="null" line="265">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis in world coordinates.</haxe_doc>
		</getAxis2>
		<getAxis1To public="1" get="inline" set="null" line="276">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis1To>
		<getAxis2To public="1" get="inline" set="null" line="285">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis in world coordinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAxis2To>
		<getLocalAxis1 public="1" get="inline" set="null" line="292">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the first rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis1>
		<getLocalAxis2 public="1" get="inline" set="null" line="301">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the second rigid body's constraint axis relative to the rigid body's transform.</haxe_doc>
		</getLocalAxis2>
		<getLocalAxis1To public="1" get="inline" set="null" line="312">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the first rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis1To>
		<getLocalAxis2To public="1" get="inline" set="null" line="321">
			<f a="axis">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `axis` to the second rigid body's constraint axis relative to the rigid body's transform.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalAxis2To>
		<getSpringDamper1 public="1" get="inline" set="null" line="328">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings along the first body's constraint axis.</haxe_doc>
		</getSpringDamper1>
		<getSpringDamper2 public="1" get="inline" set="null" line="335">
			<f a=""><c path="oimo.dynamics.constraint.joint.SpringDamper"/></f>
			<haxe_doc>* Returns the rotational spring and damper settings along the second body's constraint axis.</haxe_doc>
		</getSpringDamper2>
		<getLimitMotor1 public="1" get="inline" set="null" line="342">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns the rotational limits and motor settings along the first body's constraint axis.</haxe_doc>
		</getLimitMotor1>
		<getLimitMotor2 public="1" get="inline" set="null" line="349">
			<f a=""><c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/></f>
			<haxe_doc>* Returns the rotational limits and motor settings along the second body's constraint axis.</haxe_doc>
		</getLimitMotor2>
		<getAngle1 public="1" get="inline" set="null" line="356">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the rotation angle along the first body's constraint axis.</haxe_doc>
		</getAngle1>
		<getAngle2 public="1" get="inline" set="null" line="363">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the rotation angle along the second body's constraint axis.</haxe_doc>
		</getAngle2>
		<new public="1" set="method" line="43">
			<f a="config">
				<c path="oimo.dynamics.constraint.joint.UniversalJointConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new universal joint by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A universal joint constrains two rigid bodies' constraint axes to be perpendicular
 * to each other. Rigid bodies can rotate along their constraint axes, but cannot along
 * the direction perpendicular to two constraint axes. This joint provides two degrees
 * of freedom. You can enable lower and upper limits, motors, spring and damper effects
 * of the two rotational constraints.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.joint.UniversalJointConfig" params="" file="src/oimo/dynamics/constraint/joint/UniversalJointConfig.hx">
		<extends path="oimo.dynamics.constraint.joint.JointConfig"/>
		<localAxis1 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The first body's local constraint axis.</haxe_doc>
		</localAxis1>
		<localAxis2 public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The second body's local constraint axis.</haxe_doc>
		</localAxis2>
		<springDamper1 public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper along the first body's constraint axis.</haxe_doc>
		</springDamper1>
		<springDamper2 public="1">
			<c path="oimo.dynamics.constraint.joint.SpringDamper"/>
			<haxe_doc>* The rotational spring and damper along the second body's constraint axis.</haxe_doc>
		</springDamper2>
		<limitMotor1 public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<haxe_doc>* The rotational limit and motor along the first body's constraint axis.</haxe_doc>
		</limitMotor1>
		<limitMotor2 public="1">
			<c path="oimo.dynamics.constraint.joint.RotationalLimitMotor"/>
			<haxe_doc>* The rotational limit and motor along the second body's constraint axis.</haxe_doc>
		</limitMotor2>
		<init public="1" set="method" line="56">
			<f a="rigidBody1:rigidBody2:worldAnchor:worldAxis1:worldAxis2">
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.dynamics.rigidbody.RigidBody"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<c path="oimo.dynamics.constraint.joint.UniversalJointConfig"/>
			</f>
			<haxe_doc>* Sets rigid bodies, local anchors from the world anchor `worldAnchor`, local axes
	 * from the world axes `worldAxis1` and `worldAxis2`, and returns `this`.</haxe_doc>
		</init>
		<new public="1" set="method" line="42">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A universal joint config is used for constructions of universal joints.</haxe_doc>
	</class>
	<class path="oimo.dynamics.constraint.solver.ConstraintSolverType" params="" file="src/oimo/dynamics/constraint/solver/ConstraintSolverType.hx">
		<_ITERATIVE public="1" get="inline" set="null" expr="0" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_ITERATIVE>
		<_DIRECT public="1" get="inline" set="null" expr="1" line="11" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_DIRECT>
		<ITERATIVE public="1" set="null" expr="_ITERATIVE" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_ITERATIVE</e></m></meta>
			<haxe_doc>* Iterative constraint solver. Fast and stable enough for common usages.</haxe_doc>
		</ITERATIVE>
		<DIRECT public="1" set="null" expr="_DIRECT" line="22" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_DIRECT</e></m></meta>
			<haxe_doc>* Direct constraint solver. Very stable but not suitable for a situation where fast
	 * computation is required.</haxe_doc>
		</DIRECT>
		<haxe_doc>* The list of the constraint solvers.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.common.ContactSolverMassDataRow" params="" file="src/oimo/dynamics/constraint/solver/common/ContactSolverMassDataRow.hx">
		<invMLinN1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN1X>
		<invMLinN1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN1Y>
		<invMLinN1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN1Z>
		<invMLinN2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN2X>
		<invMLinN2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN2Y>
		<invMLinN2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinN2Z>
		<invMAngN1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN1X>
		<invMAngN1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN1Y>
		<invMAngN1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN1Z>
		<invMAngN2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN2X>
		<invMAngN2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN2Y>
		<invMAngN2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngN2Z>
		<invMLinT1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT1X>
		<invMLinT1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT1Y>
		<invMLinT1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT1Z>
		<invMLinT2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT2X>
		<invMLinT2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT2Y>
		<invMLinT2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinT2Z>
		<invMAngT1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT1X>
		<invMAngT1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT1Y>
		<invMAngT1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT1Z>
		<invMAngT2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT2X>
		<invMAngT2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT2Y>
		<invMAngT2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngT2Z>
		<invMLinB1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB1X>
		<invMLinB1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB1Y>
		<invMLinB1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB1Z>
		<invMLinB2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB2X>
		<invMLinB2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB2Y>
		<invMLinB2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLinB2Z>
		<invMAngB1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB1X>
		<invMAngB1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB1Y>
		<invMAngB1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB1Z>
		<invMAngB2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB2X>
		<invMAngB2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB2Y>
		<invMAngB2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAngB2Z>
		<massN public="1"><x path="Float"/></massN>
		<massTB00 public="1"><x path="Float"/></massTB00>
		<massTB01 public="1"><x path="Float"/></massTB01>
		<massTB10 public="1"><x path="Float"/></massTB10>
		<massTB11 public="1"><x path="Float"/></massTB11>
		<new public="1" set="method" line="38"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.common.JointSolverMassDataRow" params="" file="src/oimo/dynamics/constraint/solver/common/JointSolverMassDataRow.hx">
		<invMLin1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin1X>
		<invMLin1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin1Y>
		<invMLin1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin1Z>
		<invMLin2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin2X>
		<invMLin2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin2Y>
		<invMLin2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMLin2Z>
		<invMAng1X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng1X>
		<invMAng1Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng1Y>
		<invMAng1Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng1Z>
		<invMAng2X public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng2X>
		<invMAng2Y public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng2Y>
		<invMAng2Z public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</invMAng2Z>
		<mass public="1"><x path="Float"/></mass>
		<massWithoutCfm public="1"><x path="Float"/></massWithoutCfm>
		<new public="1" set="method" line="21"><f a=""><x path="Void"/></f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.Boundary" params="" file="src/oimo/dynamics/constraint/solver/direct/Boundary.hx">
		<numBounded public="1"><x path="Int"/></numBounded>
		<iBounded public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></iBounded>
		<signs public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></signs>
		<numUnbounded public="1"><x path="Int"/></numUnbounded>
		<iUnbounded public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></iUnbounded>
		<b><x path="haxe.ds.Vector"><x path="Float"/></x></b>
		<matrixId><x path="Int"/></matrixId>
		<init public="1" set="method" line="41"><f a="buildInfo">
	<c path="oimo.dynamics.constraint.solver.direct.BoundaryBuildInfo"/>
	<x path="Void"/>
</f></init>
		<computeImpulses public="1" set="method" line="59"><f a="info:mass:relVels:impulses:dImpulses:impulseFactor:noCheck">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<c path="oimo.dynamics.constraint.solver.direct.MassMatrix"/>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="haxe.ds.Vector"><x path="Float"/></x>
	<x path="Float"/>
	<x path="Bool"/>
	<x path="Bool"/>
</f></computeImpulses>
		<new public="1" set="method" line="31"><f a="maxRows">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.BoundaryBuildInfo" params="" file="src/oimo/dynamics/constraint/solver/direct/BoundaryBuildInfo.hx">
		<size public="1"><x path="Int"/></size>
		<numBounded public="1"><x path="Int"/></numBounded>
		<iBounded public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></iBounded>
		<signs public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></signs>
		<numUnbounded public="1"><x path="Int"/></numUnbounded>
		<iUnbounded public="1"><x path="haxe.ds.Vector"><x path="Int"/></x></iUnbounded>
		<new public="1" set="method" line="20"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.BoundaryBuilder" params="" file="src/oimo/dynamics/constraint/solver/direct/BoundaryBuilder.hx">
		<numBoundaries public="1"><x path="Int"/></numBoundaries>
		<boundaries public="1"><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.direct.Boundary"/></x></boundaries>
		<maxRows><x path="Int"/></maxRows>
		<bbInfo><c path="oimo.dynamics.constraint.solver.direct.BoundaryBuildInfo"/></bbInfo>
		<buildBoundariesRecursive set="method" line="27"><f a="info:i">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<x path="Int"/>
	<x path="Void"/>
</f></buildBoundariesRecursive>
		<buildBoundaries public="1" get="inline" set="null" line="73"><f a="info">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<x path="Void"/>
</f></buildBoundaries>
		<new public="1" set="method" line="18"><f a="maxRows">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.BoundarySelector" params="" file="src/oimo/dynamics/constraint/solver/direct/BoundarySelector.hx">
		<n><x path="Int"/></n>
		<indices><x path="haxe.ds.Vector"><x path="Int"/></x></indices>
		<tmpIndices><x path="haxe.ds.Vector"><x path="Int"/></x></tmpIndices>
		<getIndex public="1" get="inline" set="null" line="22"><f a="i">
	<x path="Int"/>
	<x path="Int"/>
</f></getIndex>
		<select public="1" get="inline" set="null" line="26"><f a="index">
	<x path="Int"/>
	<x path="Void"/>
</f></select>
		<setSize public="1" get="inline" set="null" line="43">
			<f a="size">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Makes first n elements the permutation of {0, 1, ... , n-1}</haxe_doc>
		</setSize>
		<new public="1" set="method" line="13"><f a="n">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal Class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.DirectJointConstraintSolver" params="" file="src/oimo/dynamics/constraint/solver/direct/DirectJointConstraintSolver.hx">
		<extends path="oimo.dynamics.constraint.ConstraintSolver"/>
		<info><c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/></info>
		<massData><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.common.JointSolverMassDataRow"/></x></massData>
		<relVels><x path="haxe.ds.Vector"><x path="Float"/></x></relVels>
		<impulses><x path="haxe.ds.Vector"><x path="Float"/></x></impulses>
		<dImpulses><x path="haxe.ds.Vector"><x path="Float"/></x></dImpulses>
		<dTotalImpulses><x path="haxe.ds.Vector"><x path="Float"/></x></dTotalImpulses>
		<joint><c path="oimo.dynamics.constraint.joint.Joint"/></joint>
		<massMatrix><c path="oimo.dynamics.constraint.solver.direct.MassMatrix"/></massMatrix>
		<boundaryBuilder><c path="oimo.dynamics.constraint.solver.direct.BoundaryBuilder"/></boundaryBuilder>
		<velBoundarySelector><c path="oimo.dynamics.constraint.solver.direct.BoundarySelector"/></velBoundarySelector>
		<posBoundarySelector><c path="oimo.dynamics.constraint.solver.direct.BoundarySelector"/></posBoundarySelector>
		<preSolveVelocity public="1" set="method" line="184" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolveVelocity>
		<warmStart public="1" set="method" line="201" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></warmStart>
		<solveVelocity public="1" set="method" line="242" override="1"><f a=""><x path="Void"/></f></solveVelocity>
		<postSolveVelocity public="1" set="method" line="340" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></postSolveVelocity>
		<preSolvePosition public="1" set="method" line="381" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolvePosition>
		<solvePositionSplitImpulse public="1" set="method" line="390" override="1"><f a=""><x path="Void"/></f></solvePositionSplitImpulse>
		<solvePositionNgs public="1" set="method" line="455" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></solvePositionNgs>
		<postSolve public="1" set="method" line="507" override="1"><f a=""><x path="Void"/></f></postSolve>
		<new public="1" set="method" line="39">
			<f a="joint">
				<c path="oimo.dynamics.constraint.joint.Joint"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* The direct solver of a mixed linear complementality problem (MLCP) for
 * joint constraints.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.direct.MassMatrix" params="" file="src/oimo/dynamics/constraint/solver/direct/MassMatrix.hx">
		<_size public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_size>
		<_invMass public="1">
			<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invMass>
		<_invMassWithoutCfm public="1">
			<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invMassWithoutCfm>
		<_massData public="1">
			<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.common.JointSolverMassDataRow"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_massData>
		<_cachedSubmatrices public="1">
			<x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_cachedSubmatrices>
		<_cacheComputed public="1">
			<x path="haxe.ds.Vector"><x path="Bool"/></x>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_cacheComputed>
		<_maxSubmatrixId public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_maxSubmatrixId>
		<tmpMatrix><x path="haxe.ds.Vector"><x path="haxe.ds.Vector"><x path="Float"/></x></x></tmpMatrix>
		<computeSubmatrix set="method" line="72"><f a="id:indices:size">
	<x path="Int"/>
	<x path="haxe.ds.Vector"><x path="Int"/></x>
	<x path="Int"/>
	<x path="Void"/>
</f></computeSubmatrix>
		<computeInvMass public="1" set="method" line="146"><f a="info:massData">
	<c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/>
	<x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.common.JointSolverMassDataRow"/></x>
	<x path="Void"/>
</f></computeInvMass>
		<new public="1" set="method" line="31"><f a="size">
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>* Internal class</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.pgs.PgsContactConstraintSolver" params="" file="src/oimo/dynamics/constraint/solver/pgs/PgsContactConstraintSolver.hx">
		<extends path="oimo.dynamics.constraint.ConstraintSolver"/>
		<constraint><c path="oimo.dynamics.constraint.contact.ContactConstraint"/></constraint>
		<info><c path="oimo.dynamics.constraint.info.contact.ContactSolverInfo"/></info>
		<massData><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.common.ContactSolverMassDataRow"/></x></massData>
		<preSolveVelocity public="1" set="method" line="44" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolveVelocity>
		<warmStart public="1" set="method" line="102" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></warmStart>
		<solveVelocity public="1" set="method" line="150" override="1"><f a=""><x path="Void"/></f></solveVelocity>
		<preSolvePosition public="1" set="method" line="282" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolvePosition>
		<solvePositionSplitImpulse public="1" set="method" line="291" override="1"><f a=""><x path="Void"/></f></solvePositionSplitImpulse>
		<solvePositionNgs public="1" set="method" line="336" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></solvePositionNgs>
		<postSolve public="1" set="method" line="382" override="1"><f a=""><x path="Void"/></f></postSolve>
		<new public="1" set="method" line="31">
			<f a="constraint">
				<c path="oimo.dynamics.constraint.contact.ContactConstraint"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A contact constraint solver using projected Gauss-Seidel (sequential impulse).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.constraint.solver.pgs.PgsJointConstraintSolver" params="" file="src/oimo/dynamics/constraint/solver/pgs/PgsJointConstraintSolver.hx">
		<extends path="oimo.dynamics.constraint.ConstraintSolver"/>
		<joint><c path="oimo.dynamics.constraint.joint.Joint"/></joint>
		<info><c path="oimo.dynamics.constraint.info.joint.JointSolverInfo"/></info>
		<massData><x path="haxe.ds.Vector"><c path="oimo.dynamics.constraint.solver.common.JointSolverMassDataRow"/></x></massData>
		<preSolveVelocity public="1" set="method" line="36" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolveVelocity>
		<warmStart public="1" set="method" line="88" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></warmStart>
		<solveVelocity public="1" set="method" line="137" override="1"><f a=""><x path="Void"/></f></solveVelocity>
		<postSolveVelocity public="1" set="method" line="229" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></postSolveVelocity>
		<preSolvePosition public="1" set="method" line="291" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></preSolvePosition>
		<solvePositionSplitImpulse public="1" set="method" line="300" override="1"><f a=""><x path="Void"/></f></solvePositionSplitImpulse>
		<solvePositionNgs public="1" set="method" line="349" override="1"><f a="timeStep">
	<c path="oimo.dynamics.TimeStep"/>
	<x path="Void"/>
</f></solvePositionNgs>
		<postSolve public="1" set="method" line="400" override="1"><f a=""><x path="Void"/></f></postSolve>
		<new public="1" set="method" line="24">
			<f a="joint">
				<c path="oimo.dynamics.constraint.joint.Joint"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</new>
		<haxe_doc>* A joint constraint solver using projected Gauss-Seidel (sequential impulse).</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":build"><e>oimo.m.B.bu()</e></m>
		</meta>
	</class>
	<class path="oimo.dynamics.rigidbody.MassData" params="" file="src/oimo/dynamics/rigidbody/MassData.hx">
		<mass public="1">
			<x path="Float"/>
			<haxe_doc>* Mass. `0` for a non-dynamic rigid body.</haxe_doc>
		</mass>
		<localInertia public="1">
			<c path="oimo.common.Mat3"/>
			<haxe_doc>* Inertia tensor in local space. Zero matrix for a non-dynamic rigid body.</haxe_doc>
		</localInertia>
		<new public="1" set="method" line="21">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* This class holds mass and moment of inertia for a rigid body.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="oimo.dynamics.rigidbody.RigidBody" params="" file="src/oimo/dynamics/rigidbody/RigidBody.hx">
		<_next public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_prev public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_shapeList public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_shapeList>
		<_shapeListLast public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_shapeListLast>
		<_numShapes public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numShapes>
		<_velX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_velX>
		<_velY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_velY>
		<_velZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_velZ>
		<_angVelX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angVelX>
		<_angVelY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angVelY>
		<_angVelZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angVelZ>
		<_pseudoVelX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pseudoVelX>
		<_pseudoVelY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pseudoVelY>
		<_pseudoVelZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_pseudoVelZ>
		<_angPseudoVelX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angPseudoVelX>
		<_angPseudoVelY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angPseudoVelY>
		<_angPseudoVelZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angPseudoVelZ>
		<_ptransform public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_ptransform>
		<_transform public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_transform>
		<_type public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_type>
		<_sleepTime public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sleepTime>
		<_sleeping public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_sleeping>
		<_autoSleep public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_autoSleep>
		<_mass public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_mass>
		<_invMass public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invMass>
		<_localInertia00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia00>
		<_localInertia01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia01>
		<_localInertia02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia02>
		<_localInertia10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia10>
		<_localInertia11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia11>
		<_localInertia12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia12>
		<_localInertia20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia20>
		<_localInertia21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia21>
		<_localInertia22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localInertia22>
		<_rotFactor public="1">
			<c path="oimo.common.Vec3"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rotFactor>
		<_invLocalInertia00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia00>
		<_invLocalInertia01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia01>
		<_invLocalInertia02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia02>
		<_invLocalInertia10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia10>
		<_invLocalInertia11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia11>
		<_invLocalInertia12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia12>
		<_invLocalInertia20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia20>
		<_invLocalInertia21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia21>
		<_invLocalInertia22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertia22>
		<_invLocalInertiaWithoutRotFactor00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor00>
		<_invLocalInertiaWithoutRotFactor01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor01>
		<_invLocalInertiaWithoutRotFactor02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor02>
		<_invLocalInertiaWithoutRotFactor10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor10>
		<_invLocalInertiaWithoutRotFactor11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor11>
		<_invLocalInertiaWithoutRotFactor12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor12>
		<_invLocalInertiaWithoutRotFactor20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor20>
		<_invLocalInertiaWithoutRotFactor21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor21>
		<_invLocalInertiaWithoutRotFactor22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invLocalInertiaWithoutRotFactor22>
		<_invInertia00 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia00>
		<_invInertia01 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia01>
		<_invInertia02 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia02>
		<_invInertia10 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia10>
		<_invInertia11 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia11>
		<_invInertia12 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia12>
		<_invInertia20 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia20>
		<_invInertia21 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia21>
		<_invInertia22 public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_invInertia22>
		<_linearDamping public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_linearDamping>
		<_angularDamping public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angularDamping>
		<_forceX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_forceX>
		<_forceY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_forceY>
		<_forceZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_forceZ>
		<_torqueX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_torqueX>
		<_torqueY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_torqueY>
		<_torqueZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_torqueZ>
		<_linearContactImpulseX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_linearContactImpulseX>
		<_linearContactImpulseY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_linearContactImpulseY>
		<_linearContactImpulseZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_linearContactImpulseZ>
		<_angularContactImpulseX public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angularContactImpulseX>
		<_angularContactImpulseY public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angularContactImpulseY>
		<_angularContactImpulseZ public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_angularContactImpulseZ>
		<_world public="1">
			<c path="oimo.dynamics.World"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_world>
		<_contactLinkList public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactLinkList>
		<_contactLinkListLast public="1">
			<c path="oimo.dynamics.ContactLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactLinkListLast>
		<_numContactLinks public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numContactLinks>
		<_jointLinkList public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_jointLinkList>
		<_jointLinkListLast public="1">
			<c path="oimo.dynamics.constraint.joint.JointLink"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_jointLinkListLast>
		<_numJointLinks public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_numJointLinks>
		<_addedToIsland public="1">
			<x path="Bool"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_addedToIsland>
		<_gravityScale public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_gravityScale>
		<userData public="1">
			<x path="Any"/>
			<haxe_doc>* Extra field that users can use for their own purposes.</haxe_doc>
		</userData>
		<_integrate public="1" set="method" line="142">
			<f a="dt">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_integrate>
		<_integratePseudoVelocity public="1" set="method" line="183">
			<f a=""><x path="Void"/></f>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_integratePseudoVelocity>
		<updateMass set="method" line="284"><f a=""><x path="Void"/></f></updateMass>
		<getPosition public="1" get="inline" set="null" line="364">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the world position of the rigid body.</haxe_doc>
		</getPosition>
		<getPositionTo public="1" get="inline" set="null" line="375">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `position` to the world position of the rigid body.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getPositionTo>
		<setPosition public="1" get="inline" set="null" line="382">
			<f a="position">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the world position of the rigid body to `position`.</haxe_doc>
		</setPosition>
		<translate public="1" get="inline" set="null" line="390">
			<f a="translation">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Translates the position of the rigid body by `translation`.</haxe_doc>
		</translate>
		<getRotation public="1" get="inline" set="null" line="400">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the rotation matrix of the rigid body.</haxe_doc>
		</getRotation>
		<getRotationTo public="1" get="inline" set="null" line="411">
			<f a="rotation">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `rotation` to the rotation matrix of the rigid body.
	 *
	 * This does not create a new instance of `Mat3`.</haxe_doc>
		</getRotationTo>
		<setRotation public="1" get="inline" set="null" line="418">
			<f a="rotation">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rotation matrix of the rigid body to `rotation`.</haxe_doc>
		</setRotation>
		<setRotationXyz public="1" get="inline" set="null" line="428">
			<f a="eulerAngles">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rotation of the rigid body by Euler angles `eulerAngles` in radians.</haxe_doc>
		</setRotationXyz>
		<rotate public="1" get="inline" set="null" line="440">
			<f a="rotation">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Rotates the rigid body by the rotation matrix `rotation`.</haxe_doc>
		</rotate>
		<rotateXyz public="1" get="inline" set="null" line="452">
			<f a="eulerAngles">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Rotates the rigid body by Euler angles `eulerAngles` in radians.</haxe_doc>
		</rotateXyz>
		<getOrientation public="1" get="inline" set="null" line="466">
			<f a=""><c path="oimo.common.Quat"/></f>
			<haxe_doc>* Returns the rotation of the rigid body as a quaternion.</haxe_doc>
		</getOrientation>
		<getOrientationTo public="1" get="inline" set="null" line="479">
			<f a="orientation">
				<c path="oimo.common.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `orientation` to the rotation quaternion of the rigid body.
	 *
	 * This does not create a new instance of `Quat`.</haxe_doc>
		</getOrientationTo>
		<setOrientation public="1" get="inline" set="null" line="488">
			<f a="quaternion">
				<c path="oimo.common.Quat"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rotation of the rigid body from a quaternion `quaternion`.</haxe_doc>
		</setOrientation>
		<getTransform public="1" get="inline" set="null" line="500">
			<f a=""><c path="oimo.common.Transform"/></f>
			<haxe_doc>* Returns the transform of the rigid body.</haxe_doc>
		</getTransform>
		<getTransformTo public="1" get="inline" set="null" line="509">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `transform` to the transform of the rigid body.
	 *
	 * This does not create a new instance of `Transform`.</haxe_doc>
		</getTransformTo>
		<setTransform public="1" get="inline" set="null" line="518">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the transform of the rigid body to `transform`.
	 *
	 * This does not keep any references to `transform`.</haxe_doc>
		</setTransform>
		<getMass public="1" get="inline" set="null" line="531">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the mass of the rigid body.
	 *
	 * If the rigid body has infinite mass, `0` will be returned.</haxe_doc>
		</getMass>
		<getLocalInertia public="1" get="inline" set="null" line="538">
			<f a=""><c path="oimo.common.Mat3"/></f>
			<haxe_doc>* Returns the moment of inertia tensor in local space.</haxe_doc>
		</getLocalInertia>
		<getLocalInertiaTo public="1" get="inline" set="null" line="549">
			<f a="inertia">
				<c path="oimo.common.Mat3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `inertia` to the moment of inertia tensor in local space.
	 *
	 * This does not create a new instance of `Mat3`</haxe_doc>
		</getLocalInertiaTo>
		<getMassData public="1" get="inline" set="null" line="556">
			<f a=""><c path="oimo.dynamics.rigidbody.MassData"/></f>
			<haxe_doc>* Returns the mass data of the rigid body.</haxe_doc>
		</getMassData>
		<getMassDataTo public="1" get="inline" set="null" line="568">
			<f a="massData">
				<c path="oimo.dynamics.rigidbody.MassData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `massData` to the mass data of the rigid body.
	 *
	 * This does not create a new instance of `MassData`.</haxe_doc>
		</getMassDataTo>
		<setMassData public="1" get="inline" set="null" line="580">
			<f a="massData">
				<c path="oimo.dynamics.rigidbody.MassData"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the mass and moment of inertia of the rigid body by the mass data `massData`.
	 * The properties set by this will be overwritten when
	 *
	 * - some shapes are added or removed
	 * - the type of the rigid body is changed</haxe_doc>
		</setMassData>
		<getRotationFactor public="1" get="inline" set="null" line="590">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the rotation factor of the rigid body.</haxe_doc>
		</getRotationFactor>
		<setRotationFactor public="1" get="inline" set="null" line="601">
			<f a="rotationFactor">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rotation factor of the rigid body to `rotationFactor`.
	 *
	 * This changes moment of inertia internally, so that the change of
	 * angular velocity in **global space** along X, Y and Z axis will scale by `rotationFactor.x`,
	 * `rotationFactor.y` and `rotationFactor.z` times respectively.</haxe_doc>
		</setRotationFactor>
		<getLinearVelocity public="1" get="inline" set="null" line="611">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the linear velocity of the rigid body.</haxe_doc>
		</getLinearVelocity>
		<getLinearVelocityTo public="1" get="inline" set="null" line="622">
			<f a="linearVelocity">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `linearVelocity` to the linear velocity of the rigid body.
	 *
	 * This does not create a new intrance of `Vec3`.</haxe_doc>
		</getLinearVelocityTo>
		<setLinearVelocity public="1" get="inline" set="null" line="629">
			<f a="linearVelocity">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the linear velocity of the rigid body.</haxe_doc>
		</setLinearVelocity>
		<getAngularVelocity public="1" get="inline" set="null" line="641">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the angular velocity of the rigid body.</haxe_doc>
		</getAngularVelocity>
		<getAngularVelocityTo public="1" get="inline" set="null" line="652">
			<f a="angularVelocity">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `angularVelocity` to the angular velocity of the rigid body.
	 *
	 * This does not create a new intrance of `Vec3`.</haxe_doc>
		</getAngularVelocityTo>
		<setAngularVelocity public="1" get="inline" set="null" line="659">
			<f a="angularVelocity">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the angular velocity of the rigid body.</haxe_doc>
		</setAngularVelocity>
		<addLinearVelocity public="1" get="inline" set="null" line="671">
			<f a="linearVelocityChange">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds `linearVelocityChange` to the linear velcity of the rigid body.</haxe_doc>
		</addLinearVelocity>
		<addAngularVelocity public="1" get="inline" set="null" line="683">
			<f a="angularVelocityChange">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds `angularVelocityChange` to the angular velcity of the rigid body.</haxe_doc>
		</addAngularVelocity>
		<applyImpulse public="1" set="method" line="697">
			<f a="impulse:positionInWorld">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the impulse `impulse` to the rigid body at `positionInWorld` in world position.
	 *
	 * This changes both the linear velocity and the angular velocity.</haxe_doc>
		</applyImpulse>
		<applyLinearImpulse public="1" set="method" line="720">
			<f a="impulse">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the linear impulse `impulse` to the rigid body.
	 *
	 * This does not change the angular velocity.</haxe_doc>
		</applyLinearImpulse>
		<applyAngularImpulse public="1" set="method" line="732">
			<f a="impulse">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the angular impulse `impulse` to the rigid body.
	 *
	 * This does not change the linear velocity.</haxe_doc>
		</applyAngularImpulse>
		<applyForce public="1" set="method" line="743">
			<f a="force:positionInWorld">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the force `force` to `positionInWorld` in world position.</haxe_doc>
		</applyForce>
		<applyForceToCenter public="1" set="method" line="763">
			<f a="force">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the force `force` to the center of mass.</haxe_doc>
		</applyForceToCenter>
		<applyTorque public="1" set="method" line="775">
			<f a="torque">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Applies the torque `torque`.</haxe_doc>
		</applyTorque>
		<getLinearContactImpulse public="1" get="inline" set="null" line="787">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the total linear impulse applied by contact constraints.</haxe_doc>
		</getLinearContactImpulse>
		<getLinearContactImpulseTo public="1" get="inline" set="null" line="798">
			<f a="linearContactImpulse">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `linearContactImpulse` to the total linear impulse applied by contact constraints.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLinearContactImpulseTo>
		<getAngularContactImpulse public="1" get="inline" set="null" line="805">
			<f a=""><c path="oimo.common.Vec3"/></f>
			<haxe_doc>* Returns the total angular impulse applied by contact constraints.</haxe_doc>
		</getAngularContactImpulse>
		<getAngularContactImpulseTo public="1" get="inline" set="null" line="816">
			<f a="angularContactImpulse">
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `angularContactImpulse` to the total angular impulse applied by contact constraints.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getAngularContactImpulseTo>
		<getGravityScale public="1" get="inline" set="null" line="823">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the gravity scaling factor of the rigid body.</haxe_doc>
		</getGravityScale>
		<setGravityScale public="1" get="inline" set="null" line="832">
			<f a="gravityScale">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the gravity scaling factor of the rigid body to `gravityScale`.
	 *
	 * If `0` is set, the rigid body will not be affected by gravity.</haxe_doc>
		</setGravityScale>
		<getLocalPoint public="1" get="inline" set="null" line="840">
			<f a="worldPoint">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the local coordinates of the point `worldPoint` in world coodinates.</haxe_doc>
		</getLocalPoint>
		<getLocalPointTo public="1" get="inline" set="null" line="855">
			<f a="worldPoint:localPoint">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `localPoint` to the local coordinates of the point `worldPoint` in world coodinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalPointTo>
		<getLocalVector public="1" get="inline" set="null" line="866">
			<f a="worldVector">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the local coordinates of the vector `worldVector` in world coodinates.</haxe_doc>
		</getLocalVector>
		<getLocalVectorTo public="1" get="inline" set="null" line="880">
			<f a="worldVector:localVector">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `localVector` to the local coordinates of the vector `worldVector` in world coodinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getLocalVectorTo>
		<getWorldPoint public="1" get="inline" set="null" line="890">
			<f a="localPoint">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the world coordinates of the point `localPoint` in local coodinates.</haxe_doc>
		</getWorldPoint>
		<getWorldPointTo public="1" get="inline" set="null" line="905">
			<f a="localPoint:worldPoint">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `worldPoint` to the world coordinates of the point `localPoint` in local coodinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getWorldPointTo>
		<getWorldVector public="1" get="inline" set="null" line="916">
			<f a="localVector">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
			</f>
			<haxe_doc>* Returns the world coordinates of the vector `localVector` in local coodinates.</haxe_doc>
		</getWorldVector>
		<getWorldVectorTo public="1" get="inline" set="null" line="930">
			<f a="localVector:worldVector">
				<c path="oimo.common.Vec3"/>
				<c path="oimo.common.Vec3"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `worldVector` to the world coordinates of the vector `localVector` in local coodinates.
	 *
	 * This does not create a new instance of `Vec3`.</haxe_doc>
		</getWorldVectorTo>
		<getNumShapes public="1" get="inline" set="null" line="940">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the shapes added.</haxe_doc>
		</getNumShapes>
		<getShapeList public="1" get="inline" set="null" line="947">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the list of the shapes of the rigid body.</haxe_doc>
		</getShapeList>
		<getNumContactLinks public="1" get="inline" set="null" line="954">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the contact lists the rigid body is involved.</haxe_doc>
		</getNumContactLinks>
		<getContactLinkList public="1" get="inline" set="null" line="961">
			<f a=""><c path="oimo.dynamics.ContactLink"/></f>
			<haxe_doc>* Returns the list of the contact links the rigid body is involved.</haxe_doc>
		</getContactLinkList>
		<getNumJointLinks public="1" get="inline" set="null" line="968">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the number of the joint links the rigid body is attached.</haxe_doc>
		</getNumJointLinks>
		<getJointLinkList public="1" get="inline" set="null" line="975">
			<f a=""><c path="oimo.dynamics.constraint.joint.JointLink"/></f>
			<haxe_doc>* Returns the list of the joint links the rigid body is attached.</haxe_doc>
		</getJointLinkList>
		<addShape public="1" set="method" line="982">
			<f a="shape">
				<c path="oimo.dynamics.rigidbody.Shape"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Adds the shape to the rigid body.</haxe_doc>
		</addShape>
		<removeShape public="1" set="method" line="999">
			<f a="shape">
				<c path="oimo.dynamics.rigidbody.Shape"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Removes the shape from the rigid body.</haxe_doc>
		</removeShape>
		<getType public="1" get="inline" set="null" line="1018">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the rigid body's type of behaviour.
	 *
	 * See `RigidBodyType` class for details.</haxe_doc>
		</getType>
		<setType public="1" set="method" line="1027">
			<f a="type">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rigid body's type of behaviour.
	 *
	 * See `RigidBodyType` class for details.</haxe_doc>
		</setType>
		<wakeUp public="1" get="inline" set="null" line="1037">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets the rigid body's sleep flag false.
	 *
	 * This also resets the sleeping timer of the rigid body.</haxe_doc>
		</wakeUp>
		<sleep public="1" get="inline" set="null" line="1047">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Sets the rigid body's sleep flag true.
	 *
	 * This also resets the sleeping timer of the rigid body.</haxe_doc>
		</sleep>
		<isSleeping public="1" get="inline" set="null" line="1055">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>* Returns whether the rigid body is sleeping.</haxe_doc>
		</isSleeping>
		<getSleepTime public="1" get="inline" set="null" line="1063">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns how long the rigid body is stopping moving. This returns `0` if the body
	 * has already slept.</haxe_doc>
		</getSleepTime>
		<setAutoSleep public="1" get="inline" set="null" line="1072">
			<f a="autoSleepEnabled">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the rigid body's auto sleep flag.
	 *
	 * If auto sleep is enabled, the rigid body will automatically sleep when needed.</haxe_doc>
		</setAutoSleep>
		<getLinearDamping public="1" get="inline" set="null" line="1080">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the linear damping.</haxe_doc>
		</getLinearDamping>
		<setLinearDamping public="1" get="inline" set="null" line="1087">
			<f a="damping">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the linear damping to `damping`.</haxe_doc>
		</setLinearDamping>
		<getAngularDamping public="1" get="inline" set="null" line="1094">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the angular damping.</haxe_doc>
		</getAngularDamping>
		<setAngularDamping public="1" get="inline" set="null" line="1101">
			<f a="damping">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the angular damping to `damping`.</haxe_doc>
		</setAngularDamping>
		<getPrev public="1" get="inline" set="null" line="1110">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the previous rigid body in the world.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" get="inline" set="null" line="1119">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the next rigid body in the world.
	 *
	 * If the next one does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="82">
			<f a="config">
				<c path="oimo.dynamics.rigidbody.RigidBodyConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new rigid body by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A rigid body. To add a rigid body to a physics world, create a `RigidBody`
 * instance, create and add shapes via `RigidBody.addShape`, and add the rigid
 * body to the physics world through `World.addRigidBody`. Rigid bodies have
 * three motion types: dynamic, static, and kinematic. See `RigidBodyType` for
 * details of motion types.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.rigidbody.RigidBodyConfig" params="" file="src/oimo/dynamics/rigidbody/RigidBodyConfig.hx">
		<position public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The world position of the rigid body's center of gravity.</haxe_doc>
		</position>
		<rotation public="1">
			<c path="oimo.common.Mat3"/>
			<haxe_doc>* The rotation matrix of the rigid body.</haxe_doc>
		</rotation>
		<linearVelocity public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The initial value of the rigid body's linear velocity.</haxe_doc>
		</linearVelocity>
		<angularVelocity public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The initial value of the rigid body's angular velocity.</haxe_doc>
		</angularVelocity>
		<type public="1">
			<x path="Int"/>
			<haxe_doc>* The rigid body's motion type. See `RigidBodyType` for details.</haxe_doc>
		</type>
		<autoSleep public="1">
			<x path="Bool"/>
			<haxe_doc>* Whether to automatically sleep the rigid body when it stops moving
	 * for a certain period of time, namely `Setting.sleepingTimeThreshold`.</haxe_doc>
		</autoSleep>
		<linearDamping public="1">
			<x path="Float"/>
			<haxe_doc>* The damping coefficient of the linear velocity. Set positive values to
	 * gradually reduce the linear velocity.</haxe_doc>
		</linearDamping>
		<angularDamping public="1">
			<x path="Float"/>
			<haxe_doc>* The damping coefficient of the angular velocity. Set positive values to
	 * gradually reduce the angular velocity.</haxe_doc>
		</angularDamping>
		<new public="1" set="method" line="57">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A rigid body configuration is used for constructions of rigid bodies. An instance of this
 * class can safely be reused, as a rigid body will not have any references to a field of
 * this class.</haxe_doc>
	</class>
	<class path="oimo.dynamics.rigidbody.RigidBodyType" params="" file="src/oimo/dynamics/rigidbody/RigidBodyType.hx">
		<_DYNAMIC public="1" get="inline" set="null" expr="0" line="8" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_DYNAMIC>
		<_STATIC public="1" get="inline" set="null" expr="1" line="9" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>1</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_STATIC>
		<_KINEMATIC public="1" get="inline" set="null" expr="2" line="10" static="1">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>2</e></m>
				<m n=":dox"><e>hide</e></m>
			</meta>
		</_KINEMATIC>
		<DYNAMIC public="1" set="null" expr="_DYNAMIC" line="16" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_DYNAMIC</e></m></meta>
			<haxe_doc>* Represents a dynamic rigid body. A dynamic rigid body has finite mass (and usually inertia
	 * tensor). The rigid body is affected by gravity, or by constraints the rigid body is involved.</haxe_doc>
		</DYNAMIC>
		<STATIC public="1" set="null" expr="_STATIC" line="23" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_STATIC</e></m></meta>
			<haxe_doc>* Represents a static rigid body. A static rigid body has zero velocities and infinite mass
	 * and inertia tensor. The rigid body is not affected by any force or impulse, such as gravity,
	 * constraints, or external forces or impulses added by an user.</haxe_doc>
		</STATIC>
		<KINEMATIC public="1" set="null" expr="_KINEMATIC" line="30" static="1">
			<x path="Int"/>
			<meta><m n=":value"><e>_KINEMATIC</e></m></meta>
			<haxe_doc>* Represents a kinematic rigid body. A kinematic rigid body is similar to a static one, except
	 * that it can have non-zero linear and angular velocities. This is useful for overlapping rigid
	 * bodies to pre-computed motions.</haxe_doc>
		</KINEMATIC>
		<haxe_doc>* The list of a rigid body's motion types.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.rigidbody.Shape" params="" file="src/oimo/dynamics/rigidbody/Shape.hx">
		<_id public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_id>
		<_prev public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_prev>
		<_next public="1">
			<c path="oimo.dynamics.rigidbody.Shape"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_next>
		<_rigidBody public="1">
			<c path="oimo.dynamics.rigidbody.RigidBody"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_rigidBody>
		<_geom public="1">
			<c path="oimo.collision.geometry.Geometry"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_geom>
		<_localTransform public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_localTransform>
		<_ptransform public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_ptransform>
		<_transform public="1">
			<c path="oimo.common.Transform"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_transform>
		<_restitution public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_restitution>
		<_friction public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_friction>
		<_density public="1">
			<x path="Float"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_density>
		<_aabb public="1">
			<c path="oimo.collision.geometry.Aabb"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_aabb>
		<_proxy public="1">
			<c path="oimo.collision.broadphase.Proxy"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_proxy>
		<_collisionGroup public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_collisionGroup>
		<_collisionMask public="1">
			<x path="Int"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_collisionMask>
		<_contactCallback public="1">
			<c path="oimo.dynamics.callback.ContactCallback"/>
			<meta><m n=":dox"><e>hide</e></m></meta>
		</_contactCallback>
		<displacement><c path="oimo.common.Vec3"/></displacement>
		<userData public="1">
			<x path="Any"/>
			<haxe_doc>* Extra field that users can use for their own purposes.</haxe_doc>
		</userData>
		<getFriction public="1" get="inline" set="null" line="107">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the coefficient of friction.</haxe_doc>
		</getFriction>
		<setFriction public="1" get="inline" set="null" line="114">
			<f a="friction">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the coefficient of friction to `friction`.</haxe_doc>
		</setFriction>
		<getRestitution public="1" get="inline" set="null" line="121">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the coefficient of restitution.</haxe_doc>
		</getRestitution>
		<setRestitution public="1" get="inline" set="null" line="128">
			<f a="restitution">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the coefficient of restitution to `restitution`.</haxe_doc>
		</setRestitution>
		<getLocalTransform public="1" get="inline" set="null" line="135">
			<f a=""><c path="oimo.common.Transform"/></f>
			<haxe_doc>* Returns the transform of the shape relative to the parent rigid body's transform.</haxe_doc>
		</getLocalTransform>
		<getLocalTransformTo public="1" get="inline" set="null" line="145">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `transform` to the transform of the shape relative to the parent rigid body's
	 * transform.
	 *
	 * This does not create a new instance of `Transform`.</haxe_doc>
		</getLocalTransformTo>
		<getTransform public="1" get="inline" set="null" line="152">
			<f a=""><c path="oimo.common.Transform"/></f>
			<haxe_doc>* Returns the world transform of the shape.</haxe_doc>
		</getTransform>
		<getTransformTo public="1" get="inline" set="null" line="161">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `transform` to the world transform of the shape.
	 *
	 * This does not create a new instance of `Transform`.</haxe_doc>
		</getTransformTo>
		<setLocalTransform public="1" get="inline" set="null" line="170">
			<f a="transform">
				<c path="oimo.common.Transform"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the shape's transform to `transform` relative to the parent rigid body's transform.
	 *
	 * This affects the parent rigid body's mass data.</haxe_doc>
		</setLocalTransform>
		<getDensity public="1" get="inline" set="null" line="180">
			<f a=""><x path="Float"/></f>
			<haxe_doc>* Returns the density of the shape.</haxe_doc>
		</getDensity>
		<setDensity public="1" get="inline" set="null" line="189">
			<f a="density">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the density of the shape to `density`.
	 *
	 * This affects the parent rigid body's mass data.</haxe_doc>
		</setDensity>
		<getAabb public="1" get="inline" set="null" line="200">
			<f a=""><c path="oimo.collision.geometry.Aabb"/></f>
			<haxe_doc>* Returns the AABB of the shape. The AABB may be incorrect if the shape doesn't have a
	 * parent rigid body.</haxe_doc>
		</getAabb>
		<getAabbTo public="1" get="inline" set="null" line="210">
			<f a="aabb">
				<c path="oimo.collision.geometry.Aabb"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets `aabb` to the AABB of the shape. The AABB may be incorrect if the shape doesn't have a
	 * parent rigid body.
	 *
	 * This does not create a new instance of `AABB`.</haxe_doc>
		</getAabbTo>
		<getGeometry public="1" get="inline" set="null" line="217">
			<f a=""><c path="oimo.collision.geometry.Geometry"/></f>
			<haxe_doc>* Returns the colision geometry of the shape.</haxe_doc>
		</getGeometry>
		<getRigidBody public="1" get="inline" set="null" line="225">
			<f a=""><c path="oimo.dynamics.rigidbody.RigidBody"/></f>
			<haxe_doc>* Returns the parent rigid body. This returns `null` if the shape doesn't have a parent
	 * rigid body.</haxe_doc>
		</getRigidBody>
		<getCollisionGroup public="1" get="inline" set="null" line="232">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the collision group bits the shape belongs to.</haxe_doc>
		</getCollisionGroup>
		<setCollisionGroup public="1" get="inline" set="null" line="239">
			<f a="collisionGroup">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the shape's collision group bits to `collisionGroup`.</haxe_doc>
		</setCollisionGroup>
		<getCollisionMask public="1" get="inline" set="null" line="246">
			<f a=""><x path="Int"/></f>
			<haxe_doc>* Returns the collision mask bits of the shape.</haxe_doc>
		</getCollisionMask>
		<setCollisionMask public="1" get="inline" set="null" line="253">
			<f a="collisionMask">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the shape's collision mask bits to `collisionMask`.</haxe_doc>
		</setCollisionMask>
		<getContactCallback public="1" get="inline" set="null" line="260">
			<f a=""><c path="oimo.dynamics.callback.ContactCallback"/></f>
			<haxe_doc>* Returns the contact callback of the shape.</haxe_doc>
		</getContactCallback>
		<setContactCallback public="1" get="inline" set="null" line="267">
			<f a="callback">
				<c path="oimo.dynamics.callback.ContactCallback"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Sets the contact callback of the shape to `callback`.</haxe_doc>
		</setContactCallback>
		<getPrev public="1" get="inline" set="null" line="276">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the previous shape in the rigid body.
	 *
	 * If the previous one does not exist, `null` will be returned.</haxe_doc>
		</getPrev>
		<getNext public="1" get="inline" set="null" line="285">
			<f a=""><c path="oimo.dynamics.rigidbody.Shape"/></f>
			<haxe_doc>* Returns the next shape in the rigid body.
	 *
	 * If the next one does not exist, `null` will be returned.</haxe_doc>
		</getNext>
		<new public="1" set="method" line="52">
			<f a="config">
				<c path="oimo.dynamics.rigidbody.ShapeConfig"/>
				<x path="Void"/>
			</f>
			<haxe_doc>* Creates a new shape by configuration `config`.</haxe_doc>
		</new>
		<haxe_doc>* A shape is a component of a rigid body. It attaches a collision geometry to the parent rigid body
 * with some physical properties such as coefficients of friction and restitution. The collision
 * geometry can locally be transformed relative to the parent rigid body's center of gravity.</haxe_doc>
		<meta><m n=":build"><e>oimo.m.B.bu()</e></m></meta>
	</class>
	<class path="oimo.dynamics.rigidbody.ShapeConfig" params="" file="src/oimo/dynamics/rigidbody/ShapeConfig.hx">
		<position public="1">
			<c path="oimo.common.Vec3"/>
			<haxe_doc>* The shape's local position relative to the parent rigid body's origin.</haxe_doc>
		</position>
		<rotation public="1">
			<c path="oimo.common.Mat3"/>
			<haxe_doc>* The shape's local rotation matrix relative to the parent rigid body's
	 * rotation.</haxe_doc>
		</rotation>
		<friction public="1">
			<x path="Float"/>
			<haxe_doc>* The coefficient of friction of the shape.</haxe_doc>
		</friction>
		<restitution public="1">
			<x path="Float"/>
			<haxe_doc>* The coefficient of restitution of the shape.</haxe_doc>
		</restitution>
		<density public="1">
			<x path="Float"/>
			<haxe_doc>* The density of the shape, usually in Kg/m^3.</haxe_doc>
		</density>
		<geometry public="1">
			<c path="oimo.collision.geometry.Geometry"/>
			<haxe_doc>* The collision geometry of the shape.</haxe_doc>
		</geometry>
		<collisionGroup public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The collision group bits the shape belongs to. This is used for collision
	 * filtering.
	 *
	 * Two shapes `shape1` and `shape2` will collide only if both
	 * `shape1.collisionGroup & shape2.collisionMask` and
	 * `shape2.collisionGroup & shape1.collisionMask` are not zero.]]></haxe_doc>
		</collisionGroup>
		<collisionMask public="1">
			<x path="Int"/>
			<haxe_doc><![CDATA[* The collision mask bits of the shape. This is used for collision
	 * filtering.
	 *
	 * Two shapes `shape1` and `shape2` will collide only if both
	 * `shape1.collisionGroup & shape2.collisionMask` and
	 * `shape2.collisionGroup & shape1.collisionMask` are not zero.]]></haxe_doc>
		</collisionMask>
		<contactCallback public="1">
			<c path="oimo.dynamics.callback.ContactCallback"/>
			<haxe_doc>* The contact callback of the shape. The callback methods are called
	 * when contact events the shape is involved occurred.</haxe_doc>
		</contactCallback>
		<new public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<haxe_doc>* Default constructor.</haxe_doc>
		</new>
		<haxe_doc>* A shape configuration is used for construction of shapes. An instance of
 * this class can safely be reused as a shape will not have any references
 * of a field of this class.</haxe_doc>
	</class>
	<class path="oimo.m.IMat3" params="" file="src/oimo/m/IMat3.hx" extern="1"/>
	<class path="oimo.m.IQuat" params="" file="src/oimo/m/IQuat.hx" extern="1"/>
	<class path="oimo.m.IVec3" params="" file="src/oimo/m/IVec3.hx" extern="1"/>
	<class path="oimo.m.M" params="" file="src/oimo/m/M.hx"><haxe_doc>* Expression Macro</haxe_doc></class>
	<class path="sys.io.FileInput" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/io/FileInput.hx">
		<extends path="haxe.io.Input"/>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<readByte public="1" set="method"><f a=""><x path="Int"/></f></readByte>
		<readBytes public="1" set="method"><f a="bytes:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></readBytes>
		<haxe_doc>Use `sys.io.File.read` to create a `FileInput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.io.FileOutput" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/io/FileOutput.hx">
		<extends path="haxe.io.Output"/>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<writeByte public="1" set="method"><f a="c">
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<writeBytes public="1" set="method"><f a="bytes:pos:len">
	<c path="haxe.io.Bytes"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
</f></writeBytes>
		<haxe_doc>Use `sys.io.File.write` to create a `FileOutput`.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="sys.thread.EventHandler" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/EventLoop.hx" module="sys.thread.EventLoop">
		<from><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></from>
		<this><c path="sys.thread._EventLoop.RegularEvent"/></this>
		<to><icast><c path="sys.thread._EventLoop.RegularEvent"/></icast></to>
		<impl><class path="sys.thread._EventLoop.EventHandler_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/EventLoop.hx" private="1" module="sys.thread.EventLoop" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="sys.thread.EventLoop" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/EventLoop.hx">
		<handle final="1">
			<x path="eval.luv.Loop"/>
			<meta><m n=":allow"><e>eval.luv.Loop</e></m></meta>
		</handle>
		<wakeup final="1"><x path="eval.luv.Async"/></wakeup>
		<pending expr="[]">
			<c path="Array"><f a=""><x path="Void"/></f></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</pending>
		<loop public="1" set="method" line="129">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Execute all pending events.
		Wait and execute as many events as many times `promiseEvent()` was called.
		Runs until all repeating events are cancelled and no more events is expected.

		Depending on a target platform this method may be non-reentrant. It must
		not be called from event callbacks.</haxe_doc>
		</loop>
		<consumePending set="method" line="135"><f a="?_">
	<x path="eval.luv.Async"/>
	<x path="Void"/>
</f></consumePending>
		<new public="1" set="method" line="43"><f a=""><x path="Void"/></f></new>
		<haxe_doc>An event loop implementation used for `sys.thread.Thread`</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="sys.thread.Mutex" params="" file="C:\HaxeToolkit\haxe\std/sys/thread/Mutex.hx" extern="1">
		<acquire public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>The current thread acquire the mutex or wait if not available.
		The same thread can acquire several times the same mutex but
		must release it as many times it has been acquired.</haxe_doc>
		</acquire>
		<tryAcquire public="1" set="method">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>Try to acquire the mutex, returns true if acquire or false
		if it's already locked by another thread.</haxe_doc>
		</tryAcquire>
		<release public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Release a mutex that has been acquired by the current thread.
		The behavior is undefined if the current thread does not own
		the mutex.</haxe_doc>
		</release>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Creates a mutex.</haxe_doc>
		</new>
		<haxe_doc>Creates a mutex, which can be used to acquire a temporary lock
	to access some ressource. The main difference with a lock is
	that a mutex must always be released by the owner thread.</haxe_doc>
	</class>
	<typedef path="sys.thread._Thread.ThreadImpl" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread"><c path="eval.vm.NativeThread"/></typedef>
	<abstract path="sys.thread.Thread" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/Thread.hx">
		<from><icast><t path="sys.thread._Thread.ThreadImpl"/></icast></from>
		<this><t path="sys.thread._Thread.ThreadImpl"/></this>
		<impl><class path="sys.thread._Thread.Thread_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
	<processEvents set="method" line="102" static="1">
		<f a=""><x path="Void"/></f>
		<meta><m n=":keep"/></meta>
	</processEvents>
	<meta><m n=":keep"/></meta>
</class></impl>
	</abstract>
	<class path="sys.thread._Thread.Thread_Impl_" params="" file="C:\HaxeToolkit\haxe\std/eval/_std/sys/thread/Thread.hx" private="1" module="sys.thread.Thread" final="1">
		<processEvents set="method" line="102" static="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":keep"/></meta>
		</processEvents>
		<meta><m n=":keep"/></meta>
	</class>
</haxe>