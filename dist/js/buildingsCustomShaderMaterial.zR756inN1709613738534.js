const o="varying vec4 vPosition;\nvoid main(){\n	vPosition=modelMatrix*vec4(position,1.);\n	csm_Position=position*vec3(1.);\n}",i="uniform mat4 modelMatrix;\nvarying vec4 vPosition;\nuniform vec3 uMax;\nuniform vec3 uMin;\nuniform float uOpacity;\nuniform float uBorderWidth;\nuniform vec3 uLightColor;\nuniform vec3 uColor;\nuniform float uCircleTime;\nuniform float uTime;\nuniform vec3 uTopColor;//顶部颜色\nuniform bool uGradient;\nvec4 uMax_world;\nvec4 uMin_world;\nvoid main(){\n	// 转世界坐标\n	uMax_world=modelMatrix*vec4(uMax,1.);\n	uMin_world=modelMatrix*vec4(uMin,1.);\n	vec3 distColor=uColor;\n	float residue=uTime-floor(uTime/uCircleTime)*uCircleTime;\n	float rate=residue/uCircleTime;\n	float lightOffset=rate*(uMax_world.y-uMin_world.y);\n	\n	if(uMin_world.y+lightOffset<vPosition.y&&uMin_world.y+lightOffset+uBorderWidth>vPosition.y){\n		csm_DiffuseColor=vec4(uLightColor,uOpacity);\n	}else{\n		csm_DiffuseColor=vec4(distColor,uOpacity);\n	}\n	\n	//根据高度计算颜色\n	if(uGradient){\n		float rateHight=(vPosition.y-uMin_world.y)/(uMax_world.y-uMin_world.y);\n		vec3 outColor=mix(csm_DiffuseColor.xyz,uTopColor,rateHight*2.);\n		csm_DiffuseColor=vec4(outColor,uOpacity);\n	}\n}";export{i as f,o as v};
